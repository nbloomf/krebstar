<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Finger Trees</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="../style.css">
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<article>
<header>
<h1 class="title">Finger Trees</h1>
</header>
<div class="contents">
<ul>
<li><a href="#introduction">Introduction</a>: The problem we’re solving</li>
<li><a href="#internal-types">Internal Types</a>: Building toward polymorphic recursion</li>
<li><a href="#finger-trees">Finger Trees</a>: Not as scary as it sounds</li>
<li><a href="#queries">Queries</a>: Extracting basic information from a finger tree</li>
<li><a href="#class-instances">Class Instances</a>: Code for free</li>
<li><a href="#cons-and-uncons">Cons and Uncons</a>: Building and destructuring finger trees</li>
<li><a href="#concatenation">Concatenation</a>: Joining finger trees</li>
<li><a href="#splitting">Splitting</a>: Efficient search</li>
<li><a href="#testing-and-debugging">Testing and Debugging</a>: Validation and test case generation</li>
</ul>
</div>
<div class="frontmatter">
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE DeriveGeneric #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="ot">{-# LANGUAGE InstanceSigs #-}</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">{-# LANGUAGE Rank2Types #-}</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="kw">module</span> <span class="dt">Kreb.Struct.FingerTree</span> (</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    <span class="dt">FingerTree</span>()</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  , empty</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  , singleton</a>
<a class="sourceLine" id="cb1-13" data-line-number="13"></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  , isEmpty</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  , isSingleton</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">  , readInit</a>
<a class="sourceLine" id="cb1-17" data-line-number="17">  , readLast</a>
<a class="sourceLine" id="cb1-18" data-line-number="18"></a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  , fmapFT</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">  , remeasure</a>
<a class="sourceLine" id="cb1-21" data-line-number="21">  , traverseFT</a>
<a class="sourceLine" id="cb1-22" data-line-number="22"></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">  , cons</a>
<a class="sourceLine" id="cb1-24" data-line-number="24">  , fromList</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">  , snoc</a>
<a class="sourceLine" id="cb1-26" data-line-number="26">  , reverse</a>
<a class="sourceLine" id="cb1-27" data-line-number="27">  , uncons</a>
<a class="sourceLine" id="cb1-28" data-line-number="28">  , unsnoc</a>
<a class="sourceLine" id="cb1-29" data-line-number="29">  , toAnnotatedList</a>
<a class="sourceLine" id="cb1-30" data-line-number="30"></a>
<a class="sourceLine" id="cb1-31" data-line-number="31">  , concatWithList</a>
<a class="sourceLine" id="cb1-32" data-line-number="32">  , inflateWith</a>
<a class="sourceLine" id="cb1-33" data-line-number="33"></a>
<a class="sourceLine" id="cb1-34" data-line-number="34">  , splitWithContext</a>
<a class="sourceLine" id="cb1-35" data-line-number="35">  , split</a>
<a class="sourceLine" id="cb1-36" data-line-number="36"></a>
<a class="sourceLine" id="cb1-37" data-line-number="37">  , validate</a>
<a class="sourceLine" id="cb1-38" data-line-number="38">) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-39" data-line-number="39"></a>
<a class="sourceLine" id="cb1-40" data-line-number="40"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (reverse)</a>
<a class="sourceLine" id="cb1-41" data-line-number="41"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Prelude</span> <span class="kw">as</span> <span class="dt">Prelude</span> (reverse)</a>
<a class="sourceLine" id="cb1-42" data-line-number="42"></a>
<a class="sourceLine" id="cb1-43" data-line-number="43"><span class="kw">import</span> <span class="dt">GHC.Generics</span></a>
<a class="sourceLine" id="cb1-44" data-line-number="44"></a>
<a class="sourceLine" id="cb1-45" data-line-number="45"><span class="kw">import</span> <span class="dt">Data.Monoid</span></a>
<a class="sourceLine" id="cb1-46" data-line-number="46"><span class="kw">import</span> <span class="dt">Data.Foldable</span></a>
<a class="sourceLine" id="cb1-47" data-line-number="47"><span class="kw">import</span> <span class="dt">Data.List</span> (unwords)</a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Kreb.Check</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Kreb.Struct.Valued</span></a></code></pre></div>
</div>
<section id="introduction" class="level2">
<h2>Introduction</h2>
<p>The most basic requirement of a text editor is surely that it provide Some vechanism for modeling and manipulating strings of characters. This mechanism had better be pretty robust and efficient, too, at least for common operations, since it will be doing most of the work during everyday use. Several different data structures have been developed for this purpose, including gap buffers and piece tables, but not all of them translate cleanly to a language like Haskell where mutation is very strictly controlled and evaluation is lazy by default.</p>
<p>Choosing a data structure is all about making tradeoffs. We think about our particular application and what data and operations it needs, then choose a structure that makes those operations efficient. With that in mind, what exactly do we need for our simple text editor? I can think of a few things.</p>
<ol type="1">
<li>Our data structure should essentially model a list of characters; that is, whatever weird branching or in-place mutating business is happening behind the scenes, the API is more or less that of lists.</li>
<li>Typically when editing text we’ve got a distinguished position called the <em>cursor</em> where our editing actions (insert, delete) have immediate effect. It is vital that interacting with and moving the cursor around be blazing fast, since that’s where most of the work happens.</li>
<li>Another very common action when editing text is <em>search</em>. This takes a few forms – jumping to a particular line and column position, or searching for a literal substring, or looking for matches to a given regular expression.</li>
</ol>
<p>There are others – fast syntax highlighting is nice, for instance – but these are the absolute essentials.</p>
<p>Lucky for us, there’s a powerful data structure that gives us all three, based on <em>finger trees</em>. These were introduced in the present form in the paper <a href="http://www.staff.city.ac.uk/~ross/papers/FingerTree.html"><em>Finger trees: a simple general-purpose data structure</em></a> by Hinze and Paterson. The funny name refers to the fact that trees of this type have <em>fingers</em> – distinguished locations where read and write access is cheap.<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">Finger trees are themselves an instance of a more general and very powerful pattern for designing data structures based on <em>numerical representations</em>. Okasaki’s <a href="https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf">thesis</a> on <em>Purely Functional Data Structures</em> (also available in book form) is the classic reference on this topic.<br />
<br />
</span></span></p>
<p>In this module we’ll develop an API for working with finger trees by following the Hinze and Paterson paper pretty closely. There are existing implementations of this that we could use instead, but finger trees are quite elegant and seeing how they work by rolling our own is a worthwhile exercise.</p>
<p>The secret sauce behind finger trees is that they are not a single data structure but a whole family of structures, parameterized by a monoid, which permit an efficient <em>search</em> algorithm. Different choices for the monoid yield specific structures with different behavior, but we can implement them all at once. This is a good case study on the principle that <em>throwing away detail</em> can lead to clean and general code.</p>
</section>
<section id="internal-types" class="level2">
<h2>Internal Types</h2>
<p>Recursive data types are the bread and butter of functional programming – after a little practice we whip up new recursive types without even thinking about it. Finger trees are also recursively defined, but exhibit a phenomenon called <em>polymorphic recursion</em> where at each level the “inner” and “outer” structures have different types. To get there we first need to define some auxiliary types.</p>
<p>Finger trees have nested data of two forms: the <em>fingers</em>, which provide amortized constant complexity access to a small number of values on either “end” of the tree, and the <em>branches</em>, which carry more deeply nested values. These are implemented as the types <code>Some</code> and <code>Node</code>, which are used only inside this module.</p>
<p>First for the fingers. The number of values on each end ranges from one to four. Why four? The short answer is that this is the number required to make the complexity proofs work out; it provides just the right balance between <em>immediate access</em> at the fingers and <em>deep nesting</em> in the branches. The Hinze and Paterson paper has the details. We represent the fingers with the following <code>Some</code> type.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">Some is also a sum.<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Some</span> v a</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Only1</span> v a</a>
<a class="sourceLine" id="cb3-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Only2</span> v a a</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">Only3</span> v a a a</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">Only4</span> v a a a a</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Note the <code>m</code> parameter; this is the cached monoidal value of the internal data. Specifically the value of a <code>Some</code> is the product of the values of its internal data.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  ( <span class="dt">Monoid</span> v</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Valued</span> v (<span class="dt">Some</span> v a)</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">    value w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">      <span class="dt">Only1</span> v _ <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb4-7" data-line-number="7">      <span class="dt">Only2</span> v _ _ <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb4-8" data-line-number="8">      <span class="dt">Only3</span> v _ _ _ <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb4-9" data-line-number="9">      <span class="dt">Only4</span> v _ _ _ _ <span class="ot">-&gt;</span> v</a></code></pre></div>
<p>To maintain the invariant that our cached value is accurate, it’s important that we only create <code>Some</code> values using the following <em>smart constructors</em>. The <code>Valued</code> class here is essential; this is where the <code>Monoid</code> instance on <code>m</code> is enforced.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1">only1</a>
<a class="sourceLine" id="cb5-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> v a</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">only1 a1 <span class="fu">=</span> <span class="dt">Only1</span> v a1</a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="kw">where</span> v <span class="fu">=</span> value a1</a>
<a class="sourceLine" id="cb5-6" data-line-number="6"></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">only2</a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> v a</a>
<a class="sourceLine" id="cb5-10" data-line-number="10">only2 a1 a2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb5-12" data-line-number="12">    v <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">      [ value a1, value a2 ]</a>
<a class="sourceLine" id="cb5-14" data-line-number="14">  <span class="kw">in</span> <span class="dt">Only2</span> v a1 a2 </a>
<a class="sourceLine" id="cb5-15" data-line-number="15"></a>
<a class="sourceLine" id="cb5-16" data-line-number="16">only3</a>
<a class="sourceLine" id="cb5-17" data-line-number="17"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb5-18" data-line-number="18">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> v a</a>
<a class="sourceLine" id="cb5-19" data-line-number="19">only3 a1 a2 a3 <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-20" data-line-number="20">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb5-21" data-line-number="21">    v <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb5-22" data-line-number="22">      [ value a1, value a2, value a3 ]</a>
<a class="sourceLine" id="cb5-23" data-line-number="23">  <span class="kw">in</span> <span class="dt">Only3</span> v a1 a2 a3 </a>
<a class="sourceLine" id="cb5-24" data-line-number="24"></a>
<a class="sourceLine" id="cb5-25" data-line-number="25">only4</a>
<a class="sourceLine" id="cb5-26" data-line-number="26"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb5-27" data-line-number="27">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> v a</a>
<a class="sourceLine" id="cb5-28" data-line-number="28">only4 a1 a2 a3 a4 <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-29" data-line-number="29">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb5-30" data-line-number="30">    v <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb5-31" data-line-number="31">      [ value a1, value a2, value a3, value a4 ]</a>
<a class="sourceLine" id="cb5-32" data-line-number="32">  <span class="kw">in</span> <span class="dt">Only4</span> v a1 a2 a3 a4 </a></code></pre></div>
<p>These constructors are not exposed outside this module since they are only used in the internal representation. For instance, we use them to define something like <code>fmap</code> for <code>Some</code> – although we can’t use the <code>Functor</code> typeclass for this due to the <code>Valued</code> constraint. (A common theme for types based on finger trees.)</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1">fmapSome</a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v1 a1, <span class="dt">Valued</span> v2 a2 )</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  <span class="ot">=&gt;</span> (a1 <span class="ot">-&gt;</span> a2) <span class="ot">-&gt;</span> <span class="dt">Some</span> v1 a1 <span class="ot">-&gt;</span> <span class="dt">Some</span> v2 a2</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">fmapSome f x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  <span class="dt">Only1</span> _ u1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    only1 (f u1)</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">  <span class="dt">Only2</span> _ u1 u2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-8" data-line-number="8">    only2 (f u1) (f u2)</a>
<a class="sourceLine" id="cb6-9" data-line-number="9">  <span class="dt">Only3</span> _ u1 u2 u3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-10" data-line-number="10">    only3 (f u1) (f u2) (f u3)</a>
<a class="sourceLine" id="cb6-11" data-line-number="11">  <span class="dt">Only4</span> _ u1 u2 u3 u4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-12" data-line-number="12">    only4 (f u1) (f u2) (f u3) (f u4)</a></code></pre></div>
<p>We can test our intuition for how <code>fmapSome</code> should behave with an example.</p>
<div class="doctest">
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4"><span class="co">--   x, y :: Some Count Int</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5"><span class="co">--   x = only3 1 2 3</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6"><span class="co">--   y = only3 2 4 6</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7"><span class="co">-- in y == fmapSome (*2) x</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb7-9" data-line-number="9"><span class="co">-- True</span></a></code></pre></div>
</div>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">traverseSome</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v1 a1, <span class="dt">Valued</span> v2 a2, <span class="dt">Applicative</span> f )</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="ot">=&gt;</span> (a1 <span class="ot">-&gt;</span> f a2) <span class="ot">-&gt;</span> <span class="dt">Some</span> v1 a1 <span class="ot">-&gt;</span> f (<span class="dt">Some</span> v2 a2)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">traverseSome f w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    only1 <span class="fu">&lt;$&gt;</span> f a1</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    only2 <span class="fu">&lt;$&gt;</span> f a1 <span class="fu">&lt;*&gt;</span> f a2</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">    only3 <span class="fu">&lt;$&gt;</span> f a1 <span class="fu">&lt;*&gt;</span> f a2 <span class="fu">&lt;*&gt;</span> f a3</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">  <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-12" data-line-number="12">    only4 <span class="fu">&lt;$&gt;</span> f a1 <span class="fu">&lt;*&gt;</span> f a2 <span class="fu">&lt;*&gt;</span> f a3 <span class="fu">&lt;*&gt;</span> f a4</a></code></pre></div>
<p>Next we have a <code>Foldable</code> instance (this is where we use <code>InstanceSigs</code> for clarity). Here we do have a bona fide class instance because we don’t need to use the smart constructors.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Foldable</span> (<span class="dt">Some</span> v) <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  toList</a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">    ::</span> <span class="dt">Some</span> v a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">  toList w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span> [a1]</a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span> [a1, a2]</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span> [a1, a2, a3]</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span> [a1, a2, a3, a4]</a>
<a class="sourceLine" id="cb9-9" data-line-number="9"></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">  foldr</a>
<a class="sourceLine" id="cb9-11" data-line-number="11"><span class="ot">    ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Some</span> v a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  foldr f b w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">    <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14">      f a1 b</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">    <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-16" data-line-number="16">      f a1 (f a2 b)</a>
<a class="sourceLine" id="cb9-17" data-line-number="17">    <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-18" data-line-number="18">      f a1 (f a2 (f a3 b))</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">    <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-20" data-line-number="20">      f a1 (f a2 (f a3 (f a4 b)))</a>
<a class="sourceLine" id="cb9-21" data-line-number="21"></a>
<a class="sourceLine" id="cb9-22" data-line-number="22">  foldl</a>
<a class="sourceLine" id="cb9-23" data-line-number="23"><span class="ot">    ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Some</span> v a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb9-24" data-line-number="24">  foldl f b w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-25" data-line-number="25">    <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-26" data-line-number="26">      f b a1</a>
<a class="sourceLine" id="cb9-27" data-line-number="27">    <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-28" data-line-number="28">      f (f b a1) a2</a>
<a class="sourceLine" id="cb9-29" data-line-number="29">    <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-30" data-line-number="30">      f (f (f b a1) a2) a3</a>
<a class="sourceLine" id="cb9-31" data-line-number="31">    <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-32" data-line-number="32">      f (f (f (f b a1) a2) a3) a4</a></code></pre></div>
<p>This instance is mainly used as a helper for defining the instance for <code>FingerTree</code>. Because <code>Some</code> is not exposed outside of this module we won’t rigorously check that this instance is lawful (though we will do this indirectly when we test the corresponding instance for finger trees). We can however manually check some small examples.</p>
<div class="doctest">
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"><span class="co">--   x :: Some Count Char</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="co">--   x = only3 &#39;a&#39; &#39;b&#39; &#39;c&#39;</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6"><span class="co">-- in (foldr (:) [] x, foldl (flip (:)) [] x)</span></a>
<a class="sourceLine" id="cb10-7" data-line-number="7"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8"><span class="co">-- (&quot;abc&quot;,&quot;cba&quot;)</span></a></code></pre></div>
</div>
<p>Next we have a nested tree type. Finger trees are basically rearranged 2-3 trees, and the nested <code>Node</code> type represents internal branching nodes of this sort.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Node</span> v a</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"> <span class="fu">=</span> <span class="dt">Node2</span> v a a</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"> <span class="fu">|</span> <span class="dt">Node3</span> v a a a</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Again we cache the value of the internal data, using smart constructors to maintain the integrity of the cache.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  ( <span class="dt">Monoid</span> v</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Valued</span> v (<span class="dt">Node</span> v a)</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    value w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">      <span class="dt">Node2</span> v _ _ <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb12-7" data-line-number="7">      <span class="dt">Node3</span> v _ _ _ <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb12-8" data-line-number="8"></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">node2</a>
<a class="sourceLine" id="cb12-10" data-line-number="10"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Node</span> v a</a>
<a class="sourceLine" id="cb12-12" data-line-number="12">node2 a1 a2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb12-14" data-line-number="14">    v <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb12-15" data-line-number="15">      [ value a1, value a2 ]</a>
<a class="sourceLine" id="cb12-16" data-line-number="16">  <span class="kw">in</span> <span class="dt">Node2</span> v a1 a2</a>
<a class="sourceLine" id="cb12-17" data-line-number="17"></a>
<a class="sourceLine" id="cb12-18" data-line-number="18">node3</a>
<a class="sourceLine" id="cb12-19" data-line-number="19"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb12-20" data-line-number="20">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Node</span> v a</a>
<a class="sourceLine" id="cb12-21" data-line-number="21">node3 a1 a2 a3 <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-22" data-line-number="22">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb12-23" data-line-number="23">    v <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb12-24" data-line-number="24">      [ value a1, value a2, value a3 ]</a>
<a class="sourceLine" id="cb12-25" data-line-number="25">  <span class="kw">in</span> <span class="dt">Node3</span> v a1 a2 a3</a></code></pre></div>
<p>From here we can give something like <code>fmap</code> for <code>Node</code>, again outside of the usual typeclass because of the <code>Valued</code> constraint.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">fmapNode</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v1 a1, <span class="dt">Valued</span> v2 a2 )</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="ot">=&gt;</span> (a1 <span class="ot">-&gt;</span> a2) <span class="ot">-&gt;</span> <span class="dt">Node</span> v1 a1 <span class="ot">-&gt;</span> <span class="dt">Node</span> v2 a2</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">fmapNode f x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  <span class="dt">Node2</span> _ u1 u2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    node2 (f u1) (f u2)</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  <span class="dt">Node3</span> _ u1 u2 u3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">    node3 (f u1) (f u2) (f u3)</a></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">traverseNode</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v1 a1, <span class="dt">Valued</span> v2 a2, <span class="dt">Applicative</span> f )</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="ot">=&gt;</span> (a1 <span class="ot">-&gt;</span> f a2) <span class="ot">-&gt;</span> <span class="dt">Node</span> v1 a1 <span class="ot">-&gt;</span> f (<span class="dt">Node</span> v2 a2)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">traverseNode f w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  <span class="dt">Node2</span> _ u1 u2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    node2 <span class="fu">&lt;$&gt;</span> f u1 <span class="fu">&lt;*&gt;</span> f u2</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">  <span class="dt">Node3</span> _ u1 u2 u3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    node3 <span class="fu">&lt;$&gt;</span> f u1 <span class="fu">&lt;*&gt;</span> f u2 <span class="fu">&lt;*&gt;</span> f u3</a></code></pre></div>
<p>And we need a <code>Foldable</code> instance:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Foldable</span> (<span class="dt">Node</span> v) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  toList</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="ot">    ::</span> <span class="dt">Node</span> v a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  toList w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">    <span class="dt">Node2</span> _ a1 a2 <span class="ot">-&gt;</span> [a1, a2]</a>
<a class="sourceLine" id="cb15-6" data-line-number="6">    <span class="dt">Node3</span> _ a1 a2 a3 <span class="ot">-&gt;</span> [a1, a2, a3]</a>
<a class="sourceLine" id="cb15-7" data-line-number="7"></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  foldr</a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="ot">    ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Node</span> v a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">  foldr f b w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-11" data-line-number="11">    <span class="dt">Node2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-12" data-line-number="12">      f a1 (f a2 b)</a>
<a class="sourceLine" id="cb15-13" data-line-number="13">    <span class="dt">Node3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-14" data-line-number="14">      f a1 (f a2 (f a3 b))</a>
<a class="sourceLine" id="cb15-15" data-line-number="15"></a>
<a class="sourceLine" id="cb15-16" data-line-number="16">  foldl</a>
<a class="sourceLine" id="cb15-17" data-line-number="17"><span class="ot">    ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Node</span> v a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb15-18" data-line-number="18">  foldl f b w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-19" data-line-number="19">    <span class="dt">Node2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-20" data-line-number="20">      f (f b a1) a2</a>
<a class="sourceLine" id="cb15-21" data-line-number="21">    <span class="dt">Node3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-22" data-line-number="22">      f (f (f b a1) a2) a3</a></code></pre></div>
<p>Finally, note that <code>Node</code> can be thought of as a strict subset of <code>Some</code>. We use a helper function, <code>toSome</code>, to make this formal.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">toSome</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">Node</span> v a <span class="ot">-&gt;</span> <span class="dt">Some</span> v a</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">toSome w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  <span class="dt">Node2</span> _ a1 a2 <span class="ot">-&gt;</span> only2 a1 a2</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">  <span class="dt">Node3</span> _ a1 a2 a3 <span class="ot">-&gt;</span> only3 a1 a2 a3</a></code></pre></div>
</section>
<section id="finger-trees" class="level2">
<h2>Finger Trees</h2>
<p>Now for the big show. A finger tree is either empty, or consists of a single node (with its cached value), or has some left and right fingers with a nested finger tree in the middle (with the cached product of their values).</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">data</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Stump</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Leaf</span> v a</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">Branch</span> v</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">      (<span class="dt">Some</span> v a)                <span class="co">-- left fingers</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">      (<span class="dt">FingerTree</span> v (<span class="dt">Node</span> v a)) <span class="co">-- nested tree</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7">      (<span class="dt">Some</span> v a)                <span class="co">-- right fingers</span></a></code></pre></div>
<p>Note that the second type parameter of the outer appearance of <code>FingerTree</code> is simply <code>a</code>, while on the inner appearance it is <code>Node v a</code>. This is polymorphic recursion, and it took me a while to wrap my head around what it means.</p>
<p>As with <code>Some</code> and <code>Node</code>, <code>FingerTree</code> inherits an instance of <code>Valued</code> and to maintain integrity we must only use smart constructors to define them.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  ( <span class="dt">Valued</span> v a</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Valued</span> v (<span class="dt">FingerTree</span> v a)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    value w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">      <span class="dt">Stump</span>          <span class="ot">-&gt;</span> mempty</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">      <span class="dt">Leaf</span>   v _     <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">      <span class="dt">Branch</span> v _ _ _ <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb18-9" data-line-number="9"></a>
<a class="sourceLine" id="cb18-10" data-line-number="10">stump</a>
<a class="sourceLine" id="cb18-11" data-line-number="11"><span class="ot">  ::</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">stump <span class="fu">=</span> <span class="dt">Stump</span></a>
<a class="sourceLine" id="cb18-13" data-line-number="13"></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">leaf</a>
<a class="sourceLine" id="cb18-15" data-line-number="15"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb18-16" data-line-number="16">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb18-17" data-line-number="17">leaf a <span class="fu">=</span> <span class="dt">Leaf</span> m a</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">  <span class="kw">where</span> m <span class="fu">=</span> value a</a>
<a class="sourceLine" id="cb18-19" data-line-number="19"></a>
<a class="sourceLine" id="cb18-20" data-line-number="20">branch</a>
<a class="sourceLine" id="cb18-21" data-line-number="21"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb18-22" data-line-number="22">  <span class="ot">=&gt;</span> <span class="dt">Some</span> v a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v (<span class="dt">Node</span> v a) <span class="ot">-&gt;</span> <span class="dt">Some</span> v a</a>
<a class="sourceLine" id="cb18-23" data-line-number="23">  <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb18-24" data-line-number="24">branch heads mids lasts <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-25" data-line-number="25">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb18-26" data-line-number="26">     m <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb18-27" data-line-number="27">       [ value heads, value mids, value lasts ]</a>
<a class="sourceLine" id="cb18-28" data-line-number="28">  <span class="kw">in</span> <span class="dt">Branch</span> m heads mids lasts</a></code></pre></div>
<p>These constructors are useful inside this module, where we know (and need to know) the internal structure of a finger tree. But outside this module it will be more useful to expose constructors with less concrete names.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">empty</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">empty <span class="fu">=</span> stump</a>
<a class="sourceLine" id="cb19-4" data-line-number="4"></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">singleton</a>
<a class="sourceLine" id="cb19-6" data-line-number="6"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">singleton <span class="fu">=</span> leaf</a></code></pre></div>
<p>Also, just as every <code>Node</code> can be converted into a <code>Some</code>, every <code>Some</code> can be converted to a <code>FingerTree</code>. This conversion will come in handy later so we define it here, but this code is not exposed outside of this module.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">someToFingerTree</a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">Some</span> v a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">someToFingerTree w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">  <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-6" data-line-number="6">    leaf a1</a>
<a class="sourceLine" id="cb20-7" data-line-number="7">  <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-8" data-line-number="8">    branch (only1 a1) stump (only1 a2)</a>
<a class="sourceLine" id="cb20-9" data-line-number="9">  <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-10" data-line-number="10">    branch (only2 a1 a2) stump (only1 a3)</a>
<a class="sourceLine" id="cb20-11" data-line-number="11">  <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb20-12" data-line-number="12">    branch (only2 a1 a2) stump (only2 a3 a4)</a>
<a class="sourceLine" id="cb20-13" data-line-number="13"></a>
<a class="sourceLine" id="cb20-14" data-line-number="14">maybeSomeToFingerTree</a>
<a class="sourceLine" id="cb20-15" data-line-number="15"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb20-16" data-line-number="16">  <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Some</span> v a) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb20-17" data-line-number="17">maybeSomeToFingerTree w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-18" data-line-number="18">  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> stump</a>
<a class="sourceLine" id="cb20-19" data-line-number="19">  <span class="dt">Just</span> z <span class="ot">-&gt;</span> someToFingerTree z</a></code></pre></div>
</section>
<section id="queries" class="level2">
<h2>Queries</h2>
<p>Next we define some simple structural queries on finger trees. We can detect whether the tree is empty or a singleton.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">isEmpty</a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">FingerTree</span> v a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">isEmpty x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="dt">Stump</span> <span class="ot">-&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  _     <span class="ot">-&gt;</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6"></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">isSingleton</a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb21-9" data-line-number="9">  <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> v a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10">isSingleton x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11">  <span class="dt">Leaf</span> _ _ <span class="ot">-&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb21-12" data-line-number="12">  _        <span class="ot">-&gt;</span> <span class="dt">False</span></a></code></pre></div>
<p>Next we define very basic queries for reading the first or last item in a nonempty finger tree. Recall that efficient access to these items is the point of the finger. (These are very basic; we’ll define much more powerful <em>destructors</em> which generalize this behavior in a bit.)</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">readInit</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">FingerTree</span> v a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">readInit w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4">  <span class="dt">Stump</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">  <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb22-6" data-line-number="6">  <span class="dt">Branch</span> _ as _ _ <span class="ot">-&gt;</span> <span class="kw">case</span> as <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    <span class="dt">Only1</span> _ a <span class="ot">-&gt;</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">    <span class="dt">Only2</span> _ a _ <span class="ot">-&gt;</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb22-9" data-line-number="9">    <span class="dt">Only3</span> _ a _ _ <span class="ot">-&gt;</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb22-10" data-line-number="10">    <span class="dt">Only4</span> _ a _ _ _ <span class="ot">-&gt;</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb22-11" data-line-number="11"></a>
<a class="sourceLine" id="cb22-12" data-line-number="12">readLast</a>
<a class="sourceLine" id="cb22-13" data-line-number="13"><span class="ot">  ::</span> <span class="dt">FingerTree</span> v a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb22-14" data-line-number="14">readLast w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-15" data-line-number="15">  <span class="dt">Stump</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb22-16" data-line-number="16">  <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb22-17" data-line-number="17">  <span class="dt">Branch</span> _ _ _ as <span class="ot">-&gt;</span> <span class="kw">case</span> as <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-18" data-line-number="18">    <span class="dt">Only1</span> _ a <span class="ot">-&gt;</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb22-19" data-line-number="19">    <span class="dt">Only2</span> _ _ a <span class="ot">-&gt;</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb22-20" data-line-number="20">    <span class="dt">Only3</span> _ _ _ a <span class="ot">-&gt;</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb22-21" data-line-number="21">    <span class="dt">Only4</span> _ _ _ _ a <span class="ot">-&gt;</span> <span class="dt">Just</span> a</a></code></pre></div>
</section>
<section id="class-instances" class="level2">
<h2>Class Instances</h2>
<p>It isn’t too surprising that we have a <code>Foldable</code> instance for finger trees.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Foldable</span> (<span class="dt">FingerTree</span> v) <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  toList</a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="ot">    ::</span> <span class="dt">FingerTree</span> v a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">  toList w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">    <span class="dt">Stump</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">    <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">    <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span> concat</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">      [ toList as1, concatMap toList as2, toList as3 ]</a>
<a class="sourceLine" id="cb23-9" data-line-number="9"></a>
<a class="sourceLine" id="cb23-10" data-line-number="10">  foldr</a>
<a class="sourceLine" id="cb23-11" data-line-number="11"><span class="ot">    ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb23-12" data-line-number="12">  foldr f b w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-13" data-line-number="13">    <span class="dt">Stump</span> <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb23-14" data-line-number="14">    <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> f a b</a>
<a class="sourceLine" id="cb23-15" data-line-number="15">    <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb23-16" data-line-number="16">      foldr f</a>
<a class="sourceLine" id="cb23-17" data-line-number="17">        (foldr (flip (foldr f)) (foldr f b as3) as2) as1</a>
<a class="sourceLine" id="cb23-18" data-line-number="18"></a>
<a class="sourceLine" id="cb23-19" data-line-number="19">  foldl</a>
<a class="sourceLine" id="cb23-20" data-line-number="20"><span class="ot">    ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb23-21" data-line-number="21">  foldl f b w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-22" data-line-number="22">    <span class="dt">Stump</span> <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb23-23" data-line-number="23">    <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> f b a</a>
<a class="sourceLine" id="cb23-24" data-line-number="24">    <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb23-25" data-line-number="25">      foldl f</a>
<a class="sourceLine" id="cb23-26" data-line-number="26">        (foldl (foldl f) (foldl f b as1) as2) as3</a></code></pre></div>
<p>Note that we didn’t derive the <code>Eq</code> instance for <code>FingerTree</code>. This is because in some sense the tree structure itself is only incidental, used for maintaining the fingers and caching values. The meat of the structure is the left-to-right traversal of the leaf nodes and fingers, and the derived (structural) equality instance would be too granular. To get around this we’ll instead check for equality on <code>FingerTree</code>s by converting to lists first, using the <code>Foldable</code> instance.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">FingerTree</span> v a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  a <span class="fu">==</span> b <span class="fu">=</span> (toList a) <span class="fu">==</span> (toList b)</a></code></pre></div>
<p>We’d also like for finger trees to be a functor. Unfortunately this can’t be expressed in the Haskell type system (as far as I know) due to the <code>Valued</code> class constraint. We can however define a bespoke <code>fmap</code>-like function on finger trees.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">fmapFT</a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="ot">  ::</span> forall v1 v2 a1 a2</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">   <span class="fu">.</span> ( <span class="dt">Valued</span> v1 a1, <span class="dt">Valued</span> v2 a2 )</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">  <span class="ot">=&gt;</span> (a1 <span class="ot">-&gt;</span> a2) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v1 a1 <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v2 a2</a>
<a class="sourceLine" id="cb25-5" data-line-number="5">fmapFT f x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-6" data-line-number="6">  <span class="dt">Stump</span> <span class="ot">-&gt;</span> stump</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">  <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> leaf (f a)</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">  <span class="dt">Branch</span> _ as bs cs <span class="ot">-&gt;</span> branch</a>
<a class="sourceLine" id="cb25-9" data-line-number="9">    (fmapSome f as)</a>
<a class="sourceLine" id="cb25-10" data-line-number="10">    (fmapFT (fmapNode f) bs)</a>
<a class="sourceLine" id="cb25-11" data-line-number="11">    (fmapSome f cs)</a></code></pre></div>
<p>With this version of <code>fmap</code> we can do something interesting. Mapping with <code>id</code> can swap out the cached value monoid.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">remeasure</a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="ot"> ::</span> forall v1 v2 a</a>
<a class="sourceLine" id="cb26-3" data-line-number="3">  <span class="fu">.</span> ( <span class="dt">Valued</span> v1 a, <span class="dt">Valued</span> v2 a )</a>
<a class="sourceLine" id="cb26-4" data-line-number="4"> <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> v1 a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v2 a</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">remeasure <span class="fu">=</span> fmapFT id</a></code></pre></div>
<div class="sourceCode" id="cb27"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">traverseFT</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v1 a1, <span class="dt">Valued</span> v2 a2, <span class="dt">Applicative</span> f )</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  <span class="ot">=&gt;</span> (a1 <span class="ot">-&gt;</span> f a2) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v1 a1 <span class="ot">-&gt;</span> f (<span class="dt">FingerTree</span> v2 a2)</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">traverseFT f w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5">  <span class="dt">Stump</span> <span class="ot">-&gt;</span> pure stump</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">  <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> leaf <span class="fu">&lt;$&gt;</span> f a</a>
<a class="sourceLine" id="cb27-7" data-line-number="7">  <span class="dt">Branch</span> _ as bs cs <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb27-8" data-line-number="8">    branch</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">      <span class="fu">&lt;$&gt;</span> traverseSome f as</a>
<a class="sourceLine" id="cb27-10" data-line-number="10">      <span class="fu">&lt;*&gt;</span> traverseFT (traverseNode f) bs</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">      <span class="fu">&lt;*&gt;</span> traverseSome f cs</a></code></pre></div>
</section>
<section id="cons-and-uncons" class="level2">
<h2>Cons and Uncons</h2>
<p>In this section we’ll implement four of the most important functions on finger trees, which efficiently build and decompose finger trees by adding or removing items from one of the ends.</p>
<p>The traditional name for appending an item to a list is <em>cons</em>, after the Lisp function for this operation. Given a finger tree, if the left end does not have a full complement of fingers then <code>cons</code> is a constant time operation. If it does, then we take some of the fingers and recursively <code>cons</code> them as a node to the inner tree. This is the first place where the magic numbers 4 and 3, for the numbers of fingers and children per node, respectively, become important.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1">cons</a>
<a class="sourceLine" id="cb28-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb28-3" data-line-number="3"> <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">cons u w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb28-5" data-line-number="5"> <span class="dt">Stump</span> <span class="ot">-&gt;</span> leaf u</a>
<a class="sourceLine" id="cb28-6" data-line-number="6"> <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> branch (only1 u) stump (only1 a)</a>
<a class="sourceLine" id="cb28-7" data-line-number="7"> <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span> <span class="kw">case</span> as1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb28-8" data-line-number="8">   <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb28-9" data-line-number="9">     branch (only2 u a1) as2 as3</a>
<a class="sourceLine" id="cb28-10" data-line-number="10">   <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb28-11" data-line-number="11">     branch (only3 u a1 a2) as2 as3</a>
<a class="sourceLine" id="cb28-12" data-line-number="12">   <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb28-13" data-line-number="13">     branch (only4 u a1 a2 a3) as2 as3</a>
<a class="sourceLine" id="cb28-14" data-line-number="14">   <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb28-15" data-line-number="15">     branch (only2 u a1) (cons (node3 a2 a3 a4) as2) as3</a></code></pre></div>
<p>With <code>cons</code> in hand we can now write a helper for converting lists into finger trees; this is handy for testing.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">fromList</a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb29-3" data-line-number="3"> <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">fromList <span class="fu">=</span> foldr cons stump</a></code></pre></div>
<p>At this point we can also test some interesting examples.</p>
<div class="doctest">
<div class="sourceCode" id="cb30"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb30-2" data-line-number="2"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb30-3" data-line-number="3"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb30-4" data-line-number="4"><span class="co">--   x :: FingerTree Count Char</span></a>
<a class="sourceLine" id="cb30-5" data-line-number="5"><span class="co">--   x = fromList [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</span></a>
<a class="sourceLine" id="cb30-6" data-line-number="6"><span class="co">-- in (readInit x, readLast x)</span></a>
<a class="sourceLine" id="cb30-7" data-line-number="7"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb30-8" data-line-number="8"><span class="co">-- (Just &#39;a&#39;,Just &#39;c&#39;)</span></a>
<a class="sourceLine" id="cb30-9" data-line-number="9"><span class="co">--</span></a>
<a class="sourceLine" id="cb30-10" data-line-number="10"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb30-11" data-line-number="11"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb30-12" data-line-number="12"><span class="co">--   x, y :: FingerTree Count Char</span></a>
<a class="sourceLine" id="cb30-13" data-line-number="13"><span class="co">--   x = fromList [&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]</span></a>
<a class="sourceLine" id="cb30-14" data-line-number="14"><span class="co">--   y = fromList [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]</span></a>
<a class="sourceLine" id="cb30-15" data-line-number="15"><span class="co">-- in y == cons &#39;a&#39; x</span></a>
<a class="sourceLine" id="cb30-16" data-line-number="16"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb30-17" data-line-number="17"><span class="co">-- True</span></a></code></pre></div>
</div>
<p>Before moving on, with <code>fromList</code> in hand we can also give a convenient <code>Show</code> instance. Note that the derived instance would include a lot of superfluous information about the internal structure of the tree.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1"><span class="kw">instance</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">FingerTree</span> v a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb31-2" data-line-number="2">  show a <span class="fu">=</span> <span class="st">&quot;fromList &quot;</span> <span class="fu">++</span> show (toList a)</a></code></pre></div>
<p>The mirror operation – appending on the right – is defined similarly. This is called <code>snoc</code>.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">snoc</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb32-3" data-line-number="3"> <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb32-4" data-line-number="4">snoc u w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb32-5" data-line-number="5"> <span class="dt">Stump</span> <span class="ot">-&gt;</span> leaf u</a>
<a class="sourceLine" id="cb32-6" data-line-number="6"> <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> branch (only1 a) stump (only1 u)</a>
<a class="sourceLine" id="cb32-7" data-line-number="7"> <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span> <span class="kw">case</span> as3 <span class="kw">of</span></a>
<a class="sourceLine" id="cb32-8" data-line-number="8">   <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">     branch as1 as2 (only2 a1 u)</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">   <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-11" data-line-number="11">     branch as1 as2 (only3 a1 a2 u)</a>
<a class="sourceLine" id="cb32-12" data-line-number="12">   <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-13" data-line-number="13">     branch as1 as2 (only4 a1 a2 a3 u)</a>
<a class="sourceLine" id="cb32-14" data-line-number="14">   <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-15" data-line-number="15">     branch as1 (snoc (node3 a1 a2 a3) as2) (only2 a4 u)</a></code></pre></div>
<p>With <code>snoc</code> we can reverse the tree.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">reverse</a>
<a class="sourceLine" id="cb33-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb33-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> v a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb33-4" data-line-number="4">reverse <span class="fu">=</span> foldr snoc mempty</a></code></pre></div>
<p>For example:</p>
<div class="doctest">
<div class="sourceCode" id="cb34"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb34-3" data-line-number="3"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb34-4" data-line-number="4"><span class="co">--   x, y :: FingerTree Count Char</span></a>
<a class="sourceLine" id="cb34-5" data-line-number="5"><span class="co">--   x = fromList [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</span></a>
<a class="sourceLine" id="cb34-6" data-line-number="6"><span class="co">--   y = fromList [&#39;c&#39;,&#39;b&#39;,&#39;a&#39;]</span></a>
<a class="sourceLine" id="cb34-7" data-line-number="7"><span class="co">-- in y == reverse x</span></a>
<a class="sourceLine" id="cb34-8" data-line-number="8"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb34-9" data-line-number="9"><span class="co">-- True</span></a></code></pre></div>
</div>
<p><code>cons</code> also has an inverse, called <code>uncons</code>. (The inverse here is not literal, but can be made so if instead of cons we consider the coproduct of cons with the constant <code>stump</code> function, but for our purposes here that’s splitting hairs.)</p>
<p>Like <code>cons</code>, <code>uncons</code> is very fast if the left side of the tree has fingers to spare. But if not, we have to do a kind of recursive borrowing.<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">Think “borrow” as in the usual algorithm for subtracting natural numbers.<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb35"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1">uncons</a>
<a class="sourceLine" id="cb35-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb35-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb35-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">FingerTree</span> v a)</a>
<a class="sourceLine" id="cb35-5" data-line-number="5">uncons w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb35-6" data-line-number="6">  <span class="dt">Stump</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb35-7" data-line-number="7">  <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, stump)</a>
<a class="sourceLine" id="cb35-8" data-line-number="8">  <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb35-9" data-line-number="9">    <span class="kw">let</span> (a, as) <span class="fu">=</span> uncons&#39; as1</a>
<a class="sourceLine" id="cb35-10" data-line-number="10">    <span class="kw">in</span> <span class="dt">Just</span> (a, borrowL as as2 as3)</a>
<a class="sourceLine" id="cb35-11" data-line-number="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-12" data-line-number="12">    uncons&#39;</a>
<a class="sourceLine" id="cb35-13" data-line-number="13"><span class="ot">      ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb35-14" data-line-number="14">      <span class="ot">=&gt;</span> <span class="dt">Some</span> v a</a>
<a class="sourceLine" id="cb35-15" data-line-number="15">      <span class="ot">-&gt;</span> (a, <span class="dt">Maybe</span> (<span class="dt">Some</span> v a))</a>
<a class="sourceLine" id="cb35-16" data-line-number="16">    uncons&#39; w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb35-17" data-line-number="17">      <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span> (a1, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb35-18" data-line-number="18">      <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span> (a1, <span class="dt">Just</span> (only1 a2))</a>
<a class="sourceLine" id="cb35-19" data-line-number="19">      <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span> (a1, <span class="dt">Just</span> (only2 a2 a3))</a>
<a class="sourceLine" id="cb35-20" data-line-number="20">      <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span> (a1, <span class="dt">Just</span> (only3 a2 a3 a4))</a>
<a class="sourceLine" id="cb35-21" data-line-number="21"></a>
<a class="sourceLine" id="cb35-22" data-line-number="22">borrowL</a>
<a class="sourceLine" id="cb35-23" data-line-number="23"><span class="ot"> ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb35-24" data-line-number="24"> <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Some</span> v a)</a>
<a class="sourceLine" id="cb35-25" data-line-number="25"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v (<span class="dt">Node</span> v a)</a>
<a class="sourceLine" id="cb35-26" data-line-number="26"> <span class="ot">-&gt;</span> <span class="dt">Some</span> v a</a>
<a class="sourceLine" id="cb35-27" data-line-number="27"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb35-28" data-line-number="28">borrowL w as2 as3 <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb35-29" data-line-number="29"> <span class="dt">Just</span> as1 <span class="ot">-&gt;</span> branch as1 as2 as3</a>
<a class="sourceLine" id="cb35-30" data-line-number="30"> <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">case</span> uncons as2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb35-31" data-line-number="31">   <span class="dt">Nothing</span> <span class="ot">-&gt;</span> someToFingerTree as3</a>
<a class="sourceLine" id="cb35-32" data-line-number="32">   <span class="dt">Just</span> (a, as) <span class="ot">-&gt;</span> branch (toSome a) as as3</a></code></pre></div>
<p>With <code>uncons</code>, we can define an alternate version of <code>toList</code> (from the <code>Foldable</code> class) that also returns the accumulated value annotations. This will be handy in a few places.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1">toAnnotatedList</a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb36-3" data-line-number="3"> <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> v a <span class="ot">-&gt;</span> [(a,v)]</a>
<a class="sourceLine" id="cb36-4" data-line-number="4">toAnnotatedList xs <span class="fu">=</span> foo mempty xs</a>
<a class="sourceLine" id="cb36-5" data-line-number="5"> <span class="kw">where</span></a>
<a class="sourceLine" id="cb36-6" data-line-number="6">   foo e z <span class="fu">=</span> <span class="kw">case</span> uncons z <span class="kw">of</span></a>
<a class="sourceLine" id="cb36-7" data-line-number="7">     <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb36-8" data-line-number="8">     <span class="dt">Just</span> (a, ys) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb36-9" data-line-number="9">       <span class="kw">let</span> u <span class="fu">=</span> e <span class="fu">&lt;&gt;</span> value a</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">       <span class="kw">in</span> (a, u) <span class="fu">:</span> foo u ys</a></code></pre></div>
<p>And there’s an analogous partner for <code>snoc</code>.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1">unsnoc</a>
<a class="sourceLine" id="cb37-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb37-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb37-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">FingerTree</span> v a)</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">unsnoc w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb37-6" data-line-number="6">  <span class="dt">Stump</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb37-7" data-line-number="7">  <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, stump)</a>
<a class="sourceLine" id="cb37-8" data-line-number="8">  <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb37-9" data-line-number="9">    <span class="kw">let</span> (a, as) <span class="fu">=</span> unsnoc&#39; as3</a>
<a class="sourceLine" id="cb37-10" data-line-number="10">    <span class="kw">in</span> <span class="dt">Just</span> (a, borrowR as1 as2 as)</a>
<a class="sourceLine" id="cb37-11" data-line-number="11">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-12" data-line-number="12">    unsnoc&#39;</a>
<a class="sourceLine" id="cb37-13" data-line-number="13"><span class="ot">      ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb37-14" data-line-number="14">      <span class="ot">=&gt;</span> <span class="dt">Some</span> v a</a>
<a class="sourceLine" id="cb37-15" data-line-number="15">      <span class="ot">-&gt;</span> (a, <span class="dt">Maybe</span> (<span class="dt">Some</span> v a))</a>
<a class="sourceLine" id="cb37-16" data-line-number="16">    unsnoc&#39; w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb37-17" data-line-number="17">      <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span> (a1, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb37-18" data-line-number="18">      <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span> (a2, <span class="dt">Just</span> (only1 a1))</a>
<a class="sourceLine" id="cb37-19" data-line-number="19">      <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span> (a3, <span class="dt">Just</span> (only2 a1 a2))</a>
<a class="sourceLine" id="cb37-20" data-line-number="20">      <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span> (a4, <span class="dt">Just</span> (only3 a1 a2 a3))</a>
<a class="sourceLine" id="cb37-21" data-line-number="21"></a>
<a class="sourceLine" id="cb37-22" data-line-number="22">borrowR</a>
<a class="sourceLine" id="cb37-23" data-line-number="23"><span class="ot"> ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb37-24" data-line-number="24"> <span class="ot">=&gt;</span> <span class="dt">Some</span> v a</a>
<a class="sourceLine" id="cb37-25" data-line-number="25"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v (<span class="dt">Node</span> v a)</a>
<a class="sourceLine" id="cb37-26" data-line-number="26"> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Some</span> v a)</a>
<a class="sourceLine" id="cb37-27" data-line-number="27"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb37-28" data-line-number="28">borrowR as1 as2 w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb37-29" data-line-number="29"> <span class="dt">Just</span> as3 <span class="ot">-&gt;</span> branch as1 as2 as3</a>
<a class="sourceLine" id="cb37-30" data-line-number="30"> <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">case</span> unsnoc as2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb37-31" data-line-number="31">   <span class="dt">Nothing</span> <span class="ot">-&gt;</span> someToFingerTree as1</a>
<a class="sourceLine" id="cb37-32" data-line-number="32">   <span class="dt">Just</span> (a, as) <span class="ot">-&gt;</span> branch as1 as (toSome a)</a></code></pre></div>
<p>And some examples:</p>
<div class="doctest">
<div class="sourceCode" id="cb38"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb38-3" data-line-number="3"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb38-4" data-line-number="4"><span class="co">--   x, y, z :: FingerTree Count Char</span></a>
<a class="sourceLine" id="cb38-5" data-line-number="5"><span class="co">--   x = fromList [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</span></a>
<a class="sourceLine" id="cb38-6" data-line-number="6"><span class="co">--   y = fromList [&#39;b&#39;,&#39;c&#39;]</span></a>
<a class="sourceLine" id="cb38-7" data-line-number="7"><span class="co">--   z = fromList [&#39;a&#39;,&#39;b&#39;]</span></a>
<a class="sourceLine" id="cb38-8" data-line-number="8"><span class="co">-- in</span></a>
<a class="sourceLine" id="cb38-9" data-line-number="9"><span class="co">--   ( Just (&#39;a&#39;, y) == uncons x</span></a>
<a class="sourceLine" id="cb38-10" data-line-number="10"><span class="co">--   , Just (&#39;c&#39;, z) == unsnoc x )</span></a>
<a class="sourceLine" id="cb38-11" data-line-number="11"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb38-12" data-line-number="12"><span class="co">-- (True,True)</span></a></code></pre></div>
</div>
</section>
<section id="concatenation" class="level2">
<h2>Concatenation</h2>
<p>Despite the name, finger trees are really list-like, and on such structures it’s typically handy to be able to append one list to another. The fancy word for this is <em>concatenation</em>. Before defining concatenation proper, we start with a generalized version that takes an additional list of elements to insert between the concatenands.</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1">concatWithList</a>
<a class="sourceLine" id="cb39-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb39-3" data-line-number="3"> <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb39-4" data-line-number="4"> <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb39-5" data-line-number="5"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb39-6" data-line-number="6"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb39-7" data-line-number="7">concatWithList u as v <span class="fu">=</span> <span class="kw">case</span> u <span class="kw">of</span></a>
<a class="sourceLine" id="cb39-8" data-line-number="8"> <span class="dt">Stump</span> <span class="ot">-&gt;</span> foldr cons v as</a>
<a class="sourceLine" id="cb39-9" data-line-number="9"> <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> cons a (foldr cons v as)</a>
<a class="sourceLine" id="cb39-10" data-line-number="10"> <span class="dt">Branch</span> _ us1 us2 us3 <span class="ot">-&gt;</span> <span class="kw">case</span> v <span class="kw">of</span></a>
<a class="sourceLine" id="cb39-11" data-line-number="11">   <span class="dt">Stump</span> <span class="ot">-&gt;</span> foldl (flip snoc) u as</a>
<a class="sourceLine" id="cb39-12" data-line-number="12">   <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> snoc a (foldl (flip snoc) u as)</a>
<a class="sourceLine" id="cb39-13" data-line-number="13">   <span class="dt">Branch</span> _ vs1 vs2 vs3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb39-14" data-line-number="14">     <span class="kw">let</span> ns <span class="fu">=</span> (toList us3) <span class="fu">++</span> as <span class="fu">++</span> (toList vs1)</a>
<a class="sourceLine" id="cb39-15" data-line-number="15">     <span class="kw">in</span> branch us1 (concatWithList us2 (toNodes ns) vs2) vs3</a>
<a class="sourceLine" id="cb39-16" data-line-number="16">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb39-17" data-line-number="17">    toNodes</a>
<a class="sourceLine" id="cb39-18" data-line-number="18"><span class="ot">      ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb39-19" data-line-number="19">      <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Node</span> v a]</a>
<a class="sourceLine" id="cb39-20" data-line-number="20">    toNodes w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb39-21" data-line-number="21">      [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb39-22" data-line-number="22">      [a1, a2] <span class="ot">-&gt;</span> [node2 a1 a2]</a>
<a class="sourceLine" id="cb39-23" data-line-number="23">      [a1, a2, a3] <span class="ot">-&gt;</span> [node3 a1 a2 a3]</a>
<a class="sourceLine" id="cb39-24" data-line-number="24">      [a1, a2, a3, a4] <span class="ot">-&gt;</span> [node2 a1 a2, node2 a3 a4]</a>
<a class="sourceLine" id="cb39-25" data-line-number="25">      a1<span class="fu">:</span>a2<span class="fu">:</span>a3<span class="fu">:</span>a4<span class="fu">:</span>as <span class="ot">-&gt;</span> (node3 a1 a2 a3) <span class="fu">:</span> toNodes (a4<span class="fu">:</span>as)</a>
<a class="sourceLine" id="cb39-26" data-line-number="26">      _ <span class="ot">-&gt;</span> error <span class="st">&quot;toNodes: panic&quot;</span></a></code></pre></div>
<p>We can test this with an example.</p>
<div class="doctest">
<div class="sourceCode" id="cb40"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb40-2" data-line-number="2"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb40-3" data-line-number="3"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb40-4" data-line-number="4"><span class="co">--   x1, x2, y :: FingerTree Count Char</span></a>
<a class="sourceLine" id="cb40-5" data-line-number="5"><span class="co">--   x1 = fromList [&#39;a&#39;,&#39;b&#39;]</span></a>
<a class="sourceLine" id="cb40-6" data-line-number="6"><span class="co">--   x2 = fromList [&#39;d&#39;,&#39;e&#39;]</span></a>
<a class="sourceLine" id="cb40-7" data-line-number="7"><span class="co">--   y = fromList [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]</span></a>
<a class="sourceLine" id="cb40-8" data-line-number="8"><span class="co">-- in y == concatWithList x1 [&#39;c&#39;] x2</span></a>
<a class="sourceLine" id="cb40-9" data-line-number="9"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb40-10" data-line-number="10"><span class="co">-- True</span></a></code></pre></div>
</div>
<p>Now the real <code>cat</code> is a specialization of <code>concatWithList</code>, and along with <code>empty</code> makes the type of finger trees into a monoid.</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb41-2" data-line-number="2"> ( <span class="dt">Valued</span> v a</a>
<a class="sourceLine" id="cb41-3" data-line-number="3"> ) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">FingerTree</span> v a)</a>
<a class="sourceLine" id="cb41-4" data-line-number="4"> <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-5" data-line-number="5">   u <span class="fu">&lt;&gt;</span> v <span class="fu">=</span> concatWithList u [] v</a>
<a class="sourceLine" id="cb41-6" data-line-number="6"></a>
<a class="sourceLine" id="cb41-7" data-line-number="7"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb41-8" data-line-number="8"> ( <span class="dt">Valued</span> v a</a>
<a class="sourceLine" id="cb41-9" data-line-number="9"> ) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">FingerTree</span> v a)</a>
<a class="sourceLine" id="cb41-10" data-line-number="10"> <span class="kw">where</span></a>
<a class="sourceLine" id="cb41-11" data-line-number="11">   mempty <span class="fu">=</span> empty</a></code></pre></div>
<p>We end with a kind of generalized <code>join</code> on finger trees. The intuition behind <code>inflateWith</code> is that each entry in an input finger tree is expanded to a subsequence.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1">inflateWith</a>
<a class="sourceLine" id="cb42-2" data-line-number="2"><span class="ot">  ::</span> forall v1 v2 a b</a>
<a class="sourceLine" id="cb42-3" data-line-number="3">   <span class="fu">.</span> ( <span class="dt">Valued</span> v1 a, <span class="dt">Valued</span> v2 b )</a>
<a class="sourceLine" id="cb42-4" data-line-number="4">  <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v1 a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v2 b</a>
<a class="sourceLine" id="cb42-5" data-line-number="5">inflateWith f w <span class="fu">=</span> inflate w</a>
<a class="sourceLine" id="cb42-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-7" data-line-number="7"><span class="ot">    inflate ::</span> <span class="dt">FingerTree</span> v1 a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v2 b</a>
<a class="sourceLine" id="cb42-8" data-line-number="8">    inflate w <span class="fu">=</span> <span class="kw">case</span> uncons w <span class="kw">of</span></a>
<a class="sourceLine" id="cb42-9" data-line-number="9">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> mempty</a>
<a class="sourceLine" id="cb42-10" data-line-number="10">      <span class="dt">Just</span> (a, as) <span class="ot">-&gt;</span> (fromList (f a)) <span class="fu">&lt;&gt;</span> inflate as</a></code></pre></div>
</section>
<section id="splitting" class="level2">
<h2>Splitting</h2>
<p>The killer operation on finger trees, and the reason for caching the <code>m</code> value at each node, is efficient <em>splitting</em>. This operation takes a predicate <code>p</code> on <code>m</code> and a finger tree <code>w</code> and attempts to break it into three pieces, <code>as</code>, <code>x</code>, and <code>bs</code>. We can think of <code>x</code> as a <em>search result</em> and of <code>as</code> and <code>bs</code> as the prefix and suffix of the search. Moreover, the search result must satisfy three <em>splitting properties</em>:</p>
<ol type="1">
<li>That <code>w == as &lt;&gt; singleton x &lt;&gt; bs</code> – so that splitting is a bona fide cat-factorization;</li>
<li>That <code>p (value as)</code> is false – so the portion of the list <em>up to</em> the search result doesn’t satisfy <code>p</code>; and</li>
<li>That <code>p (value as &lt;&gt; value x)</code> is true – so the portion of the list <em>up to and including</em> the search result does satisfy <code>p</code>.</li>
</ol>
<p>The internal structure of finger trees allows this to be done efficiently. In general there may be many possible places to break the tree, but with a judicious choice of <code>m</code> and the predicate we can perform some complex operations quickly.</p>
<p>It’s natural to wonder why this is a useful thing to do. Well, for a judiciously chosen monoid <code>m</code> and predicate <code>p</code>, splitting can do some interesting things. As a simple example, with the <code>Count</code> monoid and a predicate like <span class="math inline">\(p(k) = (k \geq N)\)</span> we can break the finger tree at a specific index. Later on we’ll use it to break a text buffer at a specific line and column position or screen coordinate.</p>
<p>First we need a version of this operation on the fingers. This is pretty tedious because we’re essentially using brute force to make sure the output satisfies the splitting properties. (<code>splitSome</code> is only used inside this module.) Tedious though it is, note that <code>splitSome</code> has constant complexity.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1">splitSome</a>
<a class="sourceLine" id="cb43-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb43-3" data-line-number="3"> <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">Some</span> v a</a>
<a class="sourceLine" id="cb43-4" data-line-number="4"> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Maybe</span> (<span class="dt">Some</span> v a), a, <span class="dt">Maybe</span> (<span class="dt">Some</span> v a))</a>
<a class="sourceLine" id="cb43-5" data-line-number="5">splitSome p i w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb43-6" data-line-number="6"> <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb43-7" data-line-number="7">   <span class="kw">let</span> v1 <span class="fu">=</span> i <span class="fu">&lt;&gt;</span> (value a1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb43-8" data-line-number="8">   <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb43-9" data-line-number="9">     <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb43-10" data-line-number="10">     <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb43-11" data-line-number="11"> <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb43-12" data-line-number="12">   <span class="kw">let</span> v1 <span class="fu">=</span> i <span class="fu">&lt;&gt;</span> (value a1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb43-13" data-line-number="13">   <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb43-14" data-line-number="14">     <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Just</span> (only1 a2))</a>
<a class="sourceLine" id="cb43-15" data-line-number="15">     <span class="kw">else</span></a>
<a class="sourceLine" id="cb43-16" data-line-number="16">       <span class="kw">let</span> v2 <span class="fu">=</span> v1 <span class="fu">&lt;&gt;</span> (value a2) <span class="kw">in</span></a>
<a class="sourceLine" id="cb43-17" data-line-number="17">       <span class="kw">if</span> p v2</a>
<a class="sourceLine" id="cb43-18" data-line-number="18">         <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only1 a1), a2, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb43-19" data-line-number="19">         <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb43-20" data-line-number="20"> <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb43-21" data-line-number="21">   <span class="kw">let</span> v1 <span class="fu">=</span> i <span class="fu">&lt;&gt;</span> (value a1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb43-22" data-line-number="22">   <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb43-23" data-line-number="23">     <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Just</span> (only2 a2 a3))</a>
<a class="sourceLine" id="cb43-24" data-line-number="24">     <span class="kw">else</span></a>
<a class="sourceLine" id="cb43-25" data-line-number="25">       <span class="kw">let</span> v2 <span class="fu">=</span> v1 <span class="fu">&lt;&gt;</span> (value a2) <span class="kw">in</span></a>
<a class="sourceLine" id="cb43-26" data-line-number="26">       <span class="kw">if</span> p v2</a>
<a class="sourceLine" id="cb43-27" data-line-number="27">         <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only1 a1), a2, <span class="dt">Just</span> (only1 a3))</a>
<a class="sourceLine" id="cb43-28" data-line-number="28">         <span class="kw">else</span></a>
<a class="sourceLine" id="cb43-29" data-line-number="29">           <span class="kw">let</span> v3 <span class="fu">=</span> v2 <span class="fu">&lt;&gt;</span> (value a3) <span class="kw">in</span></a>
<a class="sourceLine" id="cb43-30" data-line-number="30">           <span class="kw">if</span> p v3</a>
<a class="sourceLine" id="cb43-31" data-line-number="31">             <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only2 a1 a2), a3, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb43-32" data-line-number="32">             <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb43-33" data-line-number="33"> <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb43-34" data-line-number="34">   <span class="kw">let</span> v1 <span class="fu">=</span> i <span class="fu">&lt;&gt;</span> (value a1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb43-35" data-line-number="35">   <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb43-36" data-line-number="36">     <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Just</span> (only3 a2 a3 a4))</a>
<a class="sourceLine" id="cb43-37" data-line-number="37">     <span class="kw">else</span></a>
<a class="sourceLine" id="cb43-38" data-line-number="38">       <span class="kw">let</span> v2 <span class="fu">=</span> v1 <span class="fu">&lt;&gt;</span> (value a2) <span class="kw">in</span></a>
<a class="sourceLine" id="cb43-39" data-line-number="39">         <span class="kw">if</span> p v2</a>
<a class="sourceLine" id="cb43-40" data-line-number="40">           <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only1 a1), a2, <span class="dt">Just</span> (only2 a3 a4))</a>
<a class="sourceLine" id="cb43-41" data-line-number="41">           <span class="kw">else</span></a>
<a class="sourceLine" id="cb43-42" data-line-number="42">             <span class="kw">let</span> v3 <span class="fu">=</span> v2 <span class="fu">&lt;&gt;</span> (value a3) <span class="kw">in</span></a>
<a class="sourceLine" id="cb43-43" data-line-number="43">               <span class="kw">if</span> p v3</a>
<a class="sourceLine" id="cb43-44" data-line-number="44">                 <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only2 a1 a2), a3, <span class="dt">Just</span> (only1 a4))</a>
<a class="sourceLine" id="cb43-45" data-line-number="45">                 <span class="kw">else</span></a>
<a class="sourceLine" id="cb43-46" data-line-number="46">                   <span class="kw">let</span> v4 <span class="fu">=</span> v3 <span class="fu">&lt;&gt;</span> (value a4) <span class="kw">in</span></a>
<a class="sourceLine" id="cb43-47" data-line-number="47">                     <span class="kw">if</span> p v4</a>
<a class="sourceLine" id="cb43-48" data-line-number="48">                       <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only3 a1 a2 a3), a4, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb43-49" data-line-number="49">                       <span class="kw">else</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>Next we define a version of split that prepends a given monoid value on the left before searching. This is a stepping stone toward our main splitting function, but is also useful in its own right; the extra <code>m</code> parameter acts like a kind of value context.</p>
<p>We use the cached value at each node to decide whether to continue the search down a given branch or ignore it. In the complexity analysis of this algorithm (available in the Hinze and Paterson paper) this, with the branching factor of the tree, is where the efficiency comes from.</p>
<p>Note also that the input to <code>splitWithContext</code> needs to satisfy a precondition: the value of the entire finger tree should be true. This is (I think) what guarantees that the search will succeed.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1">splitWithContext</a>
<a class="sourceLine" id="cb44-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb44-3" data-line-number="3"> <span class="ot">=&gt;</span> v <span class="ot">-&gt;</span> (v <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb44-4" data-line-number="4"> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">FingerTree</span> v a, a, <span class="dt">FingerTree</span> v a)</a>
<a class="sourceLine" id="cb44-5" data-line-number="5">splitWithContext i p w <span class="fu">=</span></a>
<a class="sourceLine" id="cb44-6" data-line-number="6">  <span class="kw">if</span> p i</a>
<a class="sourceLine" id="cb44-7" data-line-number="7">    <span class="kw">then</span> <span class="kw">case</span> uncons w <span class="kw">of</span></a>
<a class="sourceLine" id="cb44-8" data-line-number="8">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb44-9" data-line-number="9">      <span class="dt">Just</span> (x,bs) <span class="ot">-&gt;</span> <span class="dt">Just</span> (mempty, x, bs)</a>
<a class="sourceLine" id="cb44-10" data-line-number="10">    <span class="kw">else</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb44-11" data-line-number="11">      <span class="dt">Stump</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb44-12" data-line-number="12">      <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb44-13" data-line-number="13">        <span class="kw">let</span> va <span class="fu">=</span> i <span class="fu">&lt;&gt;</span> (value a) <span class="kw">in</span></a>
<a class="sourceLine" id="cb44-14" data-line-number="14">        <span class="kw">if</span> p va</a>
<a class="sourceLine" id="cb44-15" data-line-number="15">          <span class="kw">then</span> <span class="dt">Just</span> (stump, a, stump)</a>
<a class="sourceLine" id="cb44-16" data-line-number="16">          <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb44-17" data-line-number="17">      <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb44-18" data-line-number="18">        <span class="kw">let</span> vas1 <span class="fu">=</span> i <span class="fu">&lt;&gt;</span> (value as1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb44-19" data-line-number="19">        <span class="kw">if</span> p vas1</a>
<a class="sourceLine" id="cb44-20" data-line-number="20">          <span class="co">-- there&#39;s a match in the left fingers</span></a>
<a class="sourceLine" id="cb44-21" data-line-number="21">          <span class="kw">then</span> <span class="kw">case</span> (splitSome p i as1) <span class="kw">of</span></a>
<a class="sourceLine" id="cb44-22" data-line-number="22">            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;split: panic (1)&quot;</span></a>
<a class="sourceLine" id="cb44-23" data-line-number="23">            <span class="dt">Just</span> (ds1, x, ds3) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb44-24" data-line-number="24">              <span class="kw">let</span></a>
<a class="sourceLine" id="cb44-25" data-line-number="25">                bs1 <span class="fu">=</span> maybeSomeToFingerTree ds1</a>
<a class="sourceLine" id="cb44-26" data-line-number="26">                bs3 <span class="fu">=</span> borrowL ds3 as2 as3</a>
<a class="sourceLine" id="cb44-27" data-line-number="27">              <span class="kw">in</span> <span class="dt">Just</span> (bs1, x, bs3)</a>
<a class="sourceLine" id="cb44-28" data-line-number="28">          <span class="kw">else</span></a>
<a class="sourceLine" id="cb44-29" data-line-number="29">            <span class="kw">let</span> vas2 <span class="fu">=</span> vas1 <span class="fu">&lt;&gt;</span> (value as2) <span class="kw">in</span></a>
<a class="sourceLine" id="cb44-30" data-line-number="30">            <span class="kw">if</span> p vas2</a>
<a class="sourceLine" id="cb44-31" data-line-number="31">              <span class="co">-- there&#39;s a match in the spine</span></a>
<a class="sourceLine" id="cb44-32" data-line-number="32">              <span class="kw">then</span> <span class="kw">case</span> splitWithContext vas1 p as2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb44-33" data-line-number="33">                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;split: panic (2)&quot;</span></a>
<a class="sourceLine" id="cb44-34" data-line-number="34">                <span class="dt">Just</span> (cs1, xs, cs3) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb44-35" data-line-number="35">                  <span class="kw">let</span> vs <span class="fu">=</span> vas1 <span class="fu">&lt;&gt;</span> (value cs1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb44-36" data-line-number="36">                  <span class="kw">case</span> splitSome p vs (toSome xs) <span class="kw">of</span></a>
<a class="sourceLine" id="cb44-37" data-line-number="37">                    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;split: panic (3)&quot;</span></a>
<a class="sourceLine" id="cb44-38" data-line-number="38">                    <span class="dt">Just</span> (ds1, x, ds3) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb44-39" data-line-number="39">                      <span class="kw">let</span></a>
<a class="sourceLine" id="cb44-40" data-line-number="40">                        bs1 <span class="fu">=</span> borrowR as1 cs1 ds1</a>
<a class="sourceLine" id="cb44-41" data-line-number="41">                        bs3 <span class="fu">=</span> borrowL ds3 cs3 as3</a>
<a class="sourceLine" id="cb44-42" data-line-number="42">                      <span class="kw">in</span> <span class="dt">Just</span> (bs1, x, bs3)</a>
<a class="sourceLine" id="cb44-43" data-line-number="43">              <span class="kw">else</span></a>
<a class="sourceLine" id="cb44-44" data-line-number="44">                <span class="kw">let</span> vas3 <span class="fu">=</span> vas2 <span class="fu">&lt;&gt;</span> (value as3) <span class="kw">in</span></a>
<a class="sourceLine" id="cb44-45" data-line-number="45">                <span class="kw">if</span> p vas3</a>
<a class="sourceLine" id="cb44-46" data-line-number="46">                  <span class="co">-- there&#39;s a match in the right fingers</span></a>
<a class="sourceLine" id="cb44-47" data-line-number="47">                  <span class="kw">then</span> <span class="kw">case</span> (splitSome p vas2 as3) <span class="kw">of</span></a>
<a class="sourceLine" id="cb44-48" data-line-number="48">                    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;split: panic (4)&quot;</span></a>
<a class="sourceLine" id="cb44-49" data-line-number="49">                    <span class="dt">Just</span> (ds1, x, ds3) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb44-50" data-line-number="50">                      <span class="kw">let</span></a>
<a class="sourceLine" id="cb44-51" data-line-number="51">                        bs1 <span class="fu">=</span> borrowR as1 as2 ds1</a>
<a class="sourceLine" id="cb44-52" data-line-number="52">                        bs3 <span class="fu">=</span> maybeSomeToFingerTree ds3</a>
<a class="sourceLine" id="cb44-53" data-line-number="53">                      <span class="kw">in</span> <span class="dt">Just</span> (bs1, x, bs3)</a>
<a class="sourceLine" id="cb44-54" data-line-number="54">                  <span class="kw">else</span> <span class="dt">Nothing</span> <span class="co">-- precondition violated</span></a></code></pre></div>
<p>Now the general <code>split</code> function just specializes <code>splitWithContext</code> to the identity.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1">split</a>
<a class="sourceLine" id="cb45-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb45-3" data-line-number="3"> <span class="ot">=&gt;</span> (v <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb45-4" data-line-number="4"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a</a>
<a class="sourceLine" id="cb45-5" data-line-number="5"> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">FingerTree</span> v a, a, <span class="dt">FingerTree</span> v a)</a>
<a class="sourceLine" id="cb45-6" data-line-number="6">split p w <span class="fu">=</span> splitWithContext mempty p w</a></code></pre></div>
<p>Now’s a good time for some examples.</p>
<div class="doctest">
<div class="sourceCode" id="cb46"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" data-line-number="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb46-2" data-line-number="2"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb46-3" data-line-number="3"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb46-4" data-line-number="4"><span class="co">--   x :: FingerTree Count Char</span></a>
<a class="sourceLine" id="cb46-5" data-line-number="5"><span class="co">--   x = fromList [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;]</span></a>
<a class="sourceLine" id="cb46-6" data-line-number="6"><span class="co">--   --</span></a>
<a class="sourceLine" id="cb46-7" data-line-number="7"><span class="co">--   us, vs :: FingerTree Count Char</span></a>
<a class="sourceLine" id="cb46-8" data-line-number="8"><span class="co">--   us = fromList [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]</span></a>
<a class="sourceLine" id="cb46-9" data-line-number="9"><span class="co">--   vs = fromList [&#39;e&#39;]</span></a>
<a class="sourceLine" id="cb46-10" data-line-number="10"><span class="co">--   --</span></a>
<a class="sourceLine" id="cb46-11" data-line-number="11"><span class="co">--   p :: Count -&gt; Bool</span></a>
<a class="sourceLine" id="cb46-12" data-line-number="12"><span class="co">--   p (Count k) = k &gt; 3</span></a>
<a class="sourceLine" id="cb46-13" data-line-number="13"><span class="co">-- in Just (us, &#39;d&#39;, vs) == split p x</span></a>
<a class="sourceLine" id="cb46-14" data-line-number="14"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb46-15" data-line-number="15"><span class="co">-- True</span></a>
<a class="sourceLine" id="cb46-16" data-line-number="16"><span class="co">--</span></a>
<a class="sourceLine" id="cb46-17" data-line-number="17"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb46-18" data-line-number="18"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb46-19" data-line-number="19"><span class="co">--   x :: FingerTree Count Char</span></a>
<a class="sourceLine" id="cb46-20" data-line-number="20"><span class="co">--   x = fromList [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]</span></a>
<a class="sourceLine" id="cb46-21" data-line-number="21"><span class="co">--   --</span></a>
<a class="sourceLine" id="cb46-22" data-line-number="22"><span class="co">--   us, vs :: FingerTree Count Char</span></a>
<a class="sourceLine" id="cb46-23" data-line-number="23"><span class="co">--   us = fromList [&#39;a&#39;]</span></a>
<a class="sourceLine" id="cb46-24" data-line-number="24"><span class="co">--   vs = fromList [&#39;c&#39;,&#39;d&#39;]</span></a>
<a class="sourceLine" id="cb46-25" data-line-number="25"><span class="co">--   --</span></a>
<a class="sourceLine" id="cb46-26" data-line-number="26"><span class="co">--   p :: Count -&gt; Bool</span></a>
<a class="sourceLine" id="cb46-27" data-line-number="27"><span class="co">--   p (Count k) = k &gt;= 2</span></a>
<a class="sourceLine" id="cb46-28" data-line-number="28"><span class="co">-- in Just (us, &#39;b&#39;, vs) == split p x</span></a>
<a class="sourceLine" id="cb46-29" data-line-number="29"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb46-30" data-line-number="30"><span class="co">-- True</span></a>
<a class="sourceLine" id="cb46-31" data-line-number="31"><span class="co">--</span></a>
<a class="sourceLine" id="cb46-32" data-line-number="32"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb46-33" data-line-number="33"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb46-34" data-line-number="34"><span class="co">--   x :: FingerTree Count Char</span></a>
<a class="sourceLine" id="cb46-35" data-line-number="35"><span class="co">--   x = fromList [&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]</span></a>
<a class="sourceLine" id="cb46-36" data-line-number="36"><span class="co">--   --</span></a>
<a class="sourceLine" id="cb46-37" data-line-number="37"><span class="co">--   p :: Count -&gt; Bool</span></a>
<a class="sourceLine" id="cb46-38" data-line-number="38"><span class="co">--   p (Count k) = k &gt;= 7</span></a>
<a class="sourceLine" id="cb46-39" data-line-number="39"><span class="co">-- in split p x</span></a>
<a class="sourceLine" id="cb46-40" data-line-number="40"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb46-41" data-line-number="41"><span class="co">-- Nothing</span></a></code></pre></div>
</div>
</section>
<section id="testing-and-debugging" class="level2">
<h2>Testing and Debugging</h2>
<p>Finally we define some utilities to help with testing. First, to interoperate with our testing framework, we need <code>FingerTree</code> to be an instance of some type classes.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb47-2" data-line-number="2">  ( <span class="dt">Arb</span> a, <span class="dt">Valued</span> v a</a>
<a class="sourceLine" id="cb47-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Arb</span> (<span class="dt">FingerTree</span> v a)</a>
<a class="sourceLine" id="cb47-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb47-5" data-line-number="5">    arb <span class="fu">=</span> fromList <span class="fu">&lt;$&gt;</span> arb</a>
<a class="sourceLine" id="cb47-6" data-line-number="6"></a>
<a class="sourceLine" id="cb47-7" data-line-number="7"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb47-8" data-line-number="8">  ( <span class="dt">Prune</span> a, <span class="dt">Valued</span> v a</a>
<a class="sourceLine" id="cb47-9" data-line-number="9">  ) <span class="ot">=&gt;</span> <span class="dt">Prune</span> (<span class="dt">FingerTree</span> v a)</a>
<a class="sourceLine" id="cb47-10" data-line-number="10">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb47-11" data-line-number="11">    prune <span class="fu">=</span></a>
<a class="sourceLine" id="cb47-12" data-line-number="12">      map fromList <span class="fu">.</span> prune <span class="fu">.</span> toList</a>
<a class="sourceLine" id="cb47-13" data-line-number="13"></a>
<a class="sourceLine" id="cb47-14" data-line-number="14"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb47-15" data-line-number="15">  ( <span class="dt">CoArb</span> a, <span class="dt">Valued</span> v a</a>
<a class="sourceLine" id="cb47-16" data-line-number="16">  ) <span class="ot">=&gt;</span> <span class="dt">CoArb</span> (<span class="dt">FingerTree</span> v a)</a>
<a class="sourceLine" id="cb47-17" data-line-number="17">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb47-18" data-line-number="18">    coarb x <span class="fu">=</span> coarb (toList x)</a>
<a class="sourceLine" id="cb47-19" data-line-number="19"></a>
<a class="sourceLine" id="cb47-20" data-line-number="20"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb47-21" data-line-number="21">  ( <span class="dt">MakeTo</span> a, <span class="dt">Valued</span> v a</a>
<a class="sourceLine" id="cb47-22" data-line-number="22">  ) <span class="ot">=&gt;</span> <span class="dt">MakeTo</span> (<span class="dt">FingerTree</span> v a)</a>
<a class="sourceLine" id="cb47-23" data-line-number="23">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb47-24" data-line-number="24">    makeTo <span class="fu">=</span> makeToExtendWith</a>
<a class="sourceLine" id="cb47-25" data-line-number="25">      makeTo toList fromList</a></code></pre></div>
<p>Next, recall that our finger tree type has an internal invariant that needs to be maintained in order for the complexity and correctness proofs of our algorithms to hold. Namely, the cached monoidal value at each Node vust be the product of the monoidal values of the node’s contents. We introduce a function (only used for testing) to check this. Note how polymorphic recursion makes this a little tricky.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" data-line-number="1">validate</a>
<a class="sourceLine" id="cb48-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Eq</span> v, <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb48-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> v a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb48-4" data-line-number="4">validate <span class="fu">=</span> validateNested (const <span class="dt">True</span>)</a>
<a class="sourceLine" id="cb48-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb48-6" data-line-number="6">    validateNested</a>
<a class="sourceLine" id="cb48-7" data-line-number="7"><span class="ot">      ::</span> ( <span class="dt">Eq</span> v, <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb48-8" data-line-number="8">      <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> v a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb48-9" data-line-number="9">    validateNested valid xs <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb48-10" data-line-number="10">      <span class="dt">Stump</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb48-11" data-line-number="11">        <span class="dt">True</span></a>
<a class="sourceLine" id="cb48-12" data-line-number="12">      <span class="dt">Leaf</span> m a <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb48-13" data-line-number="13">        m <span class="fu">==</span> value a</a>
<a class="sourceLine" id="cb48-14" data-line-number="14">      <span class="dt">Branch</span> m as x bs <span class="ot">-&gt;</span> and</a>
<a class="sourceLine" id="cb48-15" data-line-number="15">        [ validateSome valid as</a>
<a class="sourceLine" id="cb48-16" data-line-number="16">        , validateNested (validateNode valid) x</a>
<a class="sourceLine" id="cb48-17" data-line-number="17">        , validateSome valid bs</a>
<a class="sourceLine" id="cb48-18" data-line-number="18">        , m <span class="fu">==</span> mconcat [ value as, value x, value bs ]</a>
<a class="sourceLine" id="cb48-19" data-line-number="19">        ]</a>
<a class="sourceLine" id="cb48-20" data-line-number="20"></a>
<a class="sourceLine" id="cb48-21" data-line-number="21">    validateSome</a>
<a class="sourceLine" id="cb48-22" data-line-number="22"><span class="ot">      ::</span> ( <span class="dt">Eq</span> v, <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb48-23" data-line-number="23">      <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Some</span> v a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb48-24" data-line-number="24">    validateSome valid x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb48-25" data-line-number="25">      <span class="dt">Only1</span> v a1 <span class="ot">-&gt;</span> and</a>
<a class="sourceLine" id="cb48-26" data-line-number="26">        [ v <span class="fu">==</span> value a1</a>
<a class="sourceLine" id="cb48-27" data-line-number="27">        , valid a1</a>
<a class="sourceLine" id="cb48-28" data-line-number="28">        ]</a>
<a class="sourceLine" id="cb48-29" data-line-number="29">      <span class="dt">Only2</span> v a1 a2 <span class="ot">-&gt;</span> and</a>
<a class="sourceLine" id="cb48-30" data-line-number="30">        [ v <span class="fu">==</span> mconcat [ value a1, value a2 ]</a>
<a class="sourceLine" id="cb48-31" data-line-number="31">        , valid a1, valid a2</a>
<a class="sourceLine" id="cb48-32" data-line-number="32">        ]</a>
<a class="sourceLine" id="cb48-33" data-line-number="33">      <span class="dt">Only3</span> v a1 a2 a3 <span class="ot">-&gt;</span> and</a>
<a class="sourceLine" id="cb48-34" data-line-number="34">        [ v <span class="fu">==</span> mconcat [ value a1, value a2, value a3 ]</a>
<a class="sourceLine" id="cb48-35" data-line-number="35">        , valid a1, valid a2, valid a3</a>
<a class="sourceLine" id="cb48-36" data-line-number="36">        ]</a>
<a class="sourceLine" id="cb48-37" data-line-number="37">      <span class="dt">Only4</span> v a1 a2 a3 a4 <span class="ot">-&gt;</span> and</a>
<a class="sourceLine" id="cb48-38" data-line-number="38">        [ v <span class="fu">==</span> mconcat [ value a1, value a2, value a3, value a4 ]</a>
<a class="sourceLine" id="cb48-39" data-line-number="39">        , valid a1, valid a2, valid a3, valid a4</a>
<a class="sourceLine" id="cb48-40" data-line-number="40">        ]</a>
<a class="sourceLine" id="cb48-41" data-line-number="41"></a>
<a class="sourceLine" id="cb48-42" data-line-number="42">    validateNode</a>
<a class="sourceLine" id="cb48-43" data-line-number="43"><span class="ot">      ::</span> ( <span class="dt">Eq</span> v, <span class="dt">Valued</span> v a )</a>
<a class="sourceLine" id="cb48-44" data-line-number="44">      <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Node</span> v a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb48-45" data-line-number="45">    validateNode valid x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb48-46" data-line-number="46">      <span class="dt">Node2</span> v a1 a2 <span class="ot">-&gt;</span> and</a>
<a class="sourceLine" id="cb48-47" data-line-number="47">        [ v <span class="fu">==</span> mconcat [ value a1, value a2 ]</a>
<a class="sourceLine" id="cb48-48" data-line-number="48">        , valid a1, valid a2</a>
<a class="sourceLine" id="cb48-49" data-line-number="49">        ]</a>
<a class="sourceLine" id="cb48-50" data-line-number="50">      <span class="dt">Node3</span> v a1 a2 a3 <span class="ot">-&gt;</span> and</a>
<a class="sourceLine" id="cb48-51" data-line-number="51">        [ v <span class="fu">==</span> mconcat [ value a1, value a2, value a3 ]</a>
<a class="sourceLine" id="cb48-52" data-line-number="52">        , valid a1, valid a2, valid a3</a>
<a class="sourceLine" id="cb48-53" data-line-number="53">        ]</a></code></pre></div>
<div class="epigraph">
<blockquote>
<p>I can whistle with my fingers, especially if I have a whistle.</p>
<footer>
Mitch Hedberg, <cite>Live at the Congress Theater in Chicago, 2004</cite>
</footer>
</blockquote>
</div>
</section>
</article>
</body>
</html>
