<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Red-Black Trees</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="../style.css">
</head>
<body>
<article>
<header>
<h1 class="title">Red-Black Trees</h1>
</header>
<div class="contents">
<ul>
<li><a href="#introduction">Introduction</a>: The problem we’re solving</li>
<li><a href="#types-and-terms">Types and Terms</a>: Type-level encoding</li>
<li><a href="#enforcing-invariants-statically">Enforcing Invariants Statically</a>: Defining errors out of existence</li>
<li><a href="#class-instances">Class Instances</a>: Code for free</li>
<li><a href="#basic-api">Basic API</a>: But just the <em>very</em> basics</li>
<li><a href="#insertion">Insertion</a>: Putting stuff in the tree</li>
<li><a href="#deletion">Deletion</a>: Taking stuff out of the tree</li>
</ul>
</div>
<div class="frontmatter">
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">{-# LANGUAGE FlexibleInstances #-}</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">{-# LANGUAGE KindSignatures #-}</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">{-# LANGUAGE TypeOperators #-}</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="ot">{-# LANGUAGE TypeFamilies #-}</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">{-# LANGUAGE DataKinds #-}</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ot">{-# LANGUAGE PolyKinds #-}</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"><span class="ot">{-# LANGUAGE GADTs #-}</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"></a>
<a class="sourceLine" id="cb1-11" data-line-number="11"><span class="kw">module</span> <span class="dt">Kreb.Struct.RedBlackTree</span> (</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">    <span class="dt">RedBlackTree</span>()</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  , empty</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  , member</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">  , toList</a>
<a class="sourceLine" id="cb1-16" data-line-number="16">  , maxElt</a>
<a class="sourceLine" id="cb1-17" data-line-number="17"></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  , insert</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  , fromList</a>
<a class="sourceLine" id="cb1-20" data-line-number="20"></a>
<a class="sourceLine" id="cb1-21" data-line-number="21">  , delete</a>
<a class="sourceLine" id="cb1-22" data-line-number="22">) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-23" data-line-number="23"></a>
<a class="sourceLine" id="cb1-24" data-line-number="24"><span class="kw">import</span> <span class="dt">Kreb.Check</span></a></code></pre></div>
</div>
<section id="introduction" class="level2">
<h2>Introduction</h2>
<p>This module implements a data structure called a <em>red-black tree</em>. Structurally this is a binary tree, but the name comes from the fact that each node in the tree has an additional bit of metadata – a color, which is traditionally either red or black. In addition, the arrangement of colors in the tree must satisfy some constraints:</p>
<ol type="1">
<li>The root and all leaves are black.</li>
<li>Both children of a red node are black.</li>
<li>All paths from a given node to any of its descendant leaves contain the same number of black nodes.</li>
</ol>
<p>The constraints conspire to make the overall tree height-balanced enough to ensure optimal asymptotic bounds on insertion and deletion of nodes. This makes red-black trees a good structure for implementing sets – unordered collections of elements with no duplicates – especially where we intend for the structure to stay around and be manipulated for a long time. But crucially, any operations on the tree must maintain these constraints as invariants in order to preserve the asymptotic complexity.</p>
<p>Red-black trees are widely used in functional languages, but they are tricky to implement correctly. In all material respects this version is taken from code written by <a href="https://github.com/sweirich/dth">Stephanie Weirich</a>, who also credits Dan Licata and John Hughes, and with a deletion strategy developed by Matt Might. Notably, Weirich’s code uses <em>dependent types</em>, that is, types which depend on terms, to enforce the red-black invariants statically.<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">This example is also the subject of an excellent <a href="https://www.youtube.com/watch?v=n-b1PYbRUOY">talk by Weirich</a> on using dependent types in Haskell.<br />
<br />
</span></span> This accomplishes two major feats: it gets the <em>compiler</em> to help prove that the invariants hold, and means that invariant checks at runtime (or even in tests) are unnecessary.</p>
<p>I will stumble around and try my best to understand and explain this code. But similar to our finger tree module, on some level here and more so than most of the other modules in this project, I’m aping someone else’s insights. But that’s okay! This is how we learn.</p>
</section>
<section id="types-and-terms" class="level2">
<h2>Types and Terms</h2>
<p>The red-black tree invariants involve two kinds of metadata: the <em>color</em> of the current node, and the <em>number</em> of black descendants in any path to the leaves. In order to guarantee the invariants statically we need representations of this data at the type-level. Haskell’s <code>DataKinds</code> extension provides an elegant way to do this. Normally, a <code>data</code> declaration defines a <em>type</em> along with some <em>data constructors</em> for building values of that type. But with <code>DataKinds</code> enabled, the <code>data</code> keyword also defines a <em>kind</em> along with some <em>type constructors</em> for building types of that kind. The classic example is the type of Peano numbers, defined like so.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">S</span> <span class="dt">Nat</span></a></code></pre></div>
<p>This defines a type, <code>Nat</code>, with two value constructors. But it also defines a <em>kind</em>, <code>Nat</code>, with two type constructors. In GHCi we can use <code>:k</code> to infer the kind of a type expression just like <code>:t</code> infers the type of a value expression. For example:</p>
<div class="doctest">
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2"><span class="co">-- &gt;&gt;&gt; :t Z</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="co">-- Z :: Nat</span></a>
<a class="sourceLine" id="cb3-4" data-line-number="4"><span class="co">--</span></a>
<a class="sourceLine" id="cb3-5" data-line-number="5"><span class="co">-- &gt;&gt;&gt; :set -XDataKinds</span></a>
<a class="sourceLine" id="cb3-6" data-line-number="6"><span class="co">-- &gt;&gt;&gt; :k Z</span></a>
<a class="sourceLine" id="cb3-7" data-line-number="7"><span class="co">-- Z :: Nat</span></a></code></pre></div>
</div>
<p>This is a powerful tool for building type constraints, and we can also promote the node colors to the type level. It turns out that there’s a nice implementation of the delete function on red-black trees using an intermediate form with more than two colors, so our <code>Color</code> kind looks like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Color</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Red</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Black</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">DoubleBlack</span>   <span class="co">-- only used internally</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">NegativeBlack</span> <span class="co">-- only used internally</span></a></code></pre></div>
<p>Note that we don’t need <code>Eq</code> or <code>Show</code> instances on either <code>Nat</code> or <code>Color</code> – we’re not using these as types, but as <em>kinds</em>, and values of the <em>type</em> <code>Nat</code> or <code>Color</code> will never actually exist in our program at either compile or run time. We do, however, need a way to “reify” the <code>Color</code> kind at the value level, and the best way to do this uses a GADT.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ValueColor</span> (<span class="ot">c ::</span> <span class="dt">Color</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="dt">R</span><span class="ot">  ::</span> <span class="dt">ValueColor</span> <span class="dt">Red</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="dt">B</span><span class="ot">  ::</span> <span class="dt">ValueColor</span> <span class="dt">Black</span></a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="dt">BB</span><span class="ot"> ::</span> <span class="dt">ValueColor</span> <span class="dt">DoubleBlack</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">  <span class="dt">NB</span><span class="ot"> ::</span> <span class="dt">ValueColor</span> <span class="dt">NegativeBlack</span></a></code></pre></div>
<p>Note how <code>Color</code> appears as a constraint on <code>c</code>, with the colors as types. Using a GADT here allows the constructors of <code>ValueColor</code> to have distinct monomorphic type arguments. We can give a show instance for <code>ValueColor</code> here, useful mostly for debugging.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Show</span> (<span class="dt">ValueColor</span> c) <span class="kw">where</span>  </a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  show x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="dt">R</span>  <span class="ot">-&gt;</span> <span class="st">&quot;R&quot;</span></a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="dt">B</span>  <span class="ot">-&gt;</span> <span class="st">&quot;B&quot;</span></a>
<a class="sourceLine" id="cb6-5" data-line-number="5">    <span class="dt">BB</span> <span class="ot">-&gt;</span> <span class="st">&quot;BB&quot;</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    <span class="dt">NB</span> <span class="ot">-&gt;</span> <span class="st">&quot;NB&quot;</span></a></code></pre></div>
<p>We will also need a way to express that two types of kind <code>Color</code> are equal at the type level; this can be done by lifting <code>ValueColor</code>s. First we give a data type which expresses type equality for <code>Color</code>s.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">EqColor</span> (<span class="ot">a ::</span> <span class="dt">Color</span>) (<span class="ot">b ::</span> <span class="dt">Color</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="dt">EqColor</span><span class="ot"> ::</span> <span class="dt">EqColor</span> a a</a></code></pre></div>
<p>Now the <code>sameColor</code> function takes two value-level colors and provides a type-level proof that they are equal (if they are). A value with type <code>EqColor c1 c2</code> is such a proof, and we are careful to constrain which values can exist. (The type and constructor for <code>EqColor</code> are not exposed outside this module.)</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">sameColor</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">ValueColor</span> (<span class="ot">c1 ::</span> <span class="dt">Color</span>)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="ot">-&gt;</span> <span class="dt">ValueColor</span> (<span class="ot">c2 ::</span> <span class="dt">Color</span>)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">EqColor</span> c1 c2)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">sameColor u v <span class="fu">=</span> <span class="kw">case</span> (u,v) <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  (<span class="dt">R</span>,  <span class="dt">R</span>)  <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="dt">EqColor</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">  (<span class="dt">B</span>,  <span class="dt">B</span>)  <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="dt">EqColor</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  (<span class="dt">BB</span>, <span class="dt">BB</span>) <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="dt">EqColor</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">  (<span class="dt">NB</span>, <span class="dt">NB</span>) <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="dt">EqColor</span></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">  _        <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>What we have so far is this: a type-level representation of natural numbers, and a type-level representation of the possible node colors, as well as a mechanism for asserting the equality of type-level colors. We’ll use these to encode the red-black invariants in types.</p>
</section>
<section id="enforcing-invariants-statically" class="level2">
<h2>Enforcing Invariants Statically</h2>
<p>We’re now prepared to define red-black trees so that invariant-violating instances are <em>not allowed to exist</em> by the compiler – and it turns out, it’s not even that hard to do. We begin with an intermediate type, defined as a GADT, which looks almost like an ordinary binary tree if we squint at it just right.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="co">-- CT is short for &quot;colorful tree&quot;</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="kw">data</span> <span class="dt">CT</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) (<span class="ot">c ::</span> <span class="dt">Color</span>) (<span class="ot">a ::</span> <span class="fu">*</span>) <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">   <span class="dt">E</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"><span class="ot">     ::</span> <span class="dt">CT</span> <span class="dt">Z</span> <span class="dt">Black</span> a</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">   <span class="dt">T</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="ot">     ::</span> ( <span class="dt">Valid</span> c c1 c2 )</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">     <span class="ot">=&gt;</span> <span class="dt">ValueColor</span> c</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">     <span class="ot">-&gt;</span> (<span class="dt">CT</span> n c1 a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> (<span class="dt">CT</span> n c2 a)</a>
<a class="sourceLine" id="cb9-9" data-line-number="9">     <span class="ot">-&gt;</span> <span class="dt">CT</span> (<span class="dt">Incr</span> c n) c a</a></code></pre></div>
<p>Let’s pause on this for a moment. This definition says that a <code>CT</code> value has three type parameters: a <code>Nat</code>, representing the black height of the tree, a <code>Color</code>, representing the color of the root, and a <code>*</code>, for the type of the values at the nodes. There are two ways to make a <code>CT</code>.</p>
<ul>
<li>There’s the <em>empty</em> <code>CT</code>, with color <code>Black</code> and black height zero. This tree trivially satisfies the constraints.</li>
<li>Given two trees a, value, and a color parameter, we can construct a <em>branch</em> <code>CT</code> with the value and color at its root. But in the branching case something else is going on: our colors have to satisfy an extra <code>Valid</code> constraint, and the resulting tree has a black height which depends on the root color in some way (the <code>Incr</code> constructor). In the <code>Red</code> and <code>Black</code> case, this satisfies the red-black invariants <em>except</em> for the requirement that the root element be black.</li>
</ul>
<p>The <code>Valid</code> class lets us constrain the colors allowed among the children at each node: red nodes must have black children, and there is no restriction on the children of black nodes. Note also that the double-black and negative-black colors do not appear among the instances of <code>Valid</code>, which excludes these internal-only colors from leaking out to valid trees.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">class</span> <span class="dt">Valid</span> (<span class="ot">c ::</span> <span class="dt">Color</span>) (<span class="ot">c1 ::</span> <span class="dt">Color</span>) (<span class="ot">c2 ::</span> <span class="dt">Color</span>)</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="kw">instance</span> <span class="dt">Valid</span> <span class="dt">Red</span> <span class="dt">Black</span> <span class="dt">Black</span> </a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="kw">instance</span> <span class="dt">Valid</span> <span class="dt">Black</span> c1 c2</a></code></pre></div>
<p>We can also implement <code>Incr</code> as a type family – notice the black height of the root of a <code>T</code> depends on the root color and black heights of the children. This looks suspiciously like a function at the type level, because that’s what it is.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">type</span> family <span class="dt">Incr</span> (<span class="ot">c ::</span> <span class="dt">Color</span>) (<span class="ot">n ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Incr</span> <span class="dt">Black</span> n             <span class="fu">=</span> <span class="dt">S</span> n</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Incr</span> <span class="dt">DoubleBlack</span> n       <span class="fu">=</span> <span class="dt">S</span> (<span class="dt">S</span> n)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Incr</span> <span class="dt">Red</span>   n             <span class="fu">=</span> n</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"><span class="kw">type</span> <span class="kw">instance</span> <span class="dt">Incr</span> <span class="dt">NegativeBlack</span> (<span class="dt">S</span> n) <span class="fu">=</span> n</a></code></pre></div>
<p>Next, for debugging, we give a <code>Show</code> instance for <code>CT</code>.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb12-2" data-line-number="2">  ( <span class="dt">Show</span> a</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">CT</span> n c a)</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">    show x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">      <span class="dt">E</span> <span class="ot">-&gt;</span> <span class="st">&quot;E&quot;</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">      (<span class="dt">T</span> c l x r) <span class="ot">-&gt;</span> concat</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">        [ <span class="st">&quot;(T &quot;</span>, show c, <span class="st">&quot; &quot;</span>, show l</a>
<a class="sourceLine" id="cb12-9" data-line-number="9">        , <span class="st">&quot; &quot;</span>, show x, <span class="st">&quot; &quot;</span>, show r, <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">        ]</a></code></pre></div>
<p>Finally we can hide the extra parameters to expose a red-black tree type depending only on the value type and forcing the root to be black. This is the type we expose from this module. This also enforces the black root invariant, which does not hold for bare <code>CT</code>s.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">data</span> <span class="dt">RedBlackTree</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  <span class="dt">Root</span><span class="ot"> ::</span> (<span class="dt">CT</span> n <span class="dt">Black</span> a) <span class="ot">-&gt;</span> <span class="dt">RedBlackTree</span> a</a>
<a class="sourceLine" id="cb13-3" data-line-number="3"></a>
<a class="sourceLine" id="cb13-4" data-line-number="4"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  ( <span class="dt">Show</span> a</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">  ) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">RedBlackTree</span> a)</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-8" data-line-number="8">    show (<span class="dt">Root</span> x) <span class="fu">=</span> show x</a></code></pre></div>
<p>And that’s all it takes to encode the red-black invariants at the type level; invalid trees cannot exist because they won’t satisfy the type checker. Neat!</p>
<p>Now for the hard(er) part: implementing the useful operations. We can be confident at this point that <em>if</em> we can write implementations for <code>insert</code> and <code>delete</code> then they will preserve the invariants, but it is not obvious that we can do this or how complicated it will be. In particular, insertion and deletion necessarily requires working with intermediate structures that violate the red-black invariants, so we’ll have to deal with that.</p>
</section>
<section id="class-instances" class="level2">
<h2>Class Instances</h2>
<p>Before getting to the meat of this module lets do a bit of cleanup. Note that we didn’t derive equality on <code>RedBlackTree</code>s, because we <em>couldn’t</em> derive a useful equality on the inner type <code>CT</code>. To do this we’ll need a kind of equality testing on <code>CT</code>s that ignores the black height parameter.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  ( <span class="dt">Eq</span> a</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">RedBlackTree</span> a)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    (<span class="dt">Root</span> t1) <span class="fu">==</span> (<span class="dt">Root</span> t2) <span class="fu">=</span> eqCT t1 t2</a>
<a class="sourceLine" id="cb14-6" data-line-number="6">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">        eqCT</a>
<a class="sourceLine" id="cb14-8" data-line-number="8"><span class="ot">          ::</span> ( <span class="dt">Eq</span> a )</a>
<a class="sourceLine" id="cb14-9" data-line-number="9">          <span class="ot">=&gt;</span> <span class="dt">CT</span> n1 c1 a <span class="ot">-&gt;</span> <span class="dt">CT</span> n2 c2 a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb14-10" data-line-number="10">        eqCT u v <span class="fu">=</span> <span class="kw">case</span> (u,v) <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">          (<span class="dt">E</span>, <span class="dt">E</span>) <span class="ot">-&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb14-12" data-line-number="12">          (<span class="dt">T</span> c1 a1 x1 b1, <span class="dt">T</span> c2 a2 x2 b2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-13" data-line-number="13">            <span class="kw">case</span> sameColor c1 c2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-14" data-line-number="14">              <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb14-15" data-line-number="15">              <span class="dt">Just</span> _  <span class="ot">-&gt;</span> (eqCT a1 a2) <span class="fu">&amp;&amp;</span> (x1 <span class="fu">==</span> x2) <span class="fu">&amp;&amp;</span> (eqCT b1 b2)</a>
<a class="sourceLine" id="cb14-16" data-line-number="16">          _ <span class="ot">-&gt;</span> <span class="dt">False</span></a></code></pre></div>
<p>Both <code>CT</code> and <code>RedBlackTree</code> are instances of functor, however, in a straightforward way.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">CT</span> n c) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2">  fmap f w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3">    <span class="dt">E</span> <span class="ot">-&gt;</span> <span class="dt">E</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4">    <span class="dt">T</span> c l a r <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">      <span class="dt">T</span> c (fmap f l) (f a) (fmap f r)</a>
<a class="sourceLine" id="cb15-6" data-line-number="6"></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">RedBlackTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">  fmap f (<span class="dt">Root</span> x) <span class="fu">=</span> <span class="dt">Root</span> (fmap f x)</a></code></pre></div>
</section>
<section id="basic-api" class="level2">
<h2>Basic API</h2>
<p>The bare minimum API we need from red-black trees is a constructor for empty trees, a way to query for membership, insertion, and deletion. The first two of these are simple to implement, but the last two are tricky to express because they involve temporarily dealing with “almost” red-black trees which violate one or more of the invariants.</p>
<p>Defining the empty tree is straightforward:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="ot">empty ::</span> <span class="dt">RedBlackTree</span> a</a>
<a class="sourceLine" id="cb16-2" data-line-number="2">empty <span class="fu">=</span> <span class="dt">Root</span> <span class="dt">E</span></a></code></pre></div>
<p>As is querying for membership.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">member</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ot">  ::</span> forall a</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">   <span class="fu">.</span> ( <span class="dt">Ord</span> a )</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">RedBlackTree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">member x (<span class="dt">Root</span> t) <span class="fu">=</span> member&#39; t</a>
<a class="sourceLine" id="cb17-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-7" data-line-number="7">    member&#39;</a>
<a class="sourceLine" id="cb17-8" data-line-number="8"><span class="ot">      ::</span> ( <span class="dt">Ord</span> a )</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">      <span class="ot">=&gt;</span> <span class="dt">CT</span> n c a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb17-10" data-line-number="10">    member&#39; w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-11" data-line-number="11">      <span class="dt">E</span> <span class="ot">-&gt;</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb17-12" data-line-number="12">      <span class="dt">T</span> _ l u r <span class="ot">-&gt;</span> <span class="kw">case</span> compare x u <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-13" data-line-number="13">        <span class="dt">LT</span> <span class="ot">-&gt;</span> member&#39; l</a>
<a class="sourceLine" id="cb17-14" data-line-number="14">        <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb17-15" data-line-number="15">        <span class="dt">GT</span> <span class="ot">-&gt;</span> member&#39; r</a></code></pre></div>
<p>While we’re here, we can also convert a red-black tree to a list, preserving the left-to-right order of the items in the tree.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">toList</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Ord</span> a )</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">RedBlackTree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">toList (<span class="dt">Root</span> t) <span class="fu">=</span> accum t []</a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">    accum</a>
<a class="sourceLine" id="cb18-7" data-line-number="7"><span class="ot">      ::</span> ( <span class="dt">Ord</span> a )</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">      <span class="ot">=&gt;</span> <span class="dt">CT</span> n c a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb18-9" data-line-number="9">    accum w zs <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-10" data-line-number="10">      <span class="dt">E</span> <span class="ot">-&gt;</span> zs</a>
<a class="sourceLine" id="cb18-11" data-line-number="11">      <span class="dt">T</span> _ a x b <span class="ot">-&gt;</span> accum a (x <span class="fu">:</span> accum b zs)</a></code></pre></div>
<p>Finally, since the items in the tree are ordered, we can extract the maximum element.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">getMax</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Ord</span> a )</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">CT</span> n c a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">getMax w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  <span class="dt">E</span>         <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">  <span class="dt">T</span> _ _ x <span class="dt">E</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">  <span class="dt">T</span> _ _ x r <span class="ot">-&gt;</span> getMax r</a>
<a class="sourceLine" id="cb19-8" data-line-number="8"></a>
<a class="sourceLine" id="cb19-9" data-line-number="9">maxElt</a>
<a class="sourceLine" id="cb19-10" data-line-number="10"><span class="ot">  ::</span> ( <span class="dt">Ord</span> a )</a>
<a class="sourceLine" id="cb19-11" data-line-number="11">  <span class="ot">=&gt;</span> <span class="dt">RedBlackTree</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb19-12" data-line-number="12">maxElt (<span class="dt">Root</span> x) <span class="fu">=</span> getMax x</a></code></pre></div>
<p>Note that these operations do not involve destructuring a red-black tree in a way that may violate any invariants.</p>
</section>
<section id="insertion" class="level2">
<h2>Insertion</h2>
<p>Suppose we want to insert an item into a red-black tree. The naive way to do this is to demand that the item type be ordered and walk down the tree from the root, branching at each node depending on whether the item to be inserted is greater than or less than the node item. We have to be careful here though, because we will end up violating at least one of the invariants. To see why, note that the inserted item will end up as a leaf in the tree, and (like all other leaves) the color of the new leaf must be black. But now the path from the root to this new leaf has one more black node than the others, a violation.</p>
<p>So during the process of insertion, what we have is <em>not</em> a red-black tree. Fortunately though it fails in only a few possible ways; in particular, we may end up with a red root having a red child. We give an auxiliary data structure capable of holding such a tree. Note the absence of a <code>Valid</code> constraint, as well as an empty constructor (since after insertion the tree cannot be empty).</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1"><span class="kw">data</span> <span class="dt">IR</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) a <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-2" data-line-number="2">  <span class="dt">IR</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3"><span class="ot">    ::</span> <span class="dt">ValueColor</span> (<span class="ot">c ::</span> <span class="dt">Color</span>)</a>
<a class="sourceLine" id="cb20-4" data-line-number="4">    <span class="ot">-&gt;</span> <span class="dt">CT</span> n c1 a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">CT</span> n c2 a</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">IR</span> (<span class="dt">Incr</span> c n) a</a></code></pre></div>
<p>So an <code>IR</code> is almost the same as a <code>RedBlackTree</code>, except that the constraint on adjacent red nodes can be violated.</p>
<p>Now <code>insert</code> works something like this: first we insert into a <code>RedBlackTree</code> to return an <code>IR</code>. The possible invariant violations are known, and rebalancing corresponds to tree <em>rotation</em>.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">insert</a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="ot">  ::</span> forall a</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">   <span class="fu">.</span> ( <span class="dt">Ord</span> a )</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">RedBlackTree</span> a <span class="ot">-&gt;</span> <span class="dt">RedBlackTree</span> a</a>
<a class="sourceLine" id="cb21-5" data-line-number="5">insert x (<span class="dt">Root</span> s) <span class="fu">=</span> blacken (ins s)</a>
<a class="sourceLine" id="cb21-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">    <span class="co">-- May (slightly) break the invariants</span></a>
<a class="sourceLine" id="cb21-8" data-line-number="8">    ins</a>
<a class="sourceLine" id="cb21-9" data-line-number="9"><span class="ot">      ::</span> ( <span class="dt">Ord</span> a )</a>
<a class="sourceLine" id="cb21-10" data-line-number="10">      <span class="ot">=&gt;</span> <span class="dt">CT</span> n c a <span class="ot">-&gt;</span> <span class="dt">IR</span> n a</a>
<a class="sourceLine" id="cb21-11" data-line-number="11">    ins w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-12" data-line-number="12">      <span class="dt">E</span> <span class="ot">-&gt;</span> <span class="dt">IR</span> <span class="dt">R</span> <span class="dt">E</span> x <span class="dt">E</span></a>
<a class="sourceLine" id="cb21-13" data-line-number="13">      s<span class="fu">@</span>(<span class="dt">T</span> c a y b) <span class="ot">-&gt;</span> <span class="kw">case</span> compare x y <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-14" data-line-number="14">        <span class="dt">LT</span> <span class="ot">-&gt;</span> balanceL c (ins a) y b</a>
<a class="sourceLine" id="cb21-15" data-line-number="15">        <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">IR</span> c a y b</a>
<a class="sourceLine" id="cb21-16" data-line-number="16">        <span class="dt">GT</span> <span class="ot">-&gt;</span> balanceR c a y (ins b)</a>
<a class="sourceLine" id="cb21-17" data-line-number="17"></a>
<a class="sourceLine" id="cb21-18" data-line-number="18">    blacken</a>
<a class="sourceLine" id="cb21-19" data-line-number="19"><span class="ot">      ::</span> <span class="dt">IR</span> n a <span class="ot">-&gt;</span> <span class="dt">RedBlackTree</span> a</a>
<a class="sourceLine" id="cb21-20" data-line-number="20">    blacken (<span class="dt">IR</span> _ a x b) <span class="fu">=</span> <span class="dt">Root</span> (<span class="dt">T</span> <span class="dt">B</span> a x b)</a>
<a class="sourceLine" id="cb21-21" data-line-number="21"></a>
<a class="sourceLine" id="cb21-22" data-line-number="22">    balanceL</a>
<a class="sourceLine" id="cb21-23" data-line-number="23"><span class="ot">      ::</span> <span class="dt">ValueColor</span> c <span class="ot">-&gt;</span> <span class="dt">IR</span> n a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">CT</span> n c1 a <span class="ot">-&gt;</span> <span class="dt">IR</span> (<span class="dt">Incr</span> c n) a</a>
<a class="sourceLine" id="cb21-24" data-line-number="24">    balanceL c u z d <span class="fu">=</span> <span class="kw">case</span> (c,u) <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-25" data-line-number="25">      (_, <span class="dt">IR</span> <span class="dt">B</span> a x b)                         <span class="ot">-&gt;</span> <span class="dt">IR</span> c (<span class="dt">T</span> <span class="dt">B</span> a x b) z d</a>
<a class="sourceLine" id="cb21-26" data-line-number="26">      (_, <span class="dt">IR</span> <span class="dt">R</span> a<span class="fu">@</span><span class="dt">E</span> x b<span class="fu">@</span><span class="dt">E</span>)                     <span class="ot">-&gt;</span> <span class="dt">IR</span> c (<span class="dt">T</span> <span class="dt">R</span> a x b) z d</a>
<a class="sourceLine" id="cb21-27" data-line-number="27">      (_, <span class="dt">IR</span> <span class="dt">R</span> a<span class="fu">@</span>(<span class="dt">T</span> <span class="dt">B</span> _ _ _) x b<span class="fu">@</span>(<span class="dt">T</span> <span class="dt">B</span> _ _ _)) <span class="ot">-&gt;</span> <span class="dt">IR</span> c (<span class="dt">T</span> <span class="dt">R</span> a x b) z d</a>
<a class="sourceLine" id="cb21-28" data-line-number="28">      (<span class="dt">B</span>, <span class="dt">IR</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">R</span> a x b) y c)               <span class="ot">-&gt;</span> <span class="dt">IR</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">B</span> a x b) y (<span class="dt">T</span> <span class="dt">B</span> c z d)</a>
<a class="sourceLine" id="cb21-29" data-line-number="29">      (<span class="dt">B</span>, <span class="dt">IR</span> <span class="dt">R</span> a x (<span class="dt">T</span> <span class="dt">R</span> b y c))               <span class="ot">-&gt;</span> <span class="dt">IR</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">B</span> a x b) y (<span class="dt">T</span> <span class="dt">B</span> c z d)</a>
<a class="sourceLine" id="cb21-30" data-line-number="30"></a>
<a class="sourceLine" id="cb21-31" data-line-number="31">    balanceR</a>
<a class="sourceLine" id="cb21-32" data-line-number="32"><span class="ot">      ::</span> <span class="dt">ValueColor</span> c <span class="ot">-&gt;</span> <span class="dt">CT</span> n c1 a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IR</span> n a <span class="ot">-&gt;</span> <span class="dt">IR</span> (<span class="dt">Incr</span> c n) a</a>
<a class="sourceLine" id="cb21-33" data-line-number="33">    balanceR c a x u <span class="fu">=</span> <span class="kw">case</span> (c,u) <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-34" data-line-number="34">      (_, <span class="dt">IR</span> <span class="dt">B</span> b z d)                         <span class="ot">-&gt;</span> <span class="dt">IR</span> c a x (<span class="dt">T</span> <span class="dt">B</span> b z d)</a>
<a class="sourceLine" id="cb21-35" data-line-number="35">      (_, <span class="dt">IR</span> <span class="dt">R</span> b<span class="fu">@</span><span class="dt">E</span> z d<span class="fu">@</span><span class="dt">E</span>)                     <span class="ot">-&gt;</span> <span class="dt">IR</span> c a x (<span class="dt">T</span> <span class="dt">R</span> b z d)</a>
<a class="sourceLine" id="cb21-36" data-line-number="36">      (_, <span class="dt">IR</span> <span class="dt">R</span> b<span class="fu">@</span>(<span class="dt">T</span> <span class="dt">B</span> _ _ _) z d<span class="fu">@</span>(<span class="dt">T</span> <span class="dt">B</span> _ _ _)) <span class="ot">-&gt;</span> <span class="dt">IR</span> c a x (<span class="dt">T</span> <span class="dt">R</span> b z d)</a>
<a class="sourceLine" id="cb21-37" data-line-number="37">      (<span class="dt">B</span>, <span class="dt">IR</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">R</span> b y c) z d)               <span class="ot">-&gt;</span> <span class="dt">IR</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">B</span> a x b) y (<span class="dt">T</span> <span class="dt">B</span> c z d)</a>
<a class="sourceLine" id="cb21-38" data-line-number="38">      (<span class="dt">B</span>, <span class="dt">IR</span> <span class="dt">R</span> b y (<span class="dt">T</span> <span class="dt">R</span> c z d))               <span class="ot">-&gt;</span> <span class="dt">IR</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">B</span> a x b) y (<span class="dt">T</span> <span class="dt">B</span> c z d)</a></code></pre></div>
<p>With <code>insert</code> we also define a helper function for building red-black trees out of lists.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">fromList</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Ord</span> a )</a>
<a class="sourceLine" id="cb22-3" data-line-number="3">  <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">RedBlackTree</span> a</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">fromList <span class="fu">=</span> foldr insert empty</a></code></pre></div>
<p>And with <code>insert</code> in hand we can finally see some interesting examples!</p>
<div class="doctest">
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="co">-- &gt;&gt;&gt; empty</span></a>
<a class="sourceLine" id="cb23-3" data-line-number="3"><span class="co">-- E</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4"><span class="co">--</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5"><span class="co">-- &gt;&gt;&gt; insert 7 empty</span></a>
<a class="sourceLine" id="cb23-6" data-line-number="6"><span class="co">-- (T B E 7 E)</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7"><span class="co">--</span></a>
<a class="sourceLine" id="cb23-8" data-line-number="8"><span class="co">-- &gt;&gt;&gt; fromList [1..5]</span></a>
<a class="sourceLine" id="cb23-9" data-line-number="9"><span class="co">-- (T B (T R (T B E 1 E) 2 (T B E 3 E)) 4 (T B E 5 E))</span></a></code></pre></div>
</div>
</section>
<section id="deletion" class="level2">
<h2>Deletion</h2>
<p>Deleting elements from a red-black tree is much tricker than insertion, most obviously because while insertion always alters the tree at a leaf, deletion can affect an interior node. Then one of the deleted node’s children is promoted, but the global invariant on black height is in danger of being violated. This code uses a strategy described by <a href="http://matt.might.net/articles/red-black-delete/">Matt Might</a> which sidesteps the hard part of preserving the global invariant by introducing two new colors: <em>double black</em>, which counts as two black nodes for the purpose of computing black height, and <em>negative black</em>, which counts as negative one black nodes. Trees with nodes of these colors are not red-black trees, of course, but just like the intermediate type <code>IR</code> used for insertion, we can precisely describe how malformed intermediate trees are during deletion. Where <code>IR</code> could have a red root with a red child, we define a type, <code>DT</code>, which may have a double black node at the root or as a single leaf.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">data</span> <span class="dt">DT</span> (<span class="ot">n ::</span> <span class="dt">Nat</span>) a <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  <span class="dt">DT</span></a>
<a class="sourceLine" id="cb24-3" data-line-number="3"><span class="ot">    ::</span> <span class="dt">ValueColor</span> c</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">    <span class="ot">-&gt;</span> <span class="dt">CT</span> n c1 a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">CT</span> n c2 a</a>
<a class="sourceLine" id="cb24-5" data-line-number="5">    <span class="ot">-&gt;</span> <span class="dt">DT</span> (<span class="dt">Incr</span> c n) a</a>
<a class="sourceLine" id="cb24-6" data-line-number="6"></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">  <span class="co">-- Double-black empty tree</span></a>
<a class="sourceLine" id="cb24-8" data-line-number="8">  <span class="dt">DEE</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9"><span class="ot">    ::</span> <span class="dt">DT</span> (<span class="dt">S</span> <span class="dt">Z</span>) a</a>
<a class="sourceLine" id="cb24-10" data-line-number="10"></a>
<a class="sourceLine" id="cb24-11" data-line-number="11">  <span class="co">-- Ordinary empty tree</span></a>
<a class="sourceLine" id="cb24-12" data-line-number="12">  <span class="dt">DE</span></a>
<a class="sourceLine" id="cb24-13" data-line-number="13"><span class="ot">    ::</span> <span class="dt">DT</span> <span class="dt">Z</span> a</a></code></pre></div>
<p>Might’s deletion strategy proceeds by attempting to <em>discharge</em> double black nodes by rotation, and if this isn’t possible, to <em>bubble</em> the double black node further up the tree. (A double black node at the root is trivially discharged.)</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">delete</a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="ot">  ::</span> forall a</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">   <span class="fu">.</span> ( <span class="dt">Ord</span> a )</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">RedBlackTree</span> a <span class="ot">-&gt;</span> <span class="dt">RedBlackTree</span> a</a>
<a class="sourceLine" id="cb25-5" data-line-number="5">delete x (<span class="dt">Root</span> s) <span class="fu">=</span> blacken (del x s) </a>
<a class="sourceLine" id="cb25-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7">    <span class="co">-- May (slightly) break the invariants</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8">    del</a>
<a class="sourceLine" id="cb25-9" data-line-number="9"><span class="ot">      ::</span> ( <span class="dt">Ord</span> a )</a>
<a class="sourceLine" id="cb25-10" data-line-number="10">      <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">CT</span> n c a <span class="ot">-&gt;</span> <span class="dt">DT</span> n a</a>
<a class="sourceLine" id="cb25-11" data-line-number="11">    del x w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-12" data-line-number="12">      <span class="dt">E</span> <span class="ot">-&gt;</span> <span class="dt">DE</span></a>
<a class="sourceLine" id="cb25-13" data-line-number="13">      s<span class="fu">@</span>(<span class="dt">T</span> c a y b) <span class="ot">-&gt;</span> <span class="kw">case</span> compare x y <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-14" data-line-number="14">        <span class="dt">LT</span> <span class="ot">-&gt;</span> bubbleL c (del x a) y b</a>
<a class="sourceLine" id="cb25-15" data-line-number="15">        <span class="dt">EQ</span> <span class="ot">-&gt;</span> removeRoot s</a>
<a class="sourceLine" id="cb25-16" data-line-number="16">        <span class="dt">GT</span> <span class="ot">-&gt;</span> bubbleR c a y (del x b)</a>
<a class="sourceLine" id="cb25-17" data-line-number="17"></a>
<a class="sourceLine" id="cb25-18" data-line-number="18">    blacken</a>
<a class="sourceLine" id="cb25-19" data-line-number="19"><span class="ot">      ::</span> <span class="dt">DT</span> n a <span class="ot">-&gt;</span> <span class="dt">RedBlackTree</span> a</a>
<a class="sourceLine" id="cb25-20" data-line-number="20">    blacken w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-21" data-line-number="21">      <span class="dt">DE</span>         <span class="ot">-&gt;</span> <span class="dt">Root</span> <span class="dt">E</span></a>
<a class="sourceLine" id="cb25-22" data-line-number="22">      <span class="dt">DEE</span>        <span class="ot">-&gt;</span> <span class="dt">Root</span> <span class="dt">E</span></a>
<a class="sourceLine" id="cb25-23" data-line-number="23">      <span class="dt">DT</span> _ a x b <span class="ot">-&gt;</span> <span class="dt">Root</span> (<span class="dt">T</span> <span class="dt">B</span> a x b)</a>
<a class="sourceLine" id="cb25-24" data-line-number="24"></a>
<a class="sourceLine" id="cb25-25" data-line-number="25">    <span class="co">-- Remove the root element. May leave a double</span></a>
<a class="sourceLine" id="cb25-26" data-line-number="26">    <span class="co">-- black node to preserve the black height.</span></a>
<a class="sourceLine" id="cb25-27" data-line-number="27">    removeRoot</a>
<a class="sourceLine" id="cb25-28" data-line-number="28"><span class="ot">      ::</span> ( <span class="dt">Ord</span> a )</a>
<a class="sourceLine" id="cb25-29" data-line-number="29">      <span class="ot">=&gt;</span> <span class="dt">CT</span> n c a <span class="ot">-&gt;</span> <span class="dt">DT</span> n a</a>
<a class="sourceLine" id="cb25-30" data-line-number="30">    removeRoot w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-31" data-line-number="31">      <span class="dt">T</span> <span class="dt">R</span> <span class="dt">E</span>           _ <span class="dt">E</span>           <span class="ot">-&gt;</span> <span class="dt">DE</span></a>
<a class="sourceLine" id="cb25-32" data-line-number="32">      <span class="dt">T</span> <span class="dt">B</span> <span class="dt">E</span>           _ <span class="dt">E</span>           <span class="ot">-&gt;</span> <span class="dt">DEE</span> </a>
<a class="sourceLine" id="cb25-33" data-line-number="33">      <span class="dt">T</span> <span class="dt">B</span> <span class="dt">E</span>           _ (<span class="dt">T</span> <span class="dt">R</span> a x b) <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">B</span> a x b</a>
<a class="sourceLine" id="cb25-34" data-line-number="34">      <span class="dt">T</span> <span class="dt">B</span> (<span class="dt">T</span> <span class="dt">R</span> a x b) _ <span class="dt">E</span>           <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">B</span> a x b</a>
<a class="sourceLine" id="cb25-35" data-line-number="35">      <span class="dt">T</span> c l           y r           <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb25-36" data-line-number="36">        <span class="kw">let</span> <span class="dt">Just</span> u <span class="fu">=</span> getMax l</a>
<a class="sourceLine" id="cb25-37" data-line-number="37">        <span class="kw">in</span> bubbleL c (removeMax l) u r</a>
<a class="sourceLine" id="cb25-38" data-line-number="38"></a>
<a class="sourceLine" id="cb25-39" data-line-number="39">    <span class="co">-- Remove the largest element.</span></a>
<a class="sourceLine" id="cb25-40" data-line-number="40">    removeMax</a>
<a class="sourceLine" id="cb25-41" data-line-number="41"><span class="ot">      ::</span> ( <span class="dt">Ord</span> a )</a>
<a class="sourceLine" id="cb25-42" data-line-number="42">      <span class="ot">=&gt;</span> <span class="dt">CT</span> n c a <span class="ot">-&gt;</span> <span class="dt">DT</span> n a</a>
<a class="sourceLine" id="cb25-43" data-line-number="43">    removeMax w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-44" data-line-number="44">      <span class="dt">E</span>         <span class="ot">-&gt;</span> error <span class="st">&quot;removeMax: panic&quot;</span></a>
<a class="sourceLine" id="cb25-45" data-line-number="45">      <span class="dt">T</span> _ _ _ <span class="dt">E</span> <span class="ot">-&gt;</span> removeRoot w</a>
<a class="sourceLine" id="cb25-46" data-line-number="46">      <span class="dt">T</span> c l x r <span class="ot">-&gt;</span> bubbleR c l x (removeMax r)</a>
<a class="sourceLine" id="cb25-47" data-line-number="47"></a>
<a class="sourceLine" id="cb25-48" data-line-number="48">    <span class="co">-- Raise a double black root in the left subtree</span></a>
<a class="sourceLine" id="cb25-49" data-line-number="49">    bubbleL</a>
<a class="sourceLine" id="cb25-50" data-line-number="50"><span class="ot">      ::</span> forall n c c1 a</a>
<a class="sourceLine" id="cb25-51" data-line-number="51">       <span class="fu">.</span> <span class="dt">ValueColor</span> c</a>
<a class="sourceLine" id="cb25-52" data-line-number="52">      <span class="ot">-&gt;</span> <span class="dt">DT</span> n a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">CT</span> n c1 a <span class="ot">-&gt;</span> <span class="dt">DT</span> (<span class="dt">Incr</span> c n) a</a>
<a class="sourceLine" id="cb25-53" data-line-number="53">    bubbleL c d x r <span class="fu">=</span> <span class="kw">case</span> (c,d) <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-54" data-line-number="54">      (<span class="dt">B</span>,  <span class="dt">DEE</span>)         <span class="ot">-&gt;</span> dbalanceR <span class="dt">BB</span> <span class="dt">E</span> x (redden r)</a>
<a class="sourceLine" id="cb25-55" data-line-number="55">      (<span class="dt">R</span>,  <span class="dt">DEE</span>)         <span class="ot">-&gt;</span> dbalanceR <span class="dt">B</span>  <span class="dt">E</span> x (redden r)</a>
<a class="sourceLine" id="cb25-56" data-line-number="56">      (<span class="dt">NB</span>, <span class="dt">DEE</span>)         <span class="ot">-&gt;</span> dbalanceR <span class="dt">R</span>  <span class="dt">E</span> x (redden r)</a>
<a class="sourceLine" id="cb25-57" data-line-number="57">      (<span class="dt">B</span>,  <span class="dt">DT</span> <span class="dt">BB</span> a y b) <span class="ot">-&gt;</span> dbalanceR <span class="dt">BB</span> (<span class="dt">T</span> <span class="dt">B</span> a y b) x (redden r)</a>
<a class="sourceLine" id="cb25-58" data-line-number="58">      (<span class="dt">R</span>,  <span class="dt">DT</span> <span class="dt">BB</span> a y b) <span class="ot">-&gt;</span> dbalanceR <span class="dt">B</span>  (<span class="dt">T</span> <span class="dt">B</span> a y b) x (redden r)</a>
<a class="sourceLine" id="cb25-59" data-line-number="59">      (<span class="dt">NB</span>, <span class="dt">DT</span> <span class="dt">BB</span> a y b) <span class="ot">-&gt;</span> dbalanceR <span class="dt">R</span>  (<span class="dt">T</span> <span class="dt">B</span> a y b) x (redden r)</a>
<a class="sourceLine" id="cb25-60" data-line-number="60">      _ <span class="ot">-&gt;</span> dbalanceL c d x r</a>
<a class="sourceLine" id="cb25-61" data-line-number="61"></a>
<a class="sourceLine" id="cb25-62" data-line-number="62">    <span class="co">-- Raise a double black root in the right subtree</span></a>
<a class="sourceLine" id="cb25-63" data-line-number="63">    bubbleR</a>
<a class="sourceLine" id="cb25-64" data-line-number="64"><span class="ot">      ::</span> forall n c c1 a</a>
<a class="sourceLine" id="cb25-65" data-line-number="65">       <span class="fu">.</span> <span class="dt">ValueColor</span> c</a>
<a class="sourceLine" id="cb25-66" data-line-number="66">      <span class="ot">-&gt;</span> <span class="dt">CT</span> n c1 a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">DT</span> n a <span class="ot">-&gt;</span> <span class="dt">DT</span> (<span class="dt">Incr</span> c n) a </a>
<a class="sourceLine" id="cb25-67" data-line-number="67">    bubbleR c l x d <span class="fu">=</span> <span class="kw">case</span> (c,d) <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-68" data-line-number="68">      (<span class="dt">B</span>,  <span class="dt">DEE</span>)         <span class="ot">-&gt;</span> dbalanceL <span class="dt">BB</span> (redden l) x <span class="dt">E</span></a>
<a class="sourceLine" id="cb25-69" data-line-number="69">      (<span class="dt">R</span>,  <span class="dt">DEE</span>)         <span class="ot">-&gt;</span> dbalanceL <span class="dt">B</span>  (redden l) x <span class="dt">E</span></a>
<a class="sourceLine" id="cb25-70" data-line-number="70">      (<span class="dt">NB</span>, <span class="dt">DEE</span>)         <span class="ot">-&gt;</span> dbalanceL <span class="dt">R</span>  (redden l) x <span class="dt">E</span></a>
<a class="sourceLine" id="cb25-71" data-line-number="71">      (<span class="dt">B</span>,  <span class="dt">DT</span> <span class="dt">BB</span> a y b) <span class="ot">-&gt;</span> dbalanceL <span class="dt">BB</span> (redden l) x (<span class="dt">T</span> <span class="dt">B</span> a y b)</a>
<a class="sourceLine" id="cb25-72" data-line-number="72">      (<span class="dt">R</span>,  <span class="dt">DT</span> <span class="dt">BB</span> a y b) <span class="ot">-&gt;</span> dbalanceL <span class="dt">B</span>  (redden l) x (<span class="dt">T</span> <span class="dt">B</span> a y b)</a>
<a class="sourceLine" id="cb25-73" data-line-number="73">      (<span class="dt">NB</span>, <span class="dt">DT</span> <span class="dt">BB</span> a y b) <span class="ot">-&gt;</span> dbalanceL <span class="dt">R</span>  (redden l) x (<span class="dt">T</span> <span class="dt">B</span> a y b)</a>
<a class="sourceLine" id="cb25-74" data-line-number="74">      _ <span class="ot">-&gt;</span> dbalanceR c l x d</a>
<a class="sourceLine" id="cb25-75" data-line-number="75"></a>
<a class="sourceLine" id="cb25-76" data-line-number="76">    <span class="co">-- Decrease the black height</span></a>
<a class="sourceLine" id="cb25-77" data-line-number="77">    redden</a>
<a class="sourceLine" id="cb25-78" data-line-number="78"><span class="ot">      ::</span> forall n c a</a>
<a class="sourceLine" id="cb25-79" data-line-number="79">       <span class="fu">.</span> <span class="dt">CT</span> (<span class="dt">S</span> n) c a <span class="ot">-&gt;</span> <span class="dt">DT</span> n a</a>
<a class="sourceLine" id="cb25-80" data-line-number="80">    redden (<span class="dt">T</span> c a x y) <span class="fu">=</span> <span class="kw">case</span> c <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-81" data-line-number="81">      <span class="dt">B</span>  <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">R</span>  a x y</a>
<a class="sourceLine" id="cb25-82" data-line-number="82">      <span class="dt">BB</span> <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">B</span>  a x y</a>
<a class="sourceLine" id="cb25-83" data-line-number="83">      <span class="dt">R</span>  <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">NB</span> a x y</a>
<a class="sourceLine" id="cb25-84" data-line-number="84"></a>
<a class="sourceLine" id="cb25-85" data-line-number="85">    dbalanceL</a>
<a class="sourceLine" id="cb25-86" data-line-number="86"><span class="ot">      ::</span> forall n c c1 a</a>
<a class="sourceLine" id="cb25-87" data-line-number="87">       <span class="fu">.</span> <span class="dt">ValueColor</span> c</a>
<a class="sourceLine" id="cb25-88" data-line-number="88">      <span class="ot">-&gt;</span> <span class="dt">DT</span> n a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">CT</span> n c1 a <span class="ot">-&gt;</span> <span class="dt">DT</span> (<span class="dt">Incr</span> c n) a</a>
<a class="sourceLine" id="cb25-89" data-line-number="89">    dbalanceL k dt u r <span class="fu">=</span> <span class="kw">case</span> (k,dt) <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-90" data-line-number="90">      (<span class="dt">B</span>,  <span class="dt">DT</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">R</span> a x b) y c)           <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">B</span> a x b) y (<span class="dt">T</span> <span class="dt">B</span> c u r)</a>
<a class="sourceLine" id="cb25-91" data-line-number="91">      (<span class="dt">B</span>,  <span class="dt">DT</span> <span class="dt">R</span> a           x (<span class="dt">T</span> <span class="dt">R</span> b y c)) <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">B</span> a x b) y (<span class="dt">T</span> <span class="dt">B</span> c u r)</a>
<a class="sourceLine" id="cb25-92" data-line-number="92">      (<span class="dt">BB</span>, <span class="dt">DT</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">R</span> a x b) y c)           <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">B</span> (<span class="dt">T</span> <span class="dt">B</span> a x b) y (<span class="dt">T</span> <span class="dt">B</span> c u r)</a>
<a class="sourceLine" id="cb25-93" data-line-number="93">      (<span class="dt">BB</span>, <span class="dt">DT</span> <span class="dt">R</span> a           x (<span class="dt">T</span> <span class="dt">R</span> b y c)) <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">B</span> (<span class="dt">T</span> <span class="dt">B</span> a x b) y (<span class="dt">T</span> <span class="dt">B</span> c u r)</a>
<a class="sourceLine" id="cb25-94" data-line-number="94"></a>
<a class="sourceLine" id="cb25-95" data-line-number="95">      (<span class="dt">BB</span>, <span class="dt">DT</span> <span class="dt">NB</span> a<span class="fu">@</span>(<span class="dt">T</span> <span class="dt">B</span> _ _ _) x (<span class="dt">T</span> <span class="dt">B</span> b y c)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb25-96" data-line-number="96">        <span class="kw">case</span> dbalanceL <span class="dt">B</span> (redden a) x b <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-97" data-line-number="97">          l<span class="fu">@</span>(<span class="dt">DT</span> <span class="dt">R</span> _ _ _) <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">B</span> (assertRed l)  y (<span class="dt">T</span> <span class="dt">B</span> c u r)</a>
<a class="sourceLine" id="cb25-98" data-line-number="98">          <span class="dt">DT</span> <span class="dt">B</span> a1 x1 y1  <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">B</span> (<span class="dt">T</span> <span class="dt">B</span> a1 x1 y1) y (<span class="dt">T</span> <span class="dt">B</span> c u r)</a>
<a class="sourceLine" id="cb25-99" data-line-number="99"></a>
<a class="sourceLine" id="cb25-100" data-line-number="100">      <span class="co">-- Fallthrough cases</span></a>
<a class="sourceLine" id="cb25-101" data-line-number="101">      (_, <span class="dt">DE</span>)                                 <span class="ot">-&gt;</span> <span class="dt">DT</span> k <span class="dt">E</span>           u r</a>
<a class="sourceLine" id="cb25-102" data-line-number="102">      (_, <span class="dt">DT</span> <span class="dt">B</span> a             x b)             <span class="ot">-&gt;</span> <span class="dt">DT</span> k (<span class="dt">T</span> <span class="dt">B</span> a x b) u r</a>
<a class="sourceLine" id="cb25-103" data-line-number="103">      (_, <span class="dt">DT</span> <span class="dt">R</span> a<span class="fu">@</span><span class="dt">E</span>           x b<span class="fu">@</span><span class="dt">E</span>)           <span class="ot">-&gt;</span> <span class="dt">DT</span> k (<span class="dt">T</span> <span class="dt">R</span> a x b) u r</a>
<a class="sourceLine" id="cb25-104" data-line-number="104">      (_, <span class="dt">DT</span> <span class="dt">R</span> a<span class="fu">@</span>(<span class="dt">T</span> <span class="dt">B</span> _ _ _) x b<span class="fu">@</span>(<span class="dt">T</span> <span class="dt">B</span> _ _ _)) <span class="ot">-&gt;</span> <span class="dt">DT</span> k (<span class="dt">T</span> <span class="dt">R</span> a x b) u r</a>
<a class="sourceLine" id="cb25-105" data-line-number="105">      _ <span class="ot">-&gt;</span> error <span class="st">&quot;dbalanceL: panic&quot;</span></a>
<a class="sourceLine" id="cb25-106" data-line-number="106"></a>
<a class="sourceLine" id="cb25-107" data-line-number="107">    dbalanceR</a>
<a class="sourceLine" id="cb25-108" data-line-number="108"><span class="ot">      ::</span> forall n c c1 a</a>
<a class="sourceLine" id="cb25-109" data-line-number="109">       <span class="fu">.</span> <span class="dt">ValueColor</span> c</a>
<a class="sourceLine" id="cb25-110" data-line-number="110">      <span class="ot">-&gt;</span> <span class="dt">CT</span> n c1 a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">DT</span> n a <span class="ot">-&gt;</span> <span class="dt">DT</span> (<span class="dt">Incr</span> c n) a</a>
<a class="sourceLine" id="cb25-111" data-line-number="111">    dbalanceR k l u dt <span class="fu">=</span> <span class="kw">case</span> (k,dt) <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-112" data-line-number="112">      (<span class="dt">B</span>,  <span class="dt">DT</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">R</span> b y c) z d)           <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">B</span> l u b) y (<span class="dt">T</span> <span class="dt">B</span> c z d)</a>
<a class="sourceLine" id="cb25-113" data-line-number="113">      (<span class="dt">B</span>,  <span class="dt">DT</span> <span class="dt">R</span> b           y (<span class="dt">T</span> <span class="dt">R</span> c z d)) <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">B</span> l u b) y (<span class="dt">T</span> <span class="dt">B</span> c z d)</a>
<a class="sourceLine" id="cb25-114" data-line-number="114">      (<span class="dt">BB</span>, <span class="dt">DT</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">R</span> b y c) z d)           <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">B</span> (<span class="dt">T</span> <span class="dt">B</span> l u b) y (<span class="dt">T</span> <span class="dt">B</span> c z d)</a>
<a class="sourceLine" id="cb25-115" data-line-number="115">      (<span class="dt">BB</span>, <span class="dt">DT</span> <span class="dt">R</span> b           y (<span class="dt">T</span> <span class="dt">R</span> c z d)) <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">B</span> (<span class="dt">T</span> <span class="dt">B</span> l u b) y (<span class="dt">T</span> <span class="dt">B</span> c z d)</a>
<a class="sourceLine" id="cb25-116" data-line-number="116"></a>
<a class="sourceLine" id="cb25-117" data-line-number="117">      (<span class="dt">BB</span>, <span class="dt">DT</span> <span class="dt">NB</span> (<span class="dt">T</span> <span class="dt">B</span> b y c) z d<span class="fu">@</span>(<span class="dt">T</span> <span class="dt">B</span> _ _ _)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb25-118" data-line-number="118">        <span class="kw">case</span> (dbalanceR <span class="dt">B</span> c z (redden d)) <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-119" data-line-number="119">          r<span class="fu">@</span>(<span class="dt">DT</span> <span class="dt">R</span> _ _ _)  <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">B</span> (<span class="dt">T</span> <span class="dt">B</span> l u b) y (assertRed r)</a>
<a class="sourceLine" id="cb25-120" data-line-number="120">          (<span class="dt">DT</span> <span class="dt">B</span> a1 x1 y1) <span class="ot">-&gt;</span> <span class="dt">DT</span> <span class="dt">B</span> (<span class="dt">T</span> <span class="dt">B</span> l u b) y (<span class="dt">T</span> <span class="dt">B</span> a1 x1 y1)</a>
<a class="sourceLine" id="cb25-121" data-line-number="121"></a>
<a class="sourceLine" id="cb25-122" data-line-number="122">      <span class="co">-- Fallthrough cases</span></a>
<a class="sourceLine" id="cb25-123" data-line-number="123">      (_, <span class="dt">DE</span>)                                 <span class="ot">-&gt;</span> <span class="dt">DT</span> k l u <span class="dt">E</span></a>
<a class="sourceLine" id="cb25-124" data-line-number="124">      (_, <span class="dt">DT</span> <span class="dt">B</span> b             z d)             <span class="ot">-&gt;</span> <span class="dt">DT</span> k l u (<span class="dt">T</span> <span class="dt">B</span> b z d)</a>
<a class="sourceLine" id="cb25-125" data-line-number="125">      (_, <span class="dt">DT</span> <span class="dt">R</span> b<span class="fu">@</span><span class="dt">E</span>           z d<span class="fu">@</span><span class="dt">E</span>)           <span class="ot">-&gt;</span> <span class="dt">DT</span> k l u (<span class="dt">T</span> <span class="dt">R</span> b z d)</a>
<a class="sourceLine" id="cb25-126" data-line-number="126">      (_, <span class="dt">DT</span> <span class="dt">R</span> b<span class="fu">@</span>(<span class="dt">T</span> <span class="dt">B</span> _ _ _) z d<span class="fu">@</span>(<span class="dt">T</span> <span class="dt">B</span> _ _ _)) <span class="ot">-&gt;</span> <span class="dt">DT</span> k l u (<span class="dt">T</span> <span class="dt">R</span> b z d)</a>
<a class="sourceLine" id="cb25-127" data-line-number="127">      _ <span class="ot">-&gt;</span> error <span class="st">&quot;dbalanceR: panic&quot;</span></a>
<a class="sourceLine" id="cb25-128" data-line-number="128"></a>
<a class="sourceLine" id="cb25-129" data-line-number="129">    assertRed</a>
<a class="sourceLine" id="cb25-130" data-line-number="130"><span class="ot">      ::</span> forall n c a</a>
<a class="sourceLine" id="cb25-131" data-line-number="131">       <span class="fu">.</span> <span class="dt">DT</span> n a <span class="ot">-&gt;</span> <span class="dt">CT</span> n <span class="dt">Red</span> a</a>
<a class="sourceLine" id="cb25-132" data-line-number="132">    assertRed w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-133" data-line-number="133">      <span class="dt">DT</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">B</span> a y b) x (<span class="dt">T</span> <span class="dt">B</span> c z d) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb25-134" data-line-number="134">        <span class="dt">T</span> <span class="dt">R</span> (<span class="dt">T</span> <span class="dt">B</span> a y b) x (<span class="dt">T</span> <span class="dt">B</span> c z d)</a>
<a class="sourceLine" id="cb25-135" data-line-number="135">      _ <span class="ot">-&gt;</span> error <span class="st">&quot;assertRed: panic&quot;</span></a></code></pre></div>
<p>And we can check some examples.</p>
<div class="doctest">
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="co">-- &gt;&gt;&gt; let x = fromList [1,2,3]</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3"><span class="co">-- &gt;&gt;&gt; member 2 x</span></a>
<a class="sourceLine" id="cb26-4" data-line-number="4"><span class="co">-- True</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5"><span class="co">-- &gt;&gt;&gt; member 2 (delete 2 x)</span></a>
<a class="sourceLine" id="cb26-6" data-line-number="6"><span class="co">-- False</span></a></code></pre></div>
</div>
</section>
<section id="testing-and-debugging" class="level2">
<h2>Testing and Debugging</h2>
<p>Finally, class instances for using <code>RedBlackTree</code>s with our property testing framework.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb27-2" data-line-number="2">  ( <span class="dt">Ord</span> a, <span class="dt">Arb</span> a</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Arb</span> (<span class="dt">RedBlackTree</span> a)</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-5" data-line-number="5">    arb <span class="fu">=</span> w</a>
<a class="sourceLine" id="cb27-6" data-line-number="6">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-7" data-line-number="7">        w</a>
<a class="sourceLine" id="cb27-8" data-line-number="8"><span class="ot">          ::</span> forall a</a>
<a class="sourceLine" id="cb27-9" data-line-number="9">           <span class="fu">.</span> ( <span class="dt">Ord</span> a, <span class="dt">Arb</span> a )</a>
<a class="sourceLine" id="cb27-10" data-line-number="10">          <span class="ot">=&gt;</span> <span class="dt">Seeded</span> (<span class="dt">RedBlackTree</span> a)</a>
<a class="sourceLine" id="cb27-11" data-line-number="11">        w <span class="fu">=</span> fmap fromList (<span class="ot">arb ::</span> <span class="dt">Seeded</span> [a])</a>
<a class="sourceLine" id="cb27-12" data-line-number="12"></a>
<a class="sourceLine" id="cb27-13" data-line-number="13"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb27-14" data-line-number="14">  ( <span class="dt">Ord</span> a, <span class="dt">Prune</span> a</a>
<a class="sourceLine" id="cb27-15" data-line-number="15">  ) <span class="ot">=&gt;</span> <span class="dt">Prune</span> (<span class="dt">RedBlackTree</span> a)</a>
<a class="sourceLine" id="cb27-16" data-line-number="16">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-17" data-line-number="17">    prune <span class="fu">=</span> map fromList <span class="fu">.</span> prune <span class="fu">.</span> toList</a></code></pre></div>
<p>The intermediate tree types aren’t used outside this module, but for debugging, some show instances are handy.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  ( <span class="dt">Show</span> a</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">IR</span> n a)</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-5" data-line-number="5">    show x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb28-6" data-line-number="6">      <span class="dt">IR</span> c l x r <span class="ot">-&gt;</span> concat</a>
<a class="sourceLine" id="cb28-7" data-line-number="7">        [ <span class="st">&quot;(IR &quot;</span>, show c, <span class="st">&quot; &quot;</span>, show l</a>
<a class="sourceLine" id="cb28-8" data-line-number="8">        , <span class="st">&quot; ... &quot;</span>, show r, <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb28-9" data-line-number="9">        ]</a>
<a class="sourceLine" id="cb28-10" data-line-number="10"></a>
<a class="sourceLine" id="cb28-11" data-line-number="11"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb28-12" data-line-number="12">  ( <span class="dt">Show</span> a</a>
<a class="sourceLine" id="cb28-13" data-line-number="13">  ) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">DT</span> n a)</a>
<a class="sourceLine" id="cb28-14" data-line-number="14">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-15" data-line-number="15">    show x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb28-16" data-line-number="16">      <span class="dt">DE</span> <span class="ot">-&gt;</span> <span class="st">&quot;DE&quot;</span></a>
<a class="sourceLine" id="cb28-17" data-line-number="17">      <span class="dt">DEE</span> <span class="ot">-&gt;</span> <span class="st">&quot;DEE&quot;</span></a>
<a class="sourceLine" id="cb28-18" data-line-number="18">      <span class="dt">DT</span> c l x r <span class="ot">-&gt;</span> concat</a>
<a class="sourceLine" id="cb28-19" data-line-number="19">        [ <span class="st">&quot;(DT &quot;</span>, show c, <span class="st">&quot; &quot;</span>, show l</a>
<a class="sourceLine" id="cb28-20" data-line-number="20">        , <span class="st">&quot; ... &quot;</span>, show r, <span class="st">&quot;)&quot;</span></a>
<a class="sourceLine" id="cb28-21" data-line-number="21">        ]</a></code></pre></div>
</section>
</article>
</body>
</html>
