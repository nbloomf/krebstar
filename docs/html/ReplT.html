<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>The Read, Eval, Print Loop</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="../style.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<article>
<header>
<h1 class="title">The Read, Eval, Print Loop</h1>
<p class="subtitle">Kreb.Control.ReplT</p>
</header>
<div class="frontmatter">
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE InstanceSigs #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="kw">module</span> <span class="dt">Kreb.Control.ReplT</span> (</a>
<a class="sourceLine" id="cb1-4" data-line-number="4">    <span class="dt">ReplParams</span>(<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">  , <span class="dt">ReplT</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  , runReplT</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  , loopReplT</a>
<a class="sourceLine" id="cb1-8" data-line-number="8">) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-9" data-line-number="9"></a>
<a class="sourceLine" id="cb1-10" data-line-number="10"><span class="kw">import</span> <span class="dt">Kreb.Control.Trans</span></a></code></pre></div>
</div>
<section id="interactive-systems" class="level2">
<h2>Interactive Systems</h2>
<p>Text editors are meant to be used by people. In particular, text editors are meant to interact with, and take direction from, an agent many orders of magnitude slower than themselves. During typical usage the human will spend much more time thinking than the machine will spend working. This pattern of interaction lends itself well to a model called the <em>read, evaluate, print loop</em>, or “REPL” for short.</p>
<p>You are probably familiar with REPLs, if not necessarily by that name. <em>Command line environments</em> such as shells and language interpreters are the classic example, but the model extends much more broadly than this. We can call a system a REPL if its operation can be divided into three phases which cycle one after the other indefinitely:</p>
<ul>
<li>The <em>Read</em> phase, where the system accepts <em>input</em> via some agreed upon interface;</li>
<li>The <em>Eval</em> phase, where the system <em>updates</em> its internal state based on the input;</li>
<li>The <em>Print</em> phase, where the system emits <em>output</em> representing its internal state.</li>
</ul>
<p>In a text editor, the Read phase will generally involve accepting keyboard or mouse events, the Eval phase will involve updating a text buffer in memory, and the Print phase will involve writing a buffer to the screen, followed by a (relatively) long wait for the next Read cycle.</p>
<p>Two properties of the REPL pattern make it especially handy as a tool for designing software. First, it is extremely general. Virtually all interactive software can be modeled with it, since it is basically a thin layer on top of a state machine. Second, and crucially, the REPL pattern naturally maintains hard boundaries between the three phases. The Eval phase should not be reading in-band input, and the Print phase should not be updating state. This division of labor among the phases helps us manage complexity.</p>
<p>Because it is so general we can express the REPL pattern in terms of just a few atomic pieces: the Read, Eval, and Print phases, along with two more added for practicality. We also have an Init phase, which runs before the main loop and sets up the environment, and the Exit phase, which cleans up when the loop needs to stop.</p>
<p>We can wrap these 5 functions in a data type for convenience.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co">-- | The essential pieces of a REPL. Uses the following type parameters:</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="co">--</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3"><span class="co">-- * @act@ : semantic /actions/ accepted by the evaluator</span></a>
<a class="sourceLine" id="cb2-4" data-line-number="4"><span class="co">-- * @sig@ : out-of-band /signals/ (e.g. errors)</span></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="co">-- * @env@ : read-only state</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="co">-- * @st@  : mutable state</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7"><span class="co">-- * @m@   : effect monad</span></a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9"><span class="kw">data</span> <span class="dt">ReplParams</span> act env sig st m <span class="fu">=</span> <span class="dt">ReplParams</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  {<span class="ot"> _Init  ::</span> env <span class="ot">-&gt;</span> st <span class="ot">-&gt;</span> m (<span class="dt">Either</span> sig st)        <span class="co">--  | Startup</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  ,<span class="ot"> _Read  ::</span> env <span class="ot">-&gt;</span> st <span class="ot">-&gt;</span> m act                    <span class="co">--  | Get input</span></a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  ,<span class="ot"> _Eval  ::</span> env <span class="ot">-&gt;</span> st <span class="ot">-&gt;</span> act <span class="ot">-&gt;</span> m (<span class="dt">Either</span> sig st) <span class="co">--  | Update state</span></a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  ,<span class="ot"> _Print ::</span> env <span class="ot">-&gt;</span> st <span class="ot">-&gt;</span> m ()                     <span class="co">--  | Send output</span></a>
<a class="sourceLine" id="cb2-14" data-line-number="14">  ,<span class="ot"> _Exit  ::</span> sig <span class="ot">-&gt;</span> m ()                           <span class="co">--  | Cleanup</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15">  }</a></code></pre></div>
<p>Note that our REPL functions collectively use several type parameters which the application will have to specify. These include the type of <em>actions</em> understood by the Read phase and accepted by the Eval phase, as well as a type of <em>signals</em> for communicating out-of-band status such as exceptions. We also have read-only and mutable state to be used in the underlying monad, <code>m</code>.</p>
</section>
<section id="the-replt-transformer" class="level2">
<h2>The ReplT Transformer</h2>
<p>Given a set of REPL parameters, we can express the logic of the read, eval, print loop at a very high level. We’ll implement this in the form of a monad transformer, <code>ReplT</code>. This type bundles up the concept of a REPL over an arbitrary effect monad <code>m</code>.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">ReplT</span> act env sig st m a <span class="fu">=</span> <span class="dt">ReplT</span></a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  { unReplT</a>
<a class="sourceLine" id="cb3-3" data-line-number="3"><span class="ot">      ::</span> <span class="dt">ReplParams</span> act env sig st m</a>
<a class="sourceLine" id="cb3-4" data-line-number="4">      <span class="ot">-&gt;</span> env <span class="ot">-&gt;</span> st</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">      <span class="ot">-&gt;</span> m (a, st)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">  }</a></code></pre></div>
<p>Note that, as a monad transformer, <code>ReplT</code> essentially augments the monad <code>m</code> with an extra bit of mutable state and two bits of read-only state. As usual, we can evaluate a <code>ReplT</code> computation by providing inital values for this state.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">runReplT</a>
<a class="sourceLine" id="cb4-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Monad</span> m )</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">ReplParams</span> act env sig st m <span class="ot">-&gt;</span> env <span class="ot">-&gt;</span> st</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">ReplT</span> act env sig st m a <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">runReplT next env st (<span class="dt">ReplT</span> x) <span class="fu">=</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">  fst <span class="fu">&lt;$&gt;</span> x next env st</a></code></pre></div>
<p>We also need to specify <code>Functor</code>, <code>Applicative</code>, and <code>Monad</code> instances for <code>ReplT</code>; this code is standard stuff.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  ( <span class="dt">Monad</span> m</a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">ReplT</span> act env sig st m)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    fmap f (<span class="dt">ReplT</span> x) <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">      <span class="dt">ReplT</span> <span class="fu">$</span> \next env st1 <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-7" data-line-number="7">        (a, st2) <span class="ot">&lt;-</span> x next env st1</a>
<a class="sourceLine" id="cb5-8" data-line-number="8">        return (f a, st2)</a>
<a class="sourceLine" id="cb5-9" data-line-number="9"></a>
<a class="sourceLine" id="cb5-10" data-line-number="10"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb5-11" data-line-number="11">  ( <span class="dt">Monad</span> m</a>
<a class="sourceLine" id="cb5-12" data-line-number="12">  ) <span class="ot">=&gt;</span> <span class="dt">Applicative</span> (<span class="dt">ReplT</span> act env sig st m)</a>
<a class="sourceLine" id="cb5-13" data-line-number="13">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-14" data-line-number="14">    pure a <span class="fu">=</span> <span class="dt">ReplT</span> <span class="fu">$</span> \_ _ st <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-15" data-line-number="15">      pure (a, st)</a>
<a class="sourceLine" id="cb5-16" data-line-number="16"></a>
<a class="sourceLine" id="cb5-17" data-line-number="17">    (<span class="dt">ReplT</span> f) <span class="fu">&lt;*&gt;</span> (<span class="dt">ReplT</span> x) <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-18" data-line-number="18">      <span class="dt">ReplT</span> <span class="fu">$</span> \next env st1 <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-19" data-line-number="19">        (g, st2) <span class="ot">&lt;-</span> f next env st1</a>
<a class="sourceLine" id="cb5-20" data-line-number="20">        (a, st3) <span class="ot">&lt;-</span> x next env st2</a>
<a class="sourceLine" id="cb5-21" data-line-number="21">        return (g a, st3)</a>
<a class="sourceLine" id="cb5-22" data-line-number="22"></a>
<a class="sourceLine" id="cb5-23" data-line-number="23"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb5-24" data-line-number="24">  ( <span class="dt">Monad</span> m</a>
<a class="sourceLine" id="cb5-25" data-line-number="25">  ) <span class="ot">=&gt;</span> <span class="dt">Monad</span> (<span class="dt">ReplT</span> act env sig st m)</a>
<a class="sourceLine" id="cb5-26" data-line-number="26">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-27" data-line-number="27">    return <span class="fu">=</span> pure</a>
<a class="sourceLine" id="cb5-28" data-line-number="28"></a>
<a class="sourceLine" id="cb5-29" data-line-number="29">    (<span class="dt">ReplT</span> x) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-30" data-line-number="30">      <span class="dt">ReplT</span> <span class="fu">$</span> \next env st1 <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb5-31" data-line-number="31">        (a, st2) <span class="ot">&lt;-</span> x next env st1</a>
<a class="sourceLine" id="cb5-32" data-line-number="32">        unReplT (f a) next env st2</a></code></pre></div>
<p>And finally, we can lift a monadic value into <code>ReplT m</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">MonadTrans</span> (<span class="dt">ReplT</span> act env sig st) <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  lift</a>
<a class="sourceLine" id="cb6-3" data-line-number="3"><span class="ot">    ::</span> ( <span class="dt">Monad</span> m )</a>
<a class="sourceLine" id="cb6-4" data-line-number="4">    <span class="ot">=&gt;</span> m a <span class="ot">-&gt;</span> <span class="dt">ReplT</span> act env sig st m a</a>
<a class="sourceLine" id="cb6-5" data-line-number="5">  lift x <span class="fu">=</span> <span class="dt">ReplT</span> <span class="fu">$</span> \_ _ st <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-6" data-line-number="6">    a <span class="ot">&lt;-</span> x</a>
<a class="sourceLine" id="cb6-7" data-line-number="7">    return (a, st)</a></code></pre></div>
<p>Effectively, <code>ReplT</code> will let us add REPL functionality to an arbitrary monad <code>m</code>. In a “real” program <code>m</code> will be <code>IO</code>. But we will also have the freedom to swap out <code>IO</code> for another type. In particular we can use it to run computations in a mock environment.</p>
</section>
<section id="expressing-the-loop" class="level2">
<h2>Expressing the Loop</h2>
<p>We’re nearly prepared to express the L in REPL. The logic will be more clear if we first define some lifted versions of the parameter functions to handle threading state.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">_init</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Monad</span> m )</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">ReplT</span> act env sig st m (<span class="dt">Maybe</span> sig)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">_init <span class="fu">=</span> <span class="dt">ReplT</span> <span class="fu">$</span> \params env st1 <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  result <span class="ot">&lt;-</span> _Init params env st1</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="kw">case</span> result <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    <span class="dt">Left</span> sig <span class="ot">-&gt;</span> return (<span class="dt">Just</span> sig, st1)</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">    <span class="dt">Right</span> st2 <span class="ot">-&gt;</span> return (<span class="dt">Nothing</span>, st2)</a>
<a class="sourceLine" id="cb7-9" data-line-number="9"></a>
<a class="sourceLine" id="cb7-10" data-line-number="10">_read</a>
<a class="sourceLine" id="cb7-11" data-line-number="11"><span class="ot">  ::</span> ( <span class="dt">Monad</span> m )</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">  <span class="ot">=&gt;</span> <span class="dt">ReplT</span> act env sig st m act</a>
<a class="sourceLine" id="cb7-13" data-line-number="13">_read <span class="fu">=</span> <span class="dt">ReplT</span> <span class="fu">$</span> \params env st <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">  act <span class="ot">&lt;-</span> _Read params env st</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">  return (act, st)</a>
<a class="sourceLine" id="cb7-16" data-line-number="16"></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">_eval</a>
<a class="sourceLine" id="cb7-18" data-line-number="18"><span class="ot">  ::</span> ( <span class="dt">Monad</span> m )</a>
<a class="sourceLine" id="cb7-19" data-line-number="19">  <span class="ot">=&gt;</span> act <span class="ot">-&gt;</span> <span class="dt">ReplT</span> act env sig st m (<span class="dt">Maybe</span> sig)</a>
<a class="sourceLine" id="cb7-20" data-line-number="20">_eval act <span class="fu">=</span> <span class="dt">ReplT</span> <span class="fu">$</span> \params env st1 <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-21" data-line-number="21">  result <span class="ot">&lt;-</span> _Eval params env st1 act</a>
<a class="sourceLine" id="cb7-22" data-line-number="22">  return <span class="fu">$</span> <span class="kw">case</span> result <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">    <span class="dt">Right</span> st2 <span class="ot">-&gt;</span> (<span class="dt">Nothing</span>, st2)</a>
<a class="sourceLine" id="cb7-24" data-line-number="24">    <span class="dt">Left</span> sig <span class="ot">-&gt;</span> (<span class="dt">Just</span> sig, st1)</a>
<a class="sourceLine" id="cb7-25" data-line-number="25"></a>
<a class="sourceLine" id="cb7-26" data-line-number="26">_print</a>
<a class="sourceLine" id="cb7-27" data-line-number="27"><span class="ot">  ::</span> ( <span class="dt">Monad</span> m )</a>
<a class="sourceLine" id="cb7-28" data-line-number="28">  <span class="ot">=&gt;</span> <span class="dt">ReplT</span> act env sig st m ()</a>
<a class="sourceLine" id="cb7-29" data-line-number="29">_print <span class="fu">=</span> <span class="dt">ReplT</span> <span class="fu">$</span> \params env st <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-30" data-line-number="30">  _Print params env st</a>
<a class="sourceLine" id="cb7-31" data-line-number="31">  return ((), st)</a>
<a class="sourceLine" id="cb7-32" data-line-number="32"></a>
<a class="sourceLine" id="cb7-33" data-line-number="33">_exit</a>
<a class="sourceLine" id="cb7-34" data-line-number="34"><span class="ot">  ::</span> ( <span class="dt">Monad</span> m )</a>
<a class="sourceLine" id="cb7-35" data-line-number="35">  <span class="ot">=&gt;</span> sig <span class="ot">-&gt;</span> <span class="dt">ReplT</span> act env sig st m ()</a>
<a class="sourceLine" id="cb7-36" data-line-number="36">_exit sig <span class="fu">=</span> <span class="dt">ReplT</span> <span class="fu">$</span> \params _ st <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb7-37" data-line-number="37">  _Exit params sig</a>
<a class="sourceLine" id="cb7-38" data-line-number="38">  return ((), st)</a></code></pre></div>
<p>Now for the main event. <code>loopReplT</code> is the top-level function we expose for running REPLs.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">loopReplT</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Monad</span> m )</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">ReplT</span> act env sig st m ()</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">loopReplT <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">  result <span class="ot">&lt;-</span> _init</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">  <span class="kw">case</span> result <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> _print <span class="fu">&gt;&gt;</span> _loop</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">    <span class="dt">Just</span> sig <span class="ot">-&gt;</span> _exit sig</a>
<a class="sourceLine" id="cb8-9" data-line-number="9"></a>
<a class="sourceLine" id="cb8-10" data-line-number="10">_loop</a>
<a class="sourceLine" id="cb8-11" data-line-number="11"><span class="ot">  ::</span> ( <span class="dt">Monad</span> m )</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">  <span class="ot">=&gt;</span> <span class="dt">ReplT</span> act env sig st m ()</a>
<a class="sourceLine" id="cb8-13" data-line-number="13">_loop <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">  result <span class="ot">&lt;-</span> _read <span class="fu">&gt;&gt;=</span> _eval</a>
<a class="sourceLine" id="cb8-15" data-line-number="15">  <span class="kw">case</span> result <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-16" data-line-number="16">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> _print <span class="fu">&gt;&gt;</span> _loop</a>
<a class="sourceLine" id="cb8-17" data-line-number="17">    <span class="dt">Just</span> sig <span class="ot">-&gt;</span> _exit sig</a></code></pre></div>
</section>
</article>
</body>
</html>
