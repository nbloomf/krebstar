<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Run Length Encoding</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="../style.css">
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<article>
<header>
<h1 class="title">Run Length Encoding</h1>
</header>
<div class="contents">
<ul>
<li><a href="#list-compression">List Compression</a>: Saying more with less</li>
<li><a href="#auxiliary-types">Auxiliary Types</a>: We need a couple</li>
<li><a href="#run-length-encoding">Run Length Encoding</a>: The main event</li>
<li><a href="#queries">Queries</a>: Extracting value from a list</li>
<li><a href="#cons-and-concat">Cons and Concat</a>: List operations</li>
<li><a href="#testing-and-debugging">Testing and Debugging</a>: For when things go wrong</li>
</ul>
</div>
<div class="frontmatter">
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">{-# LANGUAGE InstanceSigs #-}</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="kw">module</span> <span class="dt">Kreb.Struct.RunLengthEncoded</span> (</a>
<a class="sourceLine" id="cb1-5" data-line-number="5">    <span class="dt">RunSize</span>()</a>
<a class="sourceLine" id="cb1-6" data-line-number="6">  , <span class="dt">Run</span>(unRun)</a>
<a class="sourceLine" id="cb1-7" data-line-number="7">  , mkRun</a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">  , <span class="dt">RunLengthEncoded</span>()</a>
<a class="sourceLine" id="cb1-10" data-line-number="10">  , fromRuns</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">  , empty</a>
<a class="sourceLine" id="cb1-12" data-line-number="12">  , singleton</a>
<a class="sourceLine" id="cb1-13" data-line-number="13">  , toRuns</a>
<a class="sourceLine" id="cb1-14" data-line-number="14">  , fromList</a>
<a class="sourceLine" id="cb1-15" data-line-number="15"></a>
<a class="sourceLine" id="cb1-16" data-line-number="16">  , isEmpty</a>
<a class="sourceLine" id="cb1-17" data-line-number="17">  , countItems</a>
<a class="sourceLine" id="cb1-18" data-line-number="18">  , countRuns</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">  , isSingleton</a>
<a class="sourceLine" id="cb1-20" data-line-number="20">  , firstRun</a>
<a class="sourceLine" id="cb1-21" data-line-number="21">  , lastRun</a>
<a class="sourceLine" id="cb1-22" data-line-number="22"></a>
<a class="sourceLine" id="cb1-23" data-line-number="23">  , cons</a>
<a class="sourceLine" id="cb1-24" data-line-number="24">  , uncons</a>
<a class="sourceLine" id="cb1-25" data-line-number="25">  , snoc</a>
<a class="sourceLine" id="cb1-26" data-line-number="26">  , unsnoc</a>
<a class="sourceLine" id="cb1-27" data-line-number="27"></a>
<a class="sourceLine" id="cb1-28" data-line-number="28">  , validate</a>
<a class="sourceLine" id="cb1-29" data-line-number="29">) <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-30" data-line-number="30"></a>
<a class="sourceLine" id="cb1-31" data-line-number="31"><span class="kw">import</span> <span class="dt">Data.Foldable</span></a>
<a class="sourceLine" id="cb1-32" data-line-number="32"><span class="kw">import</span> <span class="dt">Data.List</span> (intercalate, genericLength)</a>
<a class="sourceLine" id="cb1-33" data-line-number="33"></a>
<a class="sourceLine" id="cb1-34" data-line-number="34"><span class="kw">import</span> <span class="dt">Kreb.Check</span></a>
<a class="sourceLine" id="cb1-35" data-line-number="35"></a>
<a class="sourceLine" id="cb1-36" data-line-number="36"><span class="kw">import</span>           <span class="dt">Kreb.Struct.Valued</span></a>
<a class="sourceLine" id="cb1-37" data-line-number="37"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Kreb.Struct.FingerTree</span> <span class="kw">as</span> <span class="dt">FT</span></a></code></pre></div>
</div>
<section id="list-compression" class="level2">
<h2>List Compression</h2>
<p>Recall that with finger trees we have a list-like data structure that supports efficient concatenation and search. We will be using that structure in a few different capacities, one of which is a little strange. For reasons we’ll see later, it will be very useful to work with lists whose entries come from a very small set of only four possible values which moreover appear in long <em>runs</em> of many identical items. In this situation we can save a lot of space by keeping track of the runs rather than the individual items.</p>
<p>For example, consider a list consisting of five of one item followed by three of another.</p>
<div class="example">
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1">[<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;a&#39;</span>,<span class="ch">&#39;b&#39;</span>,<span class="ch">&#39;b&#39;</span>,<span class="ch">&#39;b&#39;</span>]</a></code></pre></div>
</div>
<p>This list could be stored instead as</p>
<div class="example">
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">[(<span class="ch">&#39;a&#39;</span>,<span class="dv">5</span>),(<span class="ch">&#39;b&#39;</span>,<span class="dv">3</span>)]</a></code></pre></div>
</div>
<p>with no loss of information. The second representation will use less space as long as the ratio of long runs to short runs in the data is large enough. This way of compressing lists is called <em>run length encoding</em>, because we’re doing exactly that – encoding the run lengths.</p>
<p>There’s another way to think about run length encoding that I particularly like. Recall that the list type constructor corresponds to the free monoid construction on an arbitrary set. With an associative operator we have the handy exponential notation for abbreviating products; rather than <span class="math inline">\(aaa\)</span> we can say <span class="math inline">\(a^3\)</span>. But this is precisely run length encoding!</p>
</section>
<section id="auxiliary-types" class="level2">
<h2>Auxiliary Types</h2>
<p>Run length encoded lists are still lists, they just keep some extra information at each index. As such they can be constructed using any type isomorphic to lists. We’ve got a particularly nice list-like type on hand – finger trees – so we’ll use that.</p>
<p>Recall that to define a concrete finger tree type we need an appropriate annotation monoid to represent the ‘measure’ of both items in the list and the list as a whole. A natural choice for this is a count of the number of items in the list, as we’ve been using with the <code>Count</code> value type so far. But the structure of run length encoded lists offers another natural measurement, namely the number of runs. We can keep track of both with the <code>RunSize</code> type.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">data</span> <span class="dt">RunSize</span> <span class="fu">=</span> <span class="dt">RunSize</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  {<span class="ot"> runCount  ::</span> <span class="dt">Integer</span> <span class="co">-- number of runs</span></a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  ,<span class="ot"> runLength ::</span> <span class="dt">Integer</span> <span class="co">-- number of items in all runs</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Before moving on we should note some constraints on <code>RunSize</code>. Internally it keeps track of two integers, which may be negative. But these integers each represent a <em>size</em>, and it doesn’t make sense for them to be negative. Consumers of this module won’t need to worry about this but we need to keep it in mind.</p>
<p>We’ll make <code>RunSize</code> an additive monoid: the total length of two runs put together is the sum of their individual lengths.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">RunSize</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  (<span class="dt">RunSize</span> s1 l1) <span class="fu">&lt;&gt;</span> (<span class="dt">RunSize</span> s2 l2) <span class="fu">=</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    <span class="dt">RunSize</span> (s1 <span class="fu">+</span> s2) (l1 <span class="fu">+</span> l2)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">RunSize</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  mempty <span class="fu">=</span> <span class="dt">RunSize</span> <span class="dv">0</span> <span class="dv">0</span></a></code></pre></div>
<p>Next we’ll need a wrapper type to represent value/run length pairs.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">Run</span> a <span class="fu">=</span> <span class="dt">Run</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  {<span class="ot"> unRun ::</span> (<span class="dt">Integer</span>, a)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">  } <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Again, to maintain the invariant that the run length must be positive we expose a smart constructor and destructor. We could in principle allow for length zero runs, but this would mean our lists no longer have a canonical representation and that any given list can have representations of arbitrarily large size.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1">mkRun</a>
<a class="sourceLine" id="cb7-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Run</span> a</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">mkRun k a <span class="fu">=</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="kw">if</span> k <span class="fu">&lt;=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    <span class="kw">then</span> error <span class="fu">$</span> concat</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">      [ <span class="st">&quot;mkRun: run length must be positive, &quot;</span></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">      , <span class="st">&quot;but got &quot;</span>, show k ]</a>
<a class="sourceLine" id="cb7-8" data-line-number="8">    <span class="kw">else</span> <span class="dt">Run</span> (k, a)</a></code></pre></div>
<p>Finally we need some class instances for <code>Run</code>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  <span class="dt">Valued</span> <span class="dt">RunSize</span> (<span class="dt">Run</span> a)</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    value (<span class="dt">Run</span> (k, _)) <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">      <span class="dt">RunSize</span> <span class="dv">1</span> k</a>
<a class="sourceLine" id="cb8-6" data-line-number="6"></a>
<a class="sourceLine" id="cb8-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Run</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8">  fmap f (<span class="dt">Run</span> (k, a)) <span class="fu">=</span> <span class="dt">Run</span> (k, f a)</a></code></pre></div>
</section>
<section id="run-length-encoding" class="level2">
<h2>Run Length Encoding</h2>
<p>We’re now prepared to define run length encoded lists in terms of <code>RunSize</code> and <code>Run</code>.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">newtype</span> <span class="dt">RunLengthEncoded</span> a <span class="fu">=</span> <span class="dt">RLE</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2">  {<span class="ot"> unRLE ::</span> <span class="dt">FT.FingerTree</span> <span class="dt">RunSize</span> (<span class="dt">Run</span> a)</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  } <span class="kw">deriving</span> <span class="dt">Eq</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  <span class="dt">Valued</span> <span class="dt">RunSize</span> (<span class="dt">RunLengthEncoded</span> a)</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    value (<span class="dt">RLE</span> x) <span class="fu">=</span> value x</a>
<a class="sourceLine" id="cb9-9" data-line-number="9"></a>
<a class="sourceLine" id="cb9-10" data-line-number="10"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">  <span class="dt">Functor</span> <span class="dt">RunLengthEncoded</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">    fmap f (<span class="dt">RLE</span> x) <span class="fu">=</span> <span class="dt">RLE</span> <span class="fu">$</span> FT.fmapFT (fmap f) x</a></code></pre></div>
<p>We’d like for our internal representation to maintain an additional invariant: that two adjacent runs always have distinct ‘bases’. For instance, using list notation, a representation like</p>
<div class="example">
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">[(<span class="ch">&#39;a&#39;</span>,<span class="dv">5</span>),(<span class="ch">&#39;a&#39;</span>,<span class="dv">2</span>),(<span class="ch">&#39;b&#39;</span>,<span class="dv">9</span>)]</a></code></pre></div>
</div>
<p>could be written instead as</p>
<div class="example">
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1">[(<span class="ch">&#39;a&#39;</span>,<span class="dv">7</span>),(<span class="ch">&#39;b&#39;</span>,<span class="dv">9</span>)]</a></code></pre></div>
</div>
<p>with no loss of information. Our <code>RunLengthEncoded</code> type can’t enforce this on its own, so we’ll have to do it using a smart constructor.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">fromRuns</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Eq</span> a )</a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="ot">=&gt;</span> [(<span class="dt">Integer</span>, a)] <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoded</span> a</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">fromRuns <span class="fu">=</span> foldr f mempty <span class="fu">.</span> filter nontrivial <span class="fu">.</span> combine</a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    f (k,a) xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">      (<span class="dt">RLE</span> <span class="fu">$</span> FT.fromList [mkRun k a]) <span class="fu">&lt;&gt;</span> xs</a>
<a class="sourceLine" id="cb12-8" data-line-number="8"></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    combine xs <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-10" data-line-number="10">      (k1, a1) <span class="fu">:</span> (k2, a2) <span class="fu">:</span> rest <span class="ot">-&gt;</span> <span class="kw">if</span> a1 <span class="fu">==</span> a2</a>
<a class="sourceLine" id="cb12-11" data-line-number="11">        <span class="kw">then</span> combine ((k1 <span class="fu">+</span> k2, a1) <span class="fu">:</span> rest)</a>
<a class="sourceLine" id="cb12-12" data-line-number="12">        <span class="kw">else</span> (k1, a1) <span class="fu">:</span> combine ((k2, a2) <span class="fu">:</span> rest)</a>
<a class="sourceLine" id="cb12-13" data-line-number="13">      _ <span class="ot">-&gt;</span> xs</a>
<a class="sourceLine" id="cb12-14" data-line-number="14"></a>
<a class="sourceLine" id="cb12-15" data-line-number="15">    nontrivial (k,_) <span class="fu">=</span> k <span class="fu">/=</span> <span class="dv">0</span></a></code></pre></div>
<p>From here we can also define the basic list-like constructors: <code>empty</code> and <code>singleton</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">empty</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Eq</span> a )</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">RunLengthEncoded</span> a</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">empty <span class="fu">=</span> fromRuns []</a>
<a class="sourceLine" id="cb13-5" data-line-number="5"></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">singleton</a>
<a class="sourceLine" id="cb13-7" data-line-number="7"><span class="ot">  ::</span> ( <span class="dt">Eq</span> a )</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoded</span> a</a>
<a class="sourceLine" id="cb13-9" data-line-number="9">singleton a <span class="fu">=</span> fromRuns [(<span class="dv">1</span>, a)]</a></code></pre></div>
<p>We’ll also convert run length encoded lists back into ordinary lists of runs; this is mostly helpful for testing.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">toRuns</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">RunLengthEncoded</span> a <span class="ot">-&gt;</span> [(<span class="dt">Integer</span>, a)]</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">toRuns (<span class="dt">RLE</span> x) <span class="fu">=</span> map unRun <span class="fu">$</span> toList x</a></code></pre></div>
<p>This is a good place to stop and see some round trip examples.</p>
<div class="doctest">
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="co">-- &gt;&gt;&gt; toRuns $ fromRuns [(5,&#39;a&#39;),(2,&#39;a&#39;),(4,&#39;b&#39;)]</span></a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="co">-- [(7,&#39;a&#39;),(4,&#39;b&#39;)]</span></a>
<a class="sourceLine" id="cb15-4" data-line-number="4"><span class="co">--</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5"><span class="co">-- &gt;&gt;&gt; toRuns $ fromRuns [(0,&#39;a&#39;),(1,&#39;b&#39;),(0,&#39;c&#39;)]</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6"><span class="co">-- [(1,&#39;b&#39;)]</span></a>
<a class="sourceLine" id="cb15-7" data-line-number="7"><span class="co">--</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8"><span class="co">-- &gt;&gt;&gt; toRuns $ fromRuns [(0,&#39;a&#39;),(0,&#39;a&#39;),(0,&#39;a&#39;)]</span></a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="co">-- []</span></a></code></pre></div>
</div>
<p>We also have a <code>Foldable</code> instance for run length encoded lists.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">RunLengthEncoded</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-2" data-line-number="2">  foldr</a>
<a class="sourceLine" id="cb16-3" data-line-number="3"><span class="ot">    ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoded</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  foldr f e (<span class="dt">RLE</span> xs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">    <span class="kw">let</span></a>
<a class="sourceLine" id="cb16-6" data-line-number="6">      rep g n a <span class="fu">=</span> <span class="kw">if</span> n <span class="fu">&lt;=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb16-7" data-line-number="7">        <span class="kw">then</span> a</a>
<a class="sourceLine" id="cb16-8" data-line-number="8">        <span class="kw">else</span> rep g (n<span class="fu">-</span><span class="dv">1</span>) (g a)</a>
<a class="sourceLine" id="cb16-9" data-line-number="9">    <span class="kw">in</span> <span class="kw">case</span> FT.unsnoc xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-10" data-line-number="10">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> e</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">      <span class="dt">Just</span> (<span class="dt">Run</span> (k, a), ys) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb16-12" data-line-number="12">        foldr f (rep (f a) k e) (<span class="dt">RLE</span> ys)</a></code></pre></div>
<p>Run length encoded lists are isomorphic to cons lists, which we witness with explicit mappings between the two.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1">fromList</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Eq</span> a )</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoded</span> a</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">fromList <span class="fu">=</span> fromRuns <span class="fu">.</span> group</a>
<a class="sourceLine" id="cb17-5" data-line-number="5">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6"><span class="ot">    group ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [(<span class="dt">Integer</span>, a)]</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">    group xs <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">      [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb17-9" data-line-number="9">      a<span class="fu">:</span>as <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-10" data-line-number="10">        <span class="kw">let</span> (us, rest) <span class="fu">=</span> span (<span class="fu">==</span> a) as</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">        <span class="kw">in</span> (<span class="dv">1</span> <span class="fu">+</span> genericLength us, a) <span class="fu">:</span> group rest</a></code></pre></div>
<p>Note that we get the analogous <code>toList</code> function for free with <code>Foldable</code>. Here are some examples:</p>
<div class="doctest">
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="co">-- &gt;&gt;&gt; toRuns (fromList [&#39;a&#39;,&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;c&#39;,&#39;c&#39;])</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3"><span class="co">-- [(2,&#39;a&#39;),(1,&#39;b&#39;),(3,&#39;c&#39;)]</span></a>
<a class="sourceLine" id="cb18-4" data-line-number="4"><span class="co">--</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5"><span class="co">-- &gt;&gt;&gt; toList (fromRuns [(4,&#39;a&#39;),(3,&#39;b&#39;)])</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6"><span class="co">-- &quot;aaaabbb&quot;</span></a></code></pre></div>
</div>
</section>
<section id="queries" class="level2">
<h2>Queries</h2>
<p>Because run length encoded lists are isomorphic to lists, the usual list operations make sense here too. We can detect when a list is empty:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">isEmpty</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">RunLengthEncoded</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb19-3" data-line-number="3">isEmpty (<span class="dt">RLE</span> xs) <span class="fu">=</span> FT.isEmpty xs</a></code></pre></div>
<p>Detecting when the list is a singleton is a little more involved. The simplest way to do it is to first find the number of items in the list, and see if that number is 1. Fortunately, since the underlying structure is a finger tree, this is already done.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">countItems</a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">RunLengthEncoded</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb20-3" data-line-number="3">countItems <span class="fu">=</span> runLength <span class="fu">.</span> value</a>
<a class="sourceLine" id="cb20-4" data-line-number="4"></a>
<a class="sourceLine" id="cb20-5" data-line-number="5">countRuns</a>
<a class="sourceLine" id="cb20-6" data-line-number="6"><span class="ot">  ::</span> <span class="dt">RunLengthEncoded</span> a <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb20-7" data-line-number="7">countRuns <span class="fu">=</span> runCount <span class="fu">.</span> value</a>
<a class="sourceLine" id="cb20-8" data-line-number="8"></a>
<a class="sourceLine" id="cb20-9" data-line-number="9">isSingleton</a>
<a class="sourceLine" id="cb20-10" data-line-number="10"><span class="ot">  ::</span> <span class="dt">RunLengthEncoded</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb20-11" data-line-number="11">isSingleton as <span class="fu">=</span> <span class="dv">1</span> <span class="fu">==</span> countItems as</a></code></pre></div>
<p>It will also be useful to extract the first and last run of the list.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">firstRun</a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">RunLengthEncoded</span> a</a>
<a class="sourceLine" id="cb21-3" data-line-number="3">  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Run</span> a, <span class="dt">RunLengthEncoded</span> a)</a>
<a class="sourceLine" id="cb21-4" data-line-number="4">firstRun (<span class="dt">RLE</span> x) <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  <span class="kw">case</span> FT.uncons x <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">    <span class="dt">Just</span> (a, as) <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, <span class="dt">RLE</span> as)</a>
<a class="sourceLine" id="cb21-8" data-line-number="8"></a>
<a class="sourceLine" id="cb21-9" data-line-number="9">lastRun</a>
<a class="sourceLine" id="cb21-10" data-line-number="10"><span class="ot">  ::</span> <span class="dt">RunLengthEncoded</span> a</a>
<a class="sourceLine" id="cb21-11" data-line-number="11">  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Run</span> a, <span class="dt">RunLengthEncoded</span> a)</a>
<a class="sourceLine" id="cb21-12" data-line-number="12">lastRun (<span class="dt">RLE</span> x) <span class="fu">=</span></a>
<a class="sourceLine" id="cb21-13" data-line-number="13">  <span class="kw">case</span> FT.unsnoc x <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-14" data-line-number="14">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb21-15" data-line-number="15">    <span class="dt">Just</span> (a, as) <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, <span class="dt">RLE</span> as)</a></code></pre></div>
</section>
<section id="cons-and-concat" class="level2">
<h2>Cons and Concat</h2>
<p>Cons and uncons are a little more complicated than on ordinary lists.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">cons</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Eq</span> a )</a>
<a class="sourceLine" id="cb22-3" data-line-number="3"> <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoded</span> a <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoded</span> a</a>
<a class="sourceLine" id="cb22-4" data-line-number="4">cons a (<span class="dt">RLE</span> xs) <span class="fu">=</span> <span class="kw">case</span> FT.uncons xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5">  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> singleton a</a>
<a class="sourceLine" id="cb22-6" data-line-number="6">  <span class="dt">Just</span> (<span class="dt">Run</span> (k, b), zs) <span class="ot">-&gt;</span> <span class="kw">if</span> a <span class="fu">==</span> b</a>
<a class="sourceLine" id="cb22-7" data-line-number="7">    <span class="kw">then</span> <span class="dt">RLE</span> <span class="fu">$</span> FT.cons (<span class="dt">Run</span> (<span class="dv">1</span><span class="fu">+</span>k, a)) zs</a>
<a class="sourceLine" id="cb22-8" data-line-number="8">    <span class="kw">else</span> <span class="dt">RLE</span> <span class="fu">$</span> FT.cons (<span class="dt">Run</span> (<span class="dv">1</span>, a)) xs</a>
<a class="sourceLine" id="cb22-9" data-line-number="9"></a>
<a class="sourceLine" id="cb22-10" data-line-number="10">uncons</a>
<a class="sourceLine" id="cb22-11" data-line-number="11"><span class="ot">  ::</span> ( <span class="dt">Eq</span> a )</a>
<a class="sourceLine" id="cb22-12" data-line-number="12">  <span class="ot">=&gt;</span> <span class="dt">RunLengthEncoded</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">RunLengthEncoded</span> a)</a>
<a class="sourceLine" id="cb22-13" data-line-number="13">uncons (<span class="dt">RLE</span> xs) <span class="fu">=</span> <span class="kw">case</span> FT.uncons xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-14" data-line-number="14">  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb22-15" data-line-number="15">  <span class="dt">Just</span> (<span class="dt">Run</span> (k, a), as) <span class="ot">-&gt;</span> <span class="kw">if</span> k <span class="fu">==</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb22-16" data-line-number="16">    <span class="kw">then</span> <span class="dt">Just</span> (a, <span class="dt">RLE</span> as)</a>
<a class="sourceLine" id="cb22-17" data-line-number="17">    <span class="kw">else</span> <span class="dt">Just</span> (a, <span class="dt">RLE</span> <span class="fu">$</span> FT.cons (<span class="dt">Run</span> (k<span class="fu">-</span><span class="dv">1</span>, a)) as)</a></code></pre></div>
<p>Likewise <code>snoc</code> and <code>unsnoc</code>.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1">snoc</a>
<a class="sourceLine" id="cb23-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Eq</span> a )</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoded</span> a <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoded</span> a</a>
<a class="sourceLine" id="cb23-4" data-line-number="4">snoc a (<span class="dt">RLE</span> xs) <span class="fu">=</span> <span class="kw">case</span> FT.unsnoc xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-5" data-line-number="5">  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> singleton a</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">  <span class="dt">Just</span> (<span class="dt">Run</span> (k, b), zs) <span class="ot">-&gt;</span> <span class="kw">if</span> a <span class="fu">==</span> b</a>
<a class="sourceLine" id="cb23-7" data-line-number="7">    <span class="kw">then</span> <span class="dt">RLE</span> <span class="fu">$</span> FT.snoc (<span class="dt">Run</span> (<span class="dv">1</span><span class="fu">+</span>k, a)) zs</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">    <span class="kw">else</span> <span class="dt">RLE</span> <span class="fu">$</span> FT.snoc (<span class="dt">Run</span> (<span class="dv">1</span>, a)) xs</a>
<a class="sourceLine" id="cb23-9" data-line-number="9"></a>
<a class="sourceLine" id="cb23-10" data-line-number="10">unsnoc</a>
<a class="sourceLine" id="cb23-11" data-line-number="11"><span class="ot">  ::</span> ( <span class="dt">Eq</span> a )</a>
<a class="sourceLine" id="cb23-12" data-line-number="12">  <span class="ot">=&gt;</span> <span class="dt">RunLengthEncoded</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">RunLengthEncoded</span> a)</a>
<a class="sourceLine" id="cb23-13" data-line-number="13">unsnoc (<span class="dt">RLE</span> xs) <span class="fu">=</span> <span class="kw">case</span> FT.unsnoc xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-14" data-line-number="14">  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb23-15" data-line-number="15">  <span class="dt">Just</span> (<span class="dt">Run</span> (k, a), as) <span class="ot">-&gt;</span> <span class="kw">if</span> k <span class="fu">==</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb23-16" data-line-number="16">    <span class="kw">then</span> <span class="dt">Just</span> (a, <span class="dt">RLE</span> as)</a>
<a class="sourceLine" id="cb23-17" data-line-number="17">    <span class="kw">else</span> <span class="dt">Just</span> (a, <span class="dt">RLE</span> <span class="fu">$</span> FT.snoc (<span class="dt">Run</span> (k<span class="fu">-</span><span class="dv">1</span>, a)) as)</a></code></pre></div>
<p>When concatenating run length encoded lists, we need to be careful to combine the innermost runs to maintain the invariant that no two adjacent runs have the same base.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  ( <span class="dt">Eq</span> a</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">RunLengthEncoded</span> a)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">    (<span class="dt">RLE</span> as) <span class="fu">&lt;&gt;</span> (<span class="dt">RLE</span> bs) <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">      <span class="kw">case</span> FT.uncons bs <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-7" data-line-number="7">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">RLE</span> as</a>
<a class="sourceLine" id="cb24-8" data-line-number="8">        <span class="dt">Just</span> (<span class="dt">Run</span> (kb, b), bs&#39;) <span class="ot">-&gt;</span> <span class="kw">case</span> FT.unsnoc as <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-9" data-line-number="9">          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">RLE</span> bs</a>
<a class="sourceLine" id="cb24-10" data-line-number="10">          <span class="dt">Just</span> (<span class="dt">Run</span> (ka, a), as&#39;) <span class="ot">-&gt;</span> <span class="dt">RLE</span> <span class="fu">$</span> mconcat <span class="fu">$</span> <span class="kw">if</span> a <span class="fu">==</span> b</a>
<a class="sourceLine" id="cb24-11" data-line-number="11">            <span class="kw">then</span> [ as&#39;, FT.fromList [ <span class="dt">Run</span> (ka <span class="fu">+</span> kb, a) ], bs&#39; ]</a>
<a class="sourceLine" id="cb24-12" data-line-number="12">            <span class="kw">else</span> [ as, bs ]</a>
<a class="sourceLine" id="cb24-13" data-line-number="13"></a>
<a class="sourceLine" id="cb24-14" data-line-number="14"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb24-15" data-line-number="15">  ( <span class="dt">Eq</span> a</a>
<a class="sourceLine" id="cb24-16" data-line-number="16">  ) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">RunLengthEncoded</span> a)</a>
<a class="sourceLine" id="cb24-17" data-line-number="17">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-18" data-line-number="18">    mempty <span class="fu">=</span> <span class="dt">RLE</span> mempty</a></code></pre></div>
</section>
<section id="testing-and-debugging" class="level2">
<h2>Testing and Debugging</h2>
<p>I almost forgot to define a <code>Show</code> instance. This uses the run list representation so that rendered strings are valid Haskell code.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb25-2" data-line-number="2">  ( <span class="dt">Show</span> a</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">RunLengthEncoded</span> a)</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5">    show xs <span class="fu">=</span> concat</a>
<a class="sourceLine" id="cb25-6" data-line-number="6">      [ <span class="st">&quot;fromRuns &quot;</span></a>
<a class="sourceLine" id="cb25-7" data-line-number="7">      , show (toRuns xs)</a>
<a class="sourceLine" id="cb25-8" data-line-number="8">      ]</a></code></pre></div>
<p>And finally, we need some class instances to interact with the testing framework.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Arb</span> <span class="dt">RunSize</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-2" data-line-number="2">  arb <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-3" data-line-number="3">    <span class="dt">NonNegative</span> s <span class="ot">&lt;-</span> arb</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">    <span class="dt">NonNegative</span> l <span class="ot">&lt;-</span> arb</a>
<a class="sourceLine" id="cb26-5" data-line-number="5">    return <span class="fu">$</span> <span class="dt">RunSize</span> s l</a>
<a class="sourceLine" id="cb26-6" data-line-number="6"></a>
<a class="sourceLine" id="cb26-7" data-line-number="7"><span class="kw">instance</span> <span class="dt">Prune</span> <span class="dt">RunSize</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-8" data-line-number="8">  prune (<span class="dt">RunSize</span> a b) <span class="fu">=</span></a>
<a class="sourceLine" id="cb26-9" data-line-number="9">    [ <span class="dt">RunSize</span> a c <span class="fu">|</span> c <span class="ot">&lt;-</span> map abs <span class="fu">$</span> prune b ] <span class="fu">++</span></a>
<a class="sourceLine" id="cb26-10" data-line-number="10">    [ <span class="dt">RunSize</span> c b <span class="fu">|</span> c <span class="ot">&lt;-</span> map abs <span class="fu">$</span> prune a ]</a>
<a class="sourceLine" id="cb26-11" data-line-number="11"></a>
<a class="sourceLine" id="cb26-12" data-line-number="12"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb26-13" data-line-number="13">  ( <span class="dt">Arb</span> a, <span class="dt">Eq</span> a</a>
<a class="sourceLine" id="cb26-14" data-line-number="14">  ) <span class="ot">=&gt;</span> <span class="dt">Arb</span> (<span class="dt">Run</span> a)</a>
<a class="sourceLine" id="cb26-15" data-line-number="15">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-16" data-line-number="16">    arb <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-17" data-line-number="17">      <span class="dt">Positive</span> k <span class="ot">&lt;-</span> arb</a>
<a class="sourceLine" id="cb26-18" data-line-number="18">      a <span class="ot">&lt;-</span> arb</a>
<a class="sourceLine" id="cb26-19" data-line-number="19">      return (mkRun k a)</a>
<a class="sourceLine" id="cb26-20" data-line-number="20"></a>
<a class="sourceLine" id="cb26-21" data-line-number="21"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb26-22" data-line-number="22">  ( <span class="dt">Prune</span> a, <span class="dt">Eq</span> a</a>
<a class="sourceLine" id="cb26-23" data-line-number="23">  ) <span class="ot">=&gt;</span> <span class="dt">Prune</span> (<span class="dt">Run</span> a)</a>
<a class="sourceLine" id="cb26-24" data-line-number="24">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-25" data-line-number="25">    prune (<span class="dt">Run</span> z) <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-26" data-line-number="26">      (k&#39;, a&#39;) <span class="ot">&lt;-</span> prune z</a>
<a class="sourceLine" id="cb26-27" data-line-number="27">      return <span class="fu">$</span> mkRun (abs k&#39;) a&#39;</a>
<a class="sourceLine" id="cb26-28" data-line-number="28"></a>
<a class="sourceLine" id="cb26-29" data-line-number="29"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb26-30" data-line-number="30">  ( <span class="dt">Arb</span> a, <span class="dt">Eq</span> a</a>
<a class="sourceLine" id="cb26-31" data-line-number="31">  ) <span class="ot">=&gt;</span> <span class="dt">Arb</span> (<span class="dt">RunLengthEncoded</span> a)</a>
<a class="sourceLine" id="cb26-32" data-line-number="32">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-33" data-line-number="33">    arb <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb26-34" data-line-number="34">      xs <span class="ot">&lt;-</span> listOf arb</a>
<a class="sourceLine" id="cb26-35" data-line-number="35">      return <span class="fu">$</span> fromRuns <span class="fu">$</span> map unRun xs</a>
<a class="sourceLine" id="cb26-36" data-line-number="36"></a>
<a class="sourceLine" id="cb26-37" data-line-number="37"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb26-38" data-line-number="38">  ( <span class="dt">Prune</span> a, <span class="dt">Eq</span> a</a>
<a class="sourceLine" id="cb26-39" data-line-number="39">  ) <span class="ot">=&gt;</span> <span class="dt">Prune</span> (<span class="dt">RunLengthEncoded</span> a)</a>
<a class="sourceLine" id="cb26-40" data-line-number="40">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-41" data-line-number="41">    prune <span class="fu">=</span> map fromRuns <span class="fu">.</span> filter (<span class="fu">/=</span> []) <span class="fu">.</span> prune <span class="fu">.</span> toRuns</a></code></pre></div>
<p>And because run length encoded lists have an essential invariant, we should expose a predicate to make sure the invariant is satisfied.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">validate</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Eq</span> a )</a>
<a class="sourceLine" id="cb27-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">RunLengthEncoded</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-4" data-line-number="4">validate <span class="fu">=</span> and <span class="fu">.</span> map ((<span class="fu">&gt;</span> <span class="dv">0</span>) <span class="fu">.</span> fst) <span class="fu">.</span> toRuns</a></code></pre></div>
</section>
</article>
</body>
</html>
