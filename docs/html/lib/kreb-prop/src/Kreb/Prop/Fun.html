<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="nbloomf">
  <title>Shrinkable, Showable Functions</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="../../../../../../styles/style.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <script>
    window.MathJax = {
      tex: {
        macros: {
          dom: "\\mathsf{dom}",
          cod: "\\mathsf{cod}",
          id:  "\\mathsf{id}",
          Hask: "\\mathsf{Hask}",
        }
      }
    };
  </script
</head>
<body>
<article>
<header>
<h1 class="title">Shrinkable, Showable Functions</h1>
<p class="byline">nbloomf</p>
</header>
<div class="frontmatter">
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">module</span> <span class="dt">Kreb.Prop.Fun</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">import</span> <span class="dt">Data.List</span> (intersperse, subsequences)</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span> <span class="dt">Data.Word</span> (<span class="dt">Word8</span>)</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span> <span class="dt">Data.Char</span> (ord, chr)</a>
<a class="sourceLine" id="cb1-6" title="6"></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Kreb.Format</span> <span class="kw">as</span> <span class="dt">Fmt</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">import</span>           <span class="dt">Kreb.Format</span></a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="kw">import</span> <span class="dt">Kreb.Prop.Sample</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="kw">import</span> <span class="dt">Kreb.Prop.Arb</span></a></code></pre></div>
</div>
<section class="level2">
<h2>Introduction</h2>
<p>The <code>Arb</code> class is inhabited by types of which we can generate arbitrary values, and <code>Prune</code> by types whose values can be made "smaller" in some sense. Both are used to search for counterexamples to properties we want to validate for our programs.</p>
<p>There's a hitch in how this works that makes it not very effective for testing higher-order functions though: the usual function type <code>a -&gt; b</code> cannot be "shrunk" in a meaningful way, nor can it be printed as a string, which is essential for tracking down why a property fails.</p>
<p>In this module we'll fix this problem by defining an alternative to the <code>a -&gt; b</code> type that <em>can</em> be shrunk and shown. This strategy comes from the paper <a href="https://dl.acm.org/doi/10.1145/2364506.2364516">Shrinking and showing functions</a> by Koen Claessen, which I highly recommend. Notably, this approach is independent of the internals of property testing, and was discovered several years after the original QuickCheck implementation. The key insight is that although an arbitrary function is (unless both the domain and codomain are finite) an infinite object, when a function witnesses a failing property tests it is only <em>applied</em> to finitely many inputs. So for the purpose of the test failure, we only need to consider the restriction of the function to a minimal, finite support.</p>
<p>First we define a helper type of finite functions, which we call <code>To</code>, as a GADT with some "algebraic" function constructors. <code>Tabular</code> defines functions on finite types; <code>Uncurry</code> and <code>Disjoin</code> define functions on product and sum types; and <code>Extend</code> define functions on "subtypes".</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">data</span> <span class="dt">To</span> a b <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="dt">Tabular</span><span class="ot"> ::</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> [(a,c)] <span class="ot">-&gt;</span> <span class="dt">To</span> a c</a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="dt">Trivial</span><span class="ot"> ::</span> c <span class="ot">-&gt;</span> <span class="dt">To</span> () c</a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="dt">Uncurry</span><span class="ot"> ::</span> <span class="dt">To</span> a (<span class="dt">To</span> b c) <span class="ot">-&gt;</span> <span class="dt">To</span> (a,b) c</a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="dt">Disjoin</span><span class="ot"> ::</span> <span class="dt">To</span> a c <span class="ot">-&gt;</span> <span class="dt">To</span> b c <span class="ot">-&gt;</span> <span class="dt">To</span> (<span class="dt">Either</span> a b) c</a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="dt">Extend</span><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">To</span> b c <span class="ot">-&gt;</span> <span class="dt">To</span> a c</a>
<a class="sourceLine" id="cb2-7" title="7"></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">To</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="ot">  fmap ::</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">To</span> a b <span class="ot">-&gt;</span> <span class="dt">To</span> a c</a>
<a class="sourceLine" id="cb2-10" title="10">  <span class="fu">fmap</span> f z <span class="ot">=</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-11" title="11">    <span class="dt">Tabular</span> ps <span class="ot">-&gt;</span> <span class="dt">Tabular</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb2-12" title="12">      <span class="fu">map</span> (\(a, b) <span class="ot">-&gt;</span> (a, f b)) ps</a>
<a class="sourceLine" id="cb2-13" title="13">    <span class="dt">Trivial</span> c <span class="ot">-&gt;</span> <span class="dt">Trivial</span> (f c)</a>
<a class="sourceLine" id="cb2-14" title="14">    <span class="dt">Uncurry</span> q <span class="ot">-&gt;</span> <span class="dt">Uncurry</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb2-15" title="15">      <span class="fu">fmap</span> (<span class="fu">fmap</span> f) q</a>
<a class="sourceLine" id="cb2-16" title="16">    <span class="dt">Disjoin</span> q1 q2 <span class="ot">-&gt;</span> <span class="dt">Disjoin</span></a>
<a class="sourceLine" id="cb2-17" title="17">      (<span class="fu">fmap</span> f q1) (<span class="fu">fmap</span> f q2)</a>
<a class="sourceLine" id="cb2-18" title="18">    <span class="dt">Extend</span> r i q <span class="ot">-&gt;</span> <span class="dt">Extend</span> r i (<span class="fu">fmap</span> f q)</a></code></pre></div>
<p>Every algebraic type we might define can be broken down as a combination of these. Since <code>To</code> is finite, it can be converted to a list of input/output pairs.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">mkTable ::</span> <span class="dt">To</span> a c <span class="ot">-&gt;</span> [(a, c)]</a>
<a class="sourceLine" id="cb3-2" title="2">mkTable z <span class="ot">=</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="dt">Tabular</span> ps <span class="ot">-&gt;</span> ps</a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="dt">Trivial</span> c <span class="ot">-&gt;</span> [((),c)]</a>
<a class="sourceLine" id="cb3-5" title="5">  <span class="dt">Uncurry</span> q1 <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb3-6" title="6">    (x,q2) <span class="ot">&lt;-</span> mkTable q1</a>
<a class="sourceLine" id="cb3-7" title="7">    (y,c) <span class="ot">&lt;-</span> mkTable q2</a>
<a class="sourceLine" id="cb3-8" title="8">    <span class="fu">return</span> ((x,y),c)</a>
<a class="sourceLine" id="cb3-9" title="9">  <span class="dt">Disjoin</span> q1 q2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb3-10" title="10">    [ (<span class="dt">Left</span> x, c) <span class="op">|</span> (x,c) <span class="ot">&lt;-</span> mkTable q1 ] <span class="op">++</span></a>
<a class="sourceLine" id="cb3-11" title="11">    [ (<span class="dt">Right</span> y, c) <span class="op">|</span> (y,c) <span class="ot">&lt;-</span> mkTable q2 ]</a>
<a class="sourceLine" id="cb3-12" title="12">  <span class="dt">Extend</span> _ i q <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb3-13" title="13">    [ (i x, c) <span class="op">|</span> (x,c) <span class="ot">&lt;-</span> mkTable q ]</a></code></pre></div>
<p>Every <code>To</code> can also be converted to a normal function if we specify a default value for inputs outside the support; this is what <code>totalize</code> does.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">totalize ::</span> c <span class="ot">-&gt;</span> <span class="dt">To</span> a c <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb4-2" title="2">totalize w z <span class="ot">=</span> \a <span class="ot">-&gt;</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-3" title="3">  <span class="dt">Tabular</span> ps <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="fu">head</span> <span class="op">$</span> [ c <span class="op">|</span> (x,c) <span class="ot">&lt;-</span> ps, x <span class="op">==</span> a] <span class="op">++</span> [w]</a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="dt">Trivial</span> c <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb4-6" title="6">  <span class="dt">Uncurry</span> q <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-7" title="7">    totalize w (<span class="fu">fmap</span> (\r <span class="ot">-&gt;</span> totalize w r (<span class="fu">snd</span> a)) q) (<span class="fu">fst</span> a)</a>
<a class="sourceLine" id="cb4-8" title="8">  <span class="dt">Disjoin</span> q1 q2 <span class="ot">-&gt;</span> <span class="kw">case</span> a <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="dt">Left</span> u <span class="ot">-&gt;</span> totalize w q1 u</a>
<a class="sourceLine" id="cb4-10" title="10">    <span class="dt">Right</span> v <span class="ot">-&gt;</span> totalize w q2 v</a>
<a class="sourceLine" id="cb4-11" title="11">  <span class="dt">Extend</span> r _ q <span class="ot">-&gt;</span> totalize w q (r a)</a></code></pre></div>
<p>Notably, because <code>To</code> is finite, we can give it a useful <code>Display</code> instance:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb5-2" title="2">  ( <span class="dt">Fmt.Display</span> a, <span class="dt">Fmt.Display</span> b</a>
<a class="sourceLine" id="cb5-3" title="3">  ) <span class="ot">=&gt;</span> <span class="dt">Fmt.Display</span> (<span class="dt">To</span> a b)</a>
<a class="sourceLine" id="cb5-4" title="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-5" title="5">    display q <span class="ot">=</span> displayTo q <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb5-6" title="6"></a>
<a class="sourceLine" id="cb5-7" title="7">displayTo</a>
<a class="sourceLine" id="cb5-8" title="8"><span class="ot">  ::</span> ( <span class="dt">Fmt.Display</span> a, <span class="dt">Fmt.Display</span> b )</a>
<a class="sourceLine" id="cb5-9" title="9">  <span class="ot">=&gt;</span> <span class="dt">To</span> a b <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b <span class="ot">-&gt;</span> <span class="dt">Fmt.Doc</span> u</a>
<a class="sourceLine" id="cb5-10" title="10">displayTo q def <span class="ot">=</span></a>
<a class="sourceLine" id="cb5-11" title="11">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb5-12" title="12">    img (x,c) <span class="ot">=</span></a>
<a class="sourceLine" id="cb5-13" title="13">      display x <span class="op">&lt;+&gt;</span> string <span class="st">&quot;-&gt;&quot;</span> <span class="op">&lt;+&gt;</span> display c</a>
<a class="sourceLine" id="cb5-14" title="14">    rest <span class="ot">=</span> <span class="kw">case</span> def <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-15" title="15">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> string <span class="st">&quot;_ -&gt;&quot;</span> <span class="op">&lt;+&gt;</span> string <span class="st">&quot;undefined&quot;</span></a>
<a class="sourceLine" id="cb5-16" title="16">      <span class="dt">Just</span> w  <span class="ot">-&gt;</span> string <span class="st">&quot;_ -&gt;&quot;</span> <span class="op">&lt;+&gt;</span> display w</a>
<a class="sourceLine" id="cb5-17" title="17">  <span class="kw">in</span> char <span class="ch">&#39;λ&#39;</span> <span class="op">&lt;&gt;</span> Fmt.braceList</a>
<a class="sourceLine" id="cb5-18" title="18">    ( <span class="fu">map</span> img (mkTable q) <span class="op">++</span> [ rest ] )</a></code></pre></div>
<p>We can also give <code>To</code> a meaningful prune instance.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb6-2" title="2">  ( <span class="dt">Prune</span> c</a>
<a class="sourceLine" id="cb6-3" title="3">  ) <span class="ot">=&gt;</span> <span class="dt">Prune</span> (<span class="dt">To</span> a c)</a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-5" title="5">    prune <span class="ot">=</span> pruneTo prune</a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7">pruneTo</a>
<a class="sourceLine" id="cb6-8" title="8"><span class="ot">  ::</span> (c <span class="ot">-&gt;</span> [c]) <span class="ot">-&gt;</span> <span class="dt">To</span> a c <span class="ot">-&gt;</span> [<span class="dt">To</span> a c]</a>
<a class="sourceLine" id="cb6-9" title="9">pruneTo p z <span class="ot">=</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-10" title="10">  <span class="dt">Tabular</span> ps <span class="ot">-&gt;</span> <span class="kw">case</span> ps <span class="kw">of</span></a>
<a class="sourceLine" id="cb6-11" title="11">    [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb6-12" title="12">    _ <span class="ot">-&gt;</span> <span class="fu">map</span> <span class="dt">Tabular</span> <span class="op">$</span> <span class="fu">init</span> <span class="op">$</span> subsequences ps</a>
<a class="sourceLine" id="cb6-13" title="13">  <span class="dt">Trivial</span> c <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-14" title="14">    c&#39; <span class="ot">&lt;-</span> p c</a>
<a class="sourceLine" id="cb6-15" title="15">    <span class="fu">return</span> <span class="op">$</span> <span class="dt">Trivial</span> c&#39;</a>
<a class="sourceLine" id="cb6-16" title="16">  <span class="dt">Uncurry</span> q <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-17" title="17">    <span class="fu">map</span> <span class="dt">Uncurry</span> <span class="op">$</span> pruneTo (pruneTo p) q</a>
<a class="sourceLine" id="cb6-18" title="18">  <span class="dt">Disjoin</span> q1 q2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-19" title="19">    [ <span class="dt">Disjoin</span> q1 r <span class="op">|</span> r <span class="ot">&lt;-</span> pruneTo p q2 ] <span class="op">++</span></a>
<a class="sourceLine" id="cb6-20" title="20">    [ <span class="dt">Disjoin</span> r q2 <span class="op">|</span> r <span class="ot">&lt;-</span> pruneTo p q1 ]</a>
<a class="sourceLine" id="cb6-21" title="21">  <span class="dt">Extend</span> r i q <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb6-22" title="22">    <span class="fu">map</span> (<span class="dt">Extend</span> r i) <span class="op">$</span> pruneTo p q</a></code></pre></div>
<p>Next we define a class, <code>MakeTo</code>. The inhabitants of <code>MakeTo</code> are types <code>a</code> such that functions <em>from</em> <code>a</code> can be turned into <code>To a</code>s.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">class</span> <span class="dt">MakeTo</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ot">  makeTo ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">To</span> a b</a></code></pre></div>
<p>And now, if we can generate arbitrary functions from <code>a</code>, and if arbitrary functions from <code>a</code> can be turned into <code>To a</code>s, then we can generate arbitrary <code>To a</code>s.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb8-2" title="2">  ( <span class="dt">MakeTo</span> a, <span class="dt">CoArb</span> a, <span class="dt">Arb</span> b</a>
<a class="sourceLine" id="cb8-3" title="3">  ) <span class="ot">=&gt;</span> <span class="dt">Arb</span> (<span class="dt">To</span> a b)</a>
<a class="sourceLine" id="cb8-4" title="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-5" title="5">    arb <span class="ot">=</span> <span class="fu">fmap</span> makeTo arb</a></code></pre></div>
</section>
<section class="level2">
<h2>MakeTo Helpers</h2>
<p>It's not necessarily obvious how to implement <code>makeTo</code> for a given type. To help with this we supply some basic helper functions.</p>
<p><code>makeToDisjoin</code> defines <code>To</code>s on <code>Either</code>s:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">makeToDisjoinWith</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="ot">  ::</span> ((a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">To</span> a c)</a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="ot">-&gt;</span> ((b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">To</span> b c)</a>
<a class="sourceLine" id="cb9-4" title="4">  <span class="ot">-&gt;</span> (<span class="dt">Either</span> a b <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb9-5" title="5">  <span class="ot">-&gt;</span> <span class="dt">To</span> (<span class="dt">Either</span> a b) c</a>
<a class="sourceLine" id="cb9-6" title="6">makeToDisjoinWith func1 func2 f <span class="ot">=</span></a>
<a class="sourceLine" id="cb9-7" title="7">  <span class="dt">Disjoin</span> (func1 (f <span class="op">.</span> <span class="dt">Left</span>)) (func2 (f <span class="op">.</span> <span class="dt">Right</span>))</a>
<a class="sourceLine" id="cb9-8" title="8"></a>
<a class="sourceLine" id="cb9-9" title="9">makeToDisjoin</a>
<a class="sourceLine" id="cb9-10" title="10"><span class="ot">  ::</span> ( <span class="dt">MakeTo</span> a, <span class="dt">MakeTo</span> b )</a>
<a class="sourceLine" id="cb9-11" title="11">  <span class="ot">=&gt;</span> (<span class="dt">Either</span> a b <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb9-12" title="12">  <span class="ot">-&gt;</span> <span class="dt">To</span> (<span class="dt">Either</span> a b) c</a>
<a class="sourceLine" id="cb9-13" title="13">makeToDisjoin <span class="ot">=</span></a>
<a class="sourceLine" id="cb9-14" title="14">  makeToDisjoinWith makeTo makeTo</a>
<a class="sourceLine" id="cb9-15" title="15"></a>
<a class="sourceLine" id="cb9-16" title="16"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb9-17" title="17">  ( <span class="dt">MakeTo</span> a, <span class="dt">MakeTo</span> b</a>
<a class="sourceLine" id="cb9-18" title="18">  ) <span class="ot">=&gt;</span> <span class="dt">MakeTo</span> (<span class="dt">Either</span> a b)</a>
<a class="sourceLine" id="cb9-19" title="19">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-20" title="20">    makeTo <span class="ot">=</span> makeToDisjoin</a></code></pre></div>
<p><code>makeToUncurry</code> defines <code>To</code>s on tuples:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">makeToUncurryWith</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="ot">  ::</span> ((a <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> c)) <span class="ot">-&gt;</span> <span class="dt">To</span> a (b <span class="ot">-&gt;</span> c))</a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="ot">-&gt;</span> ((b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">To</span> b c)</a>
<a class="sourceLine" id="cb10-4" title="4">  <span class="ot">-&gt;</span> ((a, b) <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb10-5" title="5">  <span class="ot">-&gt;</span> <span class="dt">To</span> (a,b) c</a>
<a class="sourceLine" id="cb10-6" title="6">makeToUncurryWith func1 func2 f <span class="ot">=</span></a>
<a class="sourceLine" id="cb10-7" title="7">  <span class="dt">Uncurry</span> <span class="op">$</span> <span class="fu">fmap</span> func2 (func1 <span class="op">$</span> <span class="fu">curry</span> f)</a>
<a class="sourceLine" id="cb10-8" title="8"></a>
<a class="sourceLine" id="cb10-9" title="9">makeToUncurry</a>
<a class="sourceLine" id="cb10-10" title="10"><span class="ot">  ::</span> ( <span class="dt">MakeTo</span> a, <span class="dt">MakeTo</span> b )</a>
<a class="sourceLine" id="cb10-11" title="11">  <span class="ot">=&gt;</span> ((a,b) <span class="ot">-&gt;</span> c)</a>
<a class="sourceLine" id="cb10-12" title="12">  <span class="ot">-&gt;</span> <span class="dt">To</span> (a,b) c</a>
<a class="sourceLine" id="cb10-13" title="13">makeToUncurry <span class="ot">=</span></a>
<a class="sourceLine" id="cb10-14" title="14">  makeToUncurryWith makeTo makeTo</a>
<a class="sourceLine" id="cb10-15" title="15"></a>
<a class="sourceLine" id="cb10-16" title="16"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb10-17" title="17">  ( <span class="dt">MakeTo</span> a, <span class="dt">MakeTo</span> b</a>
<a class="sourceLine" id="cb10-18" title="18">  ) <span class="ot">=&gt;</span> <span class="dt">MakeTo</span> (a,b)</a>
<a class="sourceLine" id="cb10-19" title="19">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-20" title="20">    makeTo <span class="ot">=</span> makeToUncurry</a></code></pre></div>
<p>And <code>makeToExtend</code> defines <code>To</code>s when we have (1) a <code>MakeTo</code> instance already and (2) a way to map to and from the existing <code>MakeTo</code> instance.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1">makeToExtendWith</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="ot">  ::</span> ((b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">To</span> b c)</a>
<a class="sourceLine" id="cb11-3" title="3">  <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb11-4" title="4">  <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">To</span> a c</a>
<a class="sourceLine" id="cb11-5" title="5">makeToExtendWith func g h f <span class="ot">=</span></a>
<a class="sourceLine" id="cb11-6" title="6">  <span class="dt">Extend</span> g h <span class="op">$</span> func (f <span class="op">.</span> h)</a>
<a class="sourceLine" id="cb11-7" title="7"></a>
<a class="sourceLine" id="cb11-8" title="8">makeToExtend</a>
<a class="sourceLine" id="cb11-9" title="9"><span class="ot">  ::</span> ( <span class="dt">MakeTo</span> b )</a>
<a class="sourceLine" id="cb11-10" title="10">  <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb11-11" title="11">  <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> <span class="dt">To</span> a c</a>
<a class="sourceLine" id="cb11-12" title="12">makeToExtend <span class="ot">=</span></a>
<a class="sourceLine" id="cb11-13" title="13">  makeToExtendWith makeTo</a></code></pre></div>
<p>With these in hand we can start defining <code>MakeTo</code> instance for the standard library types. Unit is trivial:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">instance</span> <span class="dt">MakeTo</span> () <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-2" title="2">  makeTo f <span class="ot">=</span> <span class="dt">Trivial</span> <span class="op">$</span> f ()</a></code></pre></div>
<p>The isomorphism <code>Maybe a === Either () a</code> gives an instance for <code>Maybe</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb13-2" title="2">  ( <span class="dt">MakeTo</span> a</a>
<a class="sourceLine" id="cb13-3" title="3">  ) <span class="ot">=&gt;</span> <span class="dt">MakeTo</span> (<span class="dt">Maybe</span> a)</a>
<a class="sourceLine" id="cb13-4" title="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-5" title="5">    makeTo <span class="ot">=</span></a>
<a class="sourceLine" id="cb13-6" title="6">      <span class="kw">let</span></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="ot">        f ::</span> <span class="dt">Either</span> () a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb13-8" title="8">        f x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-9" title="9">          <span class="dt">Left</span> () <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb13-10" title="10">          <span class="dt">Right</span> a <span class="ot">-&gt;</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb13-11" title="11"></a>
<a class="sourceLine" id="cb13-12" title="12"><span class="ot">        g ::</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Either</span> () a</a>
<a class="sourceLine" id="cb13-13" title="13">        g x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-14" title="14">          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Left</span> ()</a>
<a class="sourceLine" id="cb13-15" title="15">          <span class="dt">Just</span> a <span class="ot">-&gt;</span> <span class="dt">Right</span> a</a>
<a class="sourceLine" id="cb13-16" title="16">      <span class="kw">in</span> makeToExtend g f</a></code></pre></div>
<p>The associators on tuple types give instances for tuples with any number of entries:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb14-2" title="2">  ( <span class="dt">MakeTo</span> a1, <span class="dt">MakeTo</span> a2, <span class="dt">MakeTo</span> a3</a>
<a class="sourceLine" id="cb14-3" title="3">  ) <span class="ot">=&gt;</span> <span class="dt">MakeTo</span> (a1, a2, a3)</a>
<a class="sourceLine" id="cb14-4" title="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-5" title="5">    makeTo <span class="ot">=</span></a>
<a class="sourceLine" id="cb14-6" title="6">      <span class="kw">let</span></a>
<a class="sourceLine" id="cb14-7" title="7"><span class="ot">        f ::</span> (a1,(a2,a3)) <span class="ot">-&gt;</span> (a1,a2,a3)</a>
<a class="sourceLine" id="cb14-8" title="8">        f (a1,(a2,a3)) <span class="ot">=</span> (a1,a2,a3)</a>
<a class="sourceLine" id="cb14-9" title="9"></a>
<a class="sourceLine" id="cb14-10" title="10"><span class="ot">        g ::</span> (a1,a2,a3) <span class="ot">-&gt;</span> (a1,(a2,a3))</a>
<a class="sourceLine" id="cb14-11" title="11">        g (a1,a2,a3) <span class="ot">=</span> (a1,(a2,a3))</a>
<a class="sourceLine" id="cb14-12" title="12">      <span class="kw">in</span> makeToExtend g f</a>
<a class="sourceLine" id="cb14-13" title="13"></a>
<a class="sourceLine" id="cb14-14" title="14"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb14-15" title="15">  ( <span class="dt">MakeTo</span> a1, <span class="dt">MakeTo</span> a2, <span class="dt">MakeTo</span> a3, <span class="dt">MakeTo</span> a4</a>
<a class="sourceLine" id="cb14-16" title="16">  ) <span class="ot">=&gt;</span> <span class="dt">MakeTo</span> (a1, a2, a3, a4)</a>
<a class="sourceLine" id="cb14-17" title="17">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-18" title="18">    makeTo <span class="ot">=</span></a>
<a class="sourceLine" id="cb14-19" title="19">      <span class="kw">let</span></a>
<a class="sourceLine" id="cb14-20" title="20"><span class="ot">        f ::</span> (a1,(a2,a3,a4)) <span class="ot">-&gt;</span> (a1,a2,a3,a4)</a>
<a class="sourceLine" id="cb14-21" title="21">        f (a1,(a2,a3,a4)) <span class="ot">=</span> (a1,a2,a3,a4)</a>
<a class="sourceLine" id="cb14-22" title="22"></a>
<a class="sourceLine" id="cb14-23" title="23"><span class="ot">        g ::</span> (a1,a2,a3,a4) <span class="ot">-&gt;</span> (a1,(a2,a3,a4))</a>
<a class="sourceLine" id="cb14-24" title="24">        g (a1,a2,a3,a4) <span class="ot">=</span> (a1,(a2,a3,a4))</a>
<a class="sourceLine" id="cb14-25" title="25">      <span class="kw">in</span> makeToExtend g f</a>
<a class="sourceLine" id="cb14-26" title="26"></a>
<a class="sourceLine" id="cb14-27" title="27"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb14-28" title="28">  ( <span class="dt">MakeTo</span> a1, <span class="dt">MakeTo</span> a2, <span class="dt">MakeTo</span> a3, <span class="dt">MakeTo</span> a4, <span class="dt">MakeTo</span> a5</a>
<a class="sourceLine" id="cb14-29" title="29">  ) <span class="ot">=&gt;</span> <span class="dt">MakeTo</span> (a1, a2, a3, a4, a5)</a>
<a class="sourceLine" id="cb14-30" title="30">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-31" title="31">    makeTo <span class="ot">=</span></a>
<a class="sourceLine" id="cb14-32" title="32">      <span class="kw">let</span></a>
<a class="sourceLine" id="cb14-33" title="33"><span class="ot">        f ::</span> (a1,(a2,a3,a4,a5)) <span class="ot">-&gt;</span> (a1,a2,a3,a4,a5)</a>
<a class="sourceLine" id="cb14-34" title="34">        f (a1,(a2,a3,a4,a5)) <span class="ot">=</span> (a1,a2,a3,a4,a5)</a>
<a class="sourceLine" id="cb14-35" title="35"></a>
<a class="sourceLine" id="cb14-36" title="36"><span class="ot">        g ::</span> (a1,a2,a3,a4,a5) <span class="ot">-&gt;</span> (a1,(a2,a3,a4,a5))</a>
<a class="sourceLine" id="cb14-37" title="37">        g (a1,a2,a3,a4,a5) <span class="ot">=</span> (a1,(a2,a3,a4,a5))</a>
<a class="sourceLine" id="cb14-38" title="38">      <span class="kw">in</span> makeToExtend g f</a></code></pre></div>
<p>Small finite types are easy enough with <code>Tabular</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">instance</span> <span class="dt">MakeTo</span> <span class="dt">Bool</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" title="2">  makeTo f <span class="ot">=</span> <span class="dt">Tabular</span></a>
<a class="sourceLine" id="cb15-3" title="3">    [ (<span class="dt">True</span>,  f <span class="dt">True</span>)</a>
<a class="sourceLine" id="cb15-4" title="4">    , (<span class="dt">False</span>, f <span class="dt">False</span>)</a>
<a class="sourceLine" id="cb15-5" title="5">    ]</a>
<a class="sourceLine" id="cb15-6" title="6"></a>
<a class="sourceLine" id="cb15-7" title="7"><span class="kw">instance</span> <span class="dt">MakeTo</span> <span class="dt">Word8</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-8" title="8">  makeTo f <span class="ot">=</span> <span class="dt">Tabular</span></a>
<a class="sourceLine" id="cb15-9" title="9">    [ (x, f x) <span class="op">|</span> x <span class="ot">&lt;-</span> [<span class="fu">minBound</span>, <span class="fu">maxBound</span>] ]</a></code></pre></div>
<p>The isomorphism <code>[a] === Either () (a, [a])</code> gives a (recursive!) instance for lists:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb16-2" title="2">  ( <span class="dt">MakeTo</span> a</a>
<a class="sourceLine" id="cb16-3" title="3">  ) <span class="ot">=&gt;</span> <span class="dt">MakeTo</span> [a]</a>
<a class="sourceLine" id="cb16-4" title="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-5" title="5">    makeTo <span class="ot">=</span> makeToExtend g h</a>
<a class="sourceLine" id="cb16-6" title="6">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-7" title="7">        <span class="co">-- uncons</span></a>
<a class="sourceLine" id="cb16-8" title="8"><span class="ot">        g ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Either</span> () (a, [a])</a>
<a class="sourceLine" id="cb16-9" title="9">        g z <span class="ot">=</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-10" title="10">          [] <span class="ot">-&gt;</span> <span class="dt">Left</span> ()</a>
<a class="sourceLine" id="cb16-11" title="11">          x<span class="op">:</span>xs <span class="ot">-&gt;</span> <span class="dt">Right</span> (x,xs)</a>
<a class="sourceLine" id="cb16-12" title="12"></a>
<a class="sourceLine" id="cb16-13" title="13">        <span class="co">-- cons</span></a>
<a class="sourceLine" id="cb16-14" title="14"><span class="ot">        h ::</span> <span class="dt">Either</span> () (a, [a]) <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb16-15" title="15">        h z <span class="ot">=</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-16" title="16">          <span class="dt">Left</span> () <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb16-17" title="17">          <span class="dt">Right</span> (x,xs) <span class="ot">-&gt;</span> x<span class="op">:</span>xs</a></code></pre></div>
<p>The isomorphism <code>Integer === [Word]</code> taking an integer to its base 256 representation gives an instance for <code>Integer</code>:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">instance</span> <span class="dt">MakeTo</span> <span class="dt">Integer</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-2" title="2">  makeTo <span class="ot">=</span> makeToExtend g h</a>
<a class="sourceLine" id="cb17-3" title="3">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-4" title="4">      <span class="co">-- to signed digits</span></a>
<a class="sourceLine" id="cb17-5" title="5"><span class="ot">      g ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Either</span> [<span class="dt">Word8</span>] [<span class="dt">Word8</span>]</a>
<a class="sourceLine" id="cb17-6" title="6">      g n <span class="ot">=</span> <span class="kw">if</span> n <span class="op">&lt;</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb17-7" title="7">        <span class="kw">then</span> <span class="dt">Left</span> <span class="op">$</span> gNat ((<span class="fu">abs</span> n) <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb17-8" title="8">        <span class="kw">else</span> <span class="dt">Right</span> <span class="op">$</span> gNat n</a>
<a class="sourceLine" id="cb17-9" title="9"></a>
<a class="sourceLine" id="cb17-10" title="10">      <span class="co">-- from signed digits</span></a>
<a class="sourceLine" id="cb17-11" title="11"><span class="ot">      h ::</span> <span class="dt">Either</span> [<span class="dt">Word8</span>] [<span class="dt">Word8</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb17-12" title="12">      h z <span class="ot">=</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-13" title="13">        <span class="dt">Left</span> ws <span class="ot">-&gt;</span> <span class="fu">negate</span> (<span class="dv">1</span> <span class="op">+</span> hNat ws)</a>
<a class="sourceLine" id="cb17-14" title="14">        <span class="dt">Right</span> ws <span class="ot">-&gt;</span> hNat ws </a>
<a class="sourceLine" id="cb17-15" title="15"></a>
<a class="sourceLine" id="cb17-16" title="16">      <span class="co">-- to digits</span></a>
<a class="sourceLine" id="cb17-17" title="17"><span class="ot">      gNat ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> [<span class="dt">Word8</span>]</a>
<a class="sourceLine" id="cb17-18" title="18">      gNat n <span class="ot">=</span> <span class="kw">if</span> n <span class="op">&lt;=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb17-19" title="19">        <span class="kw">then</span> []</a>
<a class="sourceLine" id="cb17-20" title="20">        <span class="kw">else</span> <span class="kw">let</span> (q,r) <span class="ot">=</span> <span class="fu">quotRem</span> n <span class="dv">258</span> <span class="kw">in</span></a>
<a class="sourceLine" id="cb17-21" title="21">          (<span class="fu">fromIntegral</span><span class="ot"> r ::</span> <span class="dt">Word8</span>) <span class="op">:</span> gNat q</a>
<a class="sourceLine" id="cb17-22" title="22"></a>
<a class="sourceLine" id="cb17-23" title="23">      <span class="co">-- from digits</span></a>
<a class="sourceLine" id="cb17-24" title="24"><span class="ot">      hNat ::</span> [<span class="dt">Word8</span>] <span class="ot">-&gt;</span> <span class="dt">Integer</span></a>
<a class="sourceLine" id="cb17-25" title="25">      hNat z <span class="ot">=</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-26" title="26">        [] <span class="ot">-&gt;</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb17-27" title="27">        x<span class="op">:</span>xs <span class="ot">-&gt;</span> (<span class="fu">fromIntegral</span> x) <span class="op">+</span> <span class="dv">256</span> <span class="op">*</span> (hNat xs)</a></code></pre></div>
<p>Now plenty of types can be mapped to and from <code>Integer</code>, and we can give a helper for defining <code>makeTo</code> on these.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1">makeToIntegralWith</a>
<a class="sourceLine" id="cb18-2" title="2"><span class="ot">  ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb18-3" title="3">  <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">To</span> a b</a>
<a class="sourceLine" id="cb18-4" title="4">makeToIntegralWith g h <span class="ot">=</span></a>
<a class="sourceLine" id="cb18-5" title="5">  makeToExtend g h</a>
<a class="sourceLine" id="cb18-6" title="6"></a>
<a class="sourceLine" id="cb18-7" title="7">makeToIntegral</a>
<a class="sourceLine" id="cb18-8" title="8"><span class="ot">  ::</span> ( <span class="dt">Num</span> a, <span class="dt">Integral</span> a )</a>
<a class="sourceLine" id="cb18-9" title="9">  <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">To</span> a b</a>
<a class="sourceLine" id="cb18-10" title="10">makeToIntegral <span class="ot">=</span></a>
<a class="sourceLine" id="cb18-11" title="11">  makeToIntegralWith <span class="fu">fromIntegral</span> <span class="fu">fromInteger</span></a>
<a class="sourceLine" id="cb18-12" title="12"></a>
<a class="sourceLine" id="cb18-13" title="13"><span class="kw">instance</span> <span class="dt">MakeTo</span> <span class="dt">Int</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-14" title="14">  makeTo <span class="ot">=</span> makeToIntegral</a>
<a class="sourceLine" id="cb18-15" title="15"></a>
<a class="sourceLine" id="cb18-16" title="16"><span class="kw">instance</span> <span class="dt">MakeTo</span> <span class="dt">Char</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-17" title="17">  makeTo <span class="ot">=</span> makeToExtend <span class="fu">ord</span> <span class="fu">chr</span></a></code></pre></div>
</section>
<section class="level2">
<h2>An Alternative Function Type</h2>
<p>We're nearly done with the API for shrinkable functions. To wrap up, we need a type to track a (possibly pruned) <code>To</code>, along with an equivalent "normal" function.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">data</span> <span class="dt">Fun</span> a b</a>
<a class="sourceLine" id="cb19-2" title="2">  <span class="ot">=</span> <span class="dt">Fun</span> (<span class="dt">To</span> a b) b <span class="dt">Pruned</span> (a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb19-3" title="3"></a>
<a class="sourceLine" id="cb19-4" title="4"><span class="kw">data</span> <span class="dt">Pruned</span></a>
<a class="sourceLine" id="cb19-5" title="5">  <span class="ot">=</span> <span class="dt">Pruned</span> <span class="op">|</span> <span class="dt">NotPruned</span></a>
<a class="sourceLine" id="cb19-6" title="6">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a>
<a class="sourceLine" id="cb19-7" title="7"></a>
<a class="sourceLine" id="cb19-8" title="8"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Fun</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb19-9" title="9">  <span class="fu">fmap</span> f (<span class="dt">Fun</span> part def p tot) <span class="ot">=</span></a>
<a class="sourceLine" id="cb19-10" title="10">    <span class="dt">Fun</span> (<span class="fu">fmap</span> f part) (f def) p (f <span class="op">.</span> tot)</a>
<a class="sourceLine" id="cb19-11" title="11"></a>
<a class="sourceLine" id="cb19-12" title="12"><span class="ot">mkFun ::</span> <span class="dt">To</span> a b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Fun</span> a b</a>
<a class="sourceLine" id="cb19-13" title="13">mkFun part def <span class="ot">=</span></a>
<a class="sourceLine" id="cb19-14" title="14">  <span class="dt">Fun</span> part def <span class="dt">NotPruned</span> (totalize def part)</a></code></pre></div>
<p>Now <code>Fun</code> can be displayed, generated, and pruned:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb20-2" title="2">  ( <span class="dt">Fmt.Display</span> a, <span class="dt">Fmt.Display</span> b</a>
<a class="sourceLine" id="cb20-3" title="3">  ) <span class="ot">=&gt;</span> <span class="dt">Fmt.Display</span> (<span class="dt">Fun</span> a b)</a>
<a class="sourceLine" id="cb20-4" title="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-5" title="5">    display (<span class="dt">Fun</span> part def p _) <span class="ot">=</span></a>
<a class="sourceLine" id="cb20-6" title="6">      <span class="kw">case</span> p <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-7" title="7">        <span class="dt">NotPruned</span> <span class="ot">-&gt;</span> string <span class="st">&quot;&lt;func&gt;&quot;</span></a>
<a class="sourceLine" id="cb20-8" title="8">        <span class="dt">Pruned</span>    <span class="ot">-&gt;</span> displayTo part (<span class="dt">Just</span> def)</a>
<a class="sourceLine" id="cb20-9" title="9"></a>
<a class="sourceLine" id="cb20-10" title="10"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb20-11" title="11">  ( <span class="dt">MakeTo</span> a, <span class="dt">CoArb</span> a, <span class="dt">Arb</span> b</a>
<a class="sourceLine" id="cb20-12" title="12">  ) <span class="ot">=&gt;</span> <span class="dt">Arb</span> (<span class="dt">Fun</span> a b)</a>
<a class="sourceLine" id="cb20-13" title="13">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-14" title="14">    arb <span class="ot">=</span> mkFun <span class="op">&lt;$&gt;</span> arb <span class="op">&lt;*&gt;</span> arb</a>
<a class="sourceLine" id="cb20-15" title="15"></a>
<a class="sourceLine" id="cb20-16" title="16"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb20-17" title="17">  ( <span class="dt">MakeTo</span> a, <span class="dt">CoArb</span> a, <span class="dt">Arb</span> b, <span class="dt">Prune</span> a, <span class="dt">Prune</span> b</a>
<a class="sourceLine" id="cb20-18" title="18">  ) <span class="ot">=&gt;</span> <span class="dt">Prune</span> (<span class="dt">Fun</span> a b)</a>
<a class="sourceLine" id="cb20-19" title="19">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-20" title="20">    prune (<span class="dt">Fun</span> part def p tot) <span class="ot">=</span> <span class="fu">concat</span></a>
<a class="sourceLine" id="cb20-21" title="21">      [ [ mkFun p&#39; d&#39; <span class="op">|</span> (p&#39;, d&#39;) <span class="ot">&lt;-</span> prune (part, def) ]</a>
<a class="sourceLine" id="cb20-22" title="22">      , <span class="kw">if</span> p <span class="op">==</span> <span class="dt">Pruned</span></a>
<a class="sourceLine" id="cb20-23" title="23">          <span class="kw">then</span> []</a>
<a class="sourceLine" id="cb20-24" title="24">          <span class="kw">else</span> [ <span class="dt">Fun</span> part def <span class="dt">Pruned</span> tot ]</a>
<a class="sourceLine" id="cb20-25" title="25">      ]</a></code></pre></div>
<p>And that's it. Anytime we want to use a function as an arbitrary parameter in a property test, we can use the <code>Fun</code> type instead, and get nicely pruned and displayed results. The only other necessary adjustment is that we have to explicitly turn the <code>Fun</code> into a "normal" function for use inside the property. The <code>apFun*</code> helpers do this.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1">apFun, (<span class="op">@@</span>)</a>
<a class="sourceLine" id="cb21-2" title="2"><span class="ot">  ::</span> <span class="dt">Fun</span> a b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb21-3" title="3">apFun (<span class="dt">Fun</span> _ _ _ f) <span class="ot">=</span> f</a>
<a class="sourceLine" id="cb21-4" title="4">(<span class="op">@@</span>) <span class="ot">=</span> apFun</a>
<a class="sourceLine" id="cb21-5" title="5"></a>
<a class="sourceLine" id="cb21-6" title="6">apFun2</a>
<a class="sourceLine" id="cb21-7" title="7"><span class="ot">  ::</span> <span class="dt">Fun</span> (a,b) c <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c</a>
<a class="sourceLine" id="cb21-8" title="8">apFun2 (<span class="dt">Fun</span> _ _ _ f) a b <span class="ot">=</span> f (a, b)</a>
<a class="sourceLine" id="cb21-9" title="9"></a>
<a class="sourceLine" id="cb21-10" title="10">apFun3</a>
<a class="sourceLine" id="cb21-11" title="11"><span class="ot">  ::</span> <span class="dt">Fun</span> (a,b,c) d <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> c <span class="ot">-&gt;</span> d</a>
<a class="sourceLine" id="cb21-12" title="12">apFun3 (<span class="dt">Fun</span> _ _ _ f) a b c <span class="ot">=</span> f (a,b,c)</a></code></pre></div>
</section>
</article>
</body>
</html>
