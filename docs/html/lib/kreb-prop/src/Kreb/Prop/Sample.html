<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="nbloomf">
  <title>Pseudorandom Data</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="../../../../../../styles/style.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" type="text/javascript"></script>
  <script>
    window.MathJax = {
      tex: {
        macros: {
          dom: "\\mathsf{dom}",
          cod: "\\mathsf{cod}",
          id:  "\\mathsf{id}",
          Hask: "\\mathsf{Hask}",
        }
      }
    };
  </script
</head>
<body>
<article>
<header>
<h1 class="title">Pseudorandom Data</h1>
<p class="byline">nbloomf</p>
</header>
<div class="frontmatter">
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">module</span> <span class="dt">Kreb.Prop.Sample</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="kw">import</span> <span class="dt">Control.Monad</span> (ap)</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="kw">import</span> <span class="dt">System.Random</span> <span class="kw">hiding</span> (next)</a>
<a class="sourceLine" id="cb1-5" title="5"><span class="kw">import</span> <span class="dt">Data.Bits</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="kw">import</span> <span class="dt">Data.Char</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="kw">import</span> <span class="dt">Kreb.Control</span></a></code></pre></div>
</div>
<section class="level2">
<h2>Introduction</h2>
<p>Unit testing allows us to automatically check code for regressions against expected behavior by, in a nutshell, specifying a list of expected inputs and outputs for a given function. (Hair-splitting over whether this is a <em>unit</em> test or an <em>integration</em> test boil down to how many subsystems the function in question touches, how much control we have over them, and what possible side effects it has.) Unit testing is a powerful tool for validating the quality and correctness of our programs, but it does have weaknesses.</p>
<p>As a trivial example suppose we want to validate the <em>square</em> function, which takes an <code>Int</code> and squares it:</p>
<div class="example">
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">square ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb2-2" title="2">square n <span class="ot">=</span> n <span class="op">^</span> <span class="dv">2</span></a></code></pre></div>
</div>
<p>Suppose we have a unit test checking that <code>square</code> behaves as expected for some input/output pairs:</p>
<div class="example">
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">cases ::</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]</a>
<a class="sourceLine" id="cb3-2" title="2">cases <span class="ot">=</span> [(<span class="dv">0</span>,<span class="dv">0</span>),(<span class="dv">1</span>,<span class="dv">1</span>),(<span class="dv">2</span>,<span class="dv">4</span>),(<span class="op">-</span><span class="dv">1</span>,<span class="dv">1</span>)]</a></code></pre></div>
</div>
<p>The tests pass, and all is well. Unfortunately, while this test can certainly tell us that our <code>square</code> implementation is <em>wrong</em>, it doesn't give much confidence that it's <em>right</em>. For example, this implementation passes the same unit test:</p>
<div class="example">
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">badsquare ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-2" title="2">badsquare n <span class="ot">=</span> <span class="kw">if</span> <span class="op">-</span><span class="dv">1</span> <span class="op">&lt;=</span> n <span class="op">&amp;&amp;</span> n <span class="op">&lt;=</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb4-3" title="3">  <span class="kw">then</span> n <span class="op">^</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb4-4" title="4">  <span class="kw">else</span> <span class="dv">27</span></a></code></pre></div>
</div>
<p>Now- would anyone actually write that implementation for <code>square</code>? Certianly not, unless they were specifically attacking a testing methodology. :) But <code>square</code> is as simple as functions get, and it's not difficult to design more complex functions that end up having some not-so-obviously bad behavior that our unit tests, which are by definition the test cases we could think of, don't catch.</p>
<p>This discussion of <code>square</code> and its correctness is a little sloppy, though. I've referred to the implementation as being either <em>wrong</em> or <em>right</em>, but these words are meaningless on their own. It's better to say that a function either does or does not conform to a particular <em>specification</em>. We have an intuitive expectation of what the specification for <code>square</code> should be: something like</p>
<ul>
<li>For any <code>Int</code>, say <code>n</code>, we have <code>square n == n*n</code>.</li>
</ul>
<p>But this is not explicit until we make it explicit. And now we can see why unit tests can't possibly give us strong guarantees about the correctness of <code>square</code>: the specification has a universal quantifier (<em>for any</em>) but the unit test can only ever check finitely many examples.</p>
<p>What we really want is to check the implementation against the specification, not just some specific examples. This is called <em>property testing</em>, and this approach to testing was, as far as I know, pioneered by the <code>QuickCheck</code> library.</p>
<p>The broad strategy for property testing goes like this:</p>
<ol>
<li>Given some implementation code decide on a specification it should satisfy, expressed as one or more universally quantified boolean-valued functions. (for all <span class="math inline">\(a\)</span>, <span class="math inline">\(p(a)\)</span> is true.)</li>
<li>Generate a bunch of random <span class="math inline">\(a\)</span>s.</li>
<li>Evaluate the <span class="math inline">\(p(a)\)</span>s, looking for any that violate the specification.</li>
</ol>
<p>The received wisdom about randomness in test code is "don't do it", so you may feel slightly uncomfortable at step 2. The idea is that random test failures are hard to replicate and it's difficult to separate "real" failures from "unlucky rng" failures. But in practice this isn't a problem. Moreover, property testing can be devastatingly effective at both finding bugs in our implementation and uncovering hidden assumptions in our specification, drastically improving confidence that the code (and any changes we make to it) really are <em>correct</em>.</p>
<p>In this library we'll build a little clone of Haskell's <code>QuickCheck</code> framework for property testing. We're working from the classic QuickCheck papers, as well as the (permissively licensed) <a href="https://hackage.haskell.org/package/QuickCheck">implementation</a>.</p>
</section>
<section class="level2">
<h2>A Pseudorandom Monad</h2>
<p>For starters we need a way to generate pseudorandom values. One way to do this is to assume we have access to an indefinite stream of pseudorandom numbers to use as an entropy source -- our <code>StreamT</code> monad transformer can do this, with the standard library <code>StdGen</code> type acting as the stream. For practical reasons it will also be useful to carry a read-only integer "size" we can use to tweak the randomness.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">type</span> <span class="dt">Sample</span> a <span class="ot">=</span> <span class="dt">EnvT</span> <span class="dt">Size</span> (<span class="dt">StreamT</span> <span class="dt">StdGen</span> <span class="dt">Identity</span>) a</a>
<a class="sourceLine" id="cb5-2" title="2"></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">type</span> <span class="dt">Size</span> <span class="ot">=</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="kw">instance</span> <span class="dt">IsStream</span> <span class="dt">StdGen</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="kw">data</span> <span class="dt">StreamValue</span> <span class="dt">StdGen</span> <span class="ot">=</span> <span class="dt">G</span> <span class="dt">StdGen</span></a>
<a class="sourceLine" id="cb5-7" title="7"></a>
<a class="sourceLine" id="cb5-8" title="8">  advance x <span class="ot">=</span></a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="kw">let</span> (a, z) <span class="ot">=</span> split x</a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="kw">in</span> (<span class="dt">G</span> a, z)</a></code></pre></div>
<p>To run a <code>Sample</code> computation, we supply it with an initial size and stream:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">runSample</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="ot">  ::</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb6-3" title="3">runSample gen size <span class="ot">=</span></a>
<a class="sourceLine" id="cb6-4" title="4">  unIdentity <span class="op">.</span> runStreamT gen <span class="op">.</span> runEnvT size</a></code></pre></div>
<p>We also define some aliases for the standard <code>EnvT</code> functions. <code>size</code> gets the size parameter, while <code>withSize</code> and <code>adjustSize</code> let us run a computation with a new or altered size, respectively.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1">size</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ot">  ::</span> <span class="dt">Sample</span> <span class="dt">Size</span></a>
<a class="sourceLine" id="cb7-3" title="3">size <span class="ot">=</span> ask</a>
<a class="sourceLine" id="cb7-4" title="4"></a>
<a class="sourceLine" id="cb7-5" title="5">withSize</a>
<a class="sourceLine" id="cb7-6" title="6"><span class="ot">  ::</span> <span class="dt">Size</span> <span class="ot">-&gt;</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> <span class="dt">Sample</span> a</a>
<a class="sourceLine" id="cb7-7" title="7">withSize k <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-8" title="8">  local (\_ <span class="ot">-&gt;</span> k)</a>
<a class="sourceLine" id="cb7-9" title="9"></a>
<a class="sourceLine" id="cb7-10" title="10">adjustSize</a>
<a class="sourceLine" id="cb7-11" title="11"><span class="ot">  ::</span> (<span class="dt">Size</span> <span class="ot">-&gt;</span> <span class="dt">Size</span>) <span class="ot">-&gt;</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> <span class="dt">Sample</span> a</a>
<a class="sourceLine" id="cb7-12" title="12">adjustSize f <span class="ot">=</span></a>
<a class="sourceLine" id="cb7-13" title="13">  local (\k <span class="ot">-&gt;</span> f k)</a></code></pre></div>
<p>We will also need a function with this odd signature later on:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1">promoteSample</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ot">  ::</span> <span class="kw">forall</span> a b</a>
<a class="sourceLine" id="cb8-3" title="3">   <span class="op">.</span> (a <span class="ot">-&gt;</span> <span class="dt">Sample</span> b) <span class="ot">-&gt;</span> <span class="dt">Sample</span> (a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb8-4" title="4">promoteSample f <span class="ot">=</span> <span class="dt">EnvT</span> <span class="op">$</span> \r <span class="ot">-&gt;</span> <span class="dt">StreamT</span> <span class="op">$</span> \s <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-5" title="5">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="ot">    g ::</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb8-7" title="7">    g a <span class="ot">=</span> unIdentity <span class="op">$</span> runStreamT s <span class="op">$</span> runEnvT r (f a)</a>
<a class="sourceLine" id="cb8-8" title="8">  <span class="kw">in</span> <span class="dt">Identity</span> (g, s)</a></code></pre></div>
<p>(We'll use <code>promoteSample</code> to generate arbitrary functions.) Next, we'll leverage the standard library <code>Random</code> class to generate <code>Sample</code> values for some basic types.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">randIn</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="ot">  ::</span> ( <span class="dt">Random</span> a )</a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="ot">=&gt;</span> (a,a) <span class="ot">-&gt;</span> <span class="dt">Sample</span> a</a>
<a class="sourceLine" id="cb9-4" title="4">randIn bds <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-5" title="5">  <span class="dt">G</span> gen <span class="ot">&lt;-</span> next <span class="op">@</span><span class="dt">StdGen</span></a>
<a class="sourceLine" id="cb9-6" title="6">  <span class="fu">return</span> <span class="op">$</span> <span class="fu">fst</span> <span class="op">$</span> randomR bds gen</a>
<a class="sourceLine" id="cb9-7" title="7"></a>
<a class="sourceLine" id="cb9-8" title="8">rand</a>
<a class="sourceLine" id="cb9-9" title="9"><span class="ot">  ::</span> ( <span class="dt">Random</span> a )</a>
<a class="sourceLine" id="cb9-10" title="10">  <span class="ot">=&gt;</span> <span class="dt">Sample</span> a</a>
<a class="sourceLine" id="cb9-11" title="11">rand <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb9-12" title="12">  <span class="dt">G</span> gen <span class="ot">&lt;-</span> next <span class="op">@</span><span class="dt">StdGen</span></a>
<a class="sourceLine" id="cb9-13" title="13">  <span class="fu">return</span> <span class="op">$</span> <span class="fu">fst</span> <span class="op">$</span> random gen</a></code></pre></div>
<p>And that's it for the basic API of <code>Sample</code>; we get most of it for free by virtue of it being a monad stack. Note how the <code>next</code> method for stack monads handles advancing the state of the random number generator.</p>
<p>Baking examples of this code into doctests is awkward, because it will give different results on every run. But we can try anyway.</p>
<div class="doctest">
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="co">--   let</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="co">--     gen = mkStdGen 27</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="co">--     k = runSample gen 5 $ randIn (1 :: Int, 10)</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="co">--   in elem k [1..10]</span></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="co">-- True</span></a></code></pre></div>
</div>
</section>
<section class="level2">
<h2>Sample Combinators</h2>
<p>A <code>Sample a</code> is a computation which, when run, returns an <code>a</code> drawn from some probability distribution. With <code>randIn</code> and <code>rand</code> in hand we can generate sample values of any type that implements the standard <code>Random</code> class, which is basically all the built in integer-like types.</p>
<p>First let's define a basic function to draw values from a <code>Sample a</code> -- this is just for testing.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1">draw</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="ot">  ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> [a]</a>
<a class="sourceLine" id="cb11-3" title="3">draw k seeded <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-4" title="4">  gen <span class="ot">&lt;-</span> newStdGen</a>
<a class="sourceLine" id="cb11-5" title="5">  <span class="fu">return</span> <span class="op">$</span> runSample gen <span class="dv">0</span> <span class="op">$</span></a>
<a class="sourceLine" id="cb11-6" title="6">    <span class="fu">sequence</span> <span class="op">$</span> <span class="fu">map</span> (\m <span class="ot">-&gt;</span> withSize m seeded) <span class="op">$</span></a>
<a class="sourceLine" id="cb11-7" title="7">    <span class="fu">map</span> (<span class="dv">2</span><span class="op">*</span>) [<span class="dv">0</span><span class="op">..</span>(k<span class="op">-</span><span class="dv">1</span>)]</a></code></pre></div>
<p><code>vectOf</code> generates a list with a given length.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">vectOf ::</span> (<span class="dt">Integral</span> n) <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> <span class="dt">Sample</span> [a]</a>
<a class="sourceLine" id="cb12-2" title="2">vectOf n gen <span class="ot">=</span></a>
<a class="sourceLine" id="cb12-3" title="3">  <span class="kw">let</span> k <span class="ot">=</span> <span class="fu">fromIntegral</span> <span class="op">$</span> <span class="fu">toInteger</span> n</a>
<a class="sourceLine" id="cb12-4" title="4">  <span class="kw">in</span> <span class="kw">if</span> k <span class="op">&lt;=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-5" title="5">    <span class="kw">then</span> <span class="fu">pure</span> []</a>
<a class="sourceLine" id="cb12-6" title="6">    <span class="kw">else</span> <span class="fu">sequence</span> <span class="op">$</span> <span class="fu">replicate</span> k <span class="op">$</span> adjustSize (<span class="ot">`div`</span> k) <span class="op">$</span> gen</a></code></pre></div>
<p>There are lots of different ways to generate lists of unspecified length, and which is most appropriate depends on the context. All of them amount to (1) choosing what the length of the list should be, and then (2) choosing how to adjust the size parameter when generating list items. We'll define a generic combinator, <code>listBy</code>, bundling up this pattern. It takes two function parameters, <code>f</code> and <code>g</code>, and generates a list of length <code>f k</code> where <code>k</code> is between 0 and the size parameter, and the size parameter when generating list items is set to <code>g size (f k)</code>. Different choices of <code>f</code> and <code>g</code> will result in different distributions of lists. The boolean parameter lets us signal whether the list can be empty or not.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1">listBy</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="ot">  ::</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb13-4" title="4">  <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb13-5" title="5">  <span class="ot">-&gt;</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> <span class="dt">Sample</span> [a]</a>
<a class="sourceLine" id="cb13-6" title="6">listBy nonEmpty f g gen <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-7" title="7">  z <span class="ot">&lt;-</span> size</a>
<a class="sourceLine" id="cb13-8" title="8">  k <span class="ot">&lt;-</span> randIn (z <span class="ot">`div`</span> <span class="dv">3</span>, z)</a>
<a class="sourceLine" id="cb13-9" title="9">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb13-10" title="10">    len <span class="ot">=</span> <span class="fu">max</span> <span class="dv">0</span> (f k) <span class="op">+</span></a>
<a class="sourceLine" id="cb13-11" title="11">      <span class="kw">if</span> nonEmpty <span class="kw">then</span> <span class="dv">1</span> <span class="kw">else</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb13-12" title="12">  vectOf len <span class="op">$</span> withSize (g z len) gen</a></code></pre></div>
<p><code>listOf</code> bounds the list length by the base 2 log of the <code>size</code> parameter, and does not adjust the size parameter when generating the list items. Used carelessly (especially on nested structures) it can easily generate enormous data. <code>listOf1</code> is a variant that never generates the empty list.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">listOf ::</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> <span class="dt">Sample</span> [a]</a>
<a class="sourceLine" id="cb14-2" title="2">listOf <span class="ot">=</span> listBy <span class="dt">False</span> ilog2 (\z _ <span class="ot">-&gt;</span> z)</a>
<a class="sourceLine" id="cb14-3" title="3"></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="ot">listOf1 ::</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> <span class="dt">Sample</span> [a]</a>
<a class="sourceLine" id="cb14-5" title="5">listOf1 <span class="ot">=</span> listBy <span class="dt">True</span> ilog2 (\z _ <span class="ot">-&gt;</span> z)</a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7">ilog2</a>
<a class="sourceLine" id="cb14-8" title="8"><span class="ot">  ::</span> ( <span class="dt">Integral</span> n ) <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb14-9" title="9">ilog2 w <span class="ot">=</span> <span class="kw">if</span> w <span class="op">&lt;=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb14-10" title="10">  <span class="kw">then</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb14-11" title="11">  <span class="kw">else</span> <span class="dv">1</span> <span class="op">+</span> ilog2 (<span class="fu">div</span> w <span class="dv">2</span>)</a></code></pre></div>
<p><code>longListOf</code> bounds the list length by the size parameter and does not adjust the size parameter when generating the list items -- even more dangerous than <code>listOf</code>.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">longListOf ::</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> <span class="dt">Sample</span> [a]</a>
<a class="sourceLine" id="cb15-2" title="2">longListOf <span class="ot">=</span> listBy <span class="dt">False</span> <span class="fu">id</span> (\z _ <span class="ot">-&gt;</span> z)</a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="ot">longListOf1 ::</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> <span class="dt">Sample</span> [a]</a>
<a class="sourceLine" id="cb15-5" title="5">longListOf1 <span class="ot">=</span> listBy <span class="dt">True</span> <span class="fu">id</span> (\z _ <span class="ot">-&gt;</span> z)</a></code></pre></div>
<p><code>nestOf</code> bounds the list length with the base 2 log of <code>size</code>, like <code>listOf</code>, but divides the size parameter by the list length when generating list items. Thinking of size as a measure of complexity, this bounds the complexity of the resulting list roughly by the original size parameter.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">nestOf ::</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> <span class="dt">Sample</span> [a]</a>
<a class="sourceLine" id="cb16-2" title="2">nestOf <span class="ot">=</span> listBy <span class="dt">False</span> ilog2 (\z u <span class="ot">-&gt;</span> z <span class="ot">`div`</span> (<span class="fu">max</span> <span class="dv">1</span> u))</a>
<a class="sourceLine" id="cb16-3" title="3"></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="ot">nestOf1 ::</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> <span class="dt">Sample</span> [a]</a>
<a class="sourceLine" id="cb16-5" title="5">nestOf1 <span class="ot">=</span> listBy <span class="dt">True</span> ilog2 (\z u <span class="ot">-&gt;</span> z <span class="ot">`div`</span> (<span class="fu">max</span> <span class="dv">1</span> u))</a></code></pre></div>
<p><code>longNestOf</code> is analogous to <code>nestOf</code>, but bounds the length by <code>size</code>.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="ot">longNestOf ::</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> <span class="dt">Sample</span> [a]</a>
<a class="sourceLine" id="cb17-2" title="2">longNestOf <span class="ot">=</span> listBy <span class="dt">False</span> <span class="fu">id</span> (\z u <span class="ot">-&gt;</span> z <span class="ot">`div`</span> (<span class="fu">max</span> <span class="dv">1</span> u))</a>
<a class="sourceLine" id="cb17-3" title="3"></a>
<a class="sourceLine" id="cb17-4" title="4"><span class="ot">longNestOf1 ::</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> <span class="dt">Sample</span> [a]</a>
<a class="sourceLine" id="cb17-5" title="5">longNestOf1 <span class="ot">=</span> listBy <span class="dt">True</span> <span class="fu">id</span> (\z u <span class="ot">-&gt;</span> z <span class="ot">`div`</span> (<span class="fu">max</span> <span class="dv">1</span> u))</a></code></pre></div>
<p>Usually <code>nestOf</code> is a safe choice when we want an arbitrary list.</p>
<p>A related problem is to pick a distribution fairly from a given nonempty list: <code>selectFrom</code> does this. <code>oneFrom</code> is the special case when all the input distributions are trivial.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1">selectFrom</a>
<a class="sourceLine" id="cb18-2" title="2"><span class="ot">  ::</span> [<span class="dt">Sample</span> a] <span class="ot">-&gt;</span> <span class="dt">Sample</span> a</a>
<a class="sourceLine" id="cb18-3" title="3">selectFrom z <span class="ot">=</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-4" title="4">  [] <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;selectFrom called on empty list&quot;</span></a>
<a class="sourceLine" id="cb18-5" title="5">  _ <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb18-6" title="6">    <span class="kw">let</span> k <span class="ot">=</span> <span class="fu">length</span> z</a>
<a class="sourceLine" id="cb18-7" title="7">    i <span class="ot">&lt;-</span> randIn (<span class="dv">0</span>,k<span class="op">-</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb18-8" title="8">    z <span class="op">!!</span> i</a>
<a class="sourceLine" id="cb18-9" title="9"></a>
<a class="sourceLine" id="cb18-10" title="10">oneFrom</a>
<a class="sourceLine" id="cb18-11" title="11"><span class="ot">  ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Sample</span> a</a>
<a class="sourceLine" id="cb18-12" title="12">oneFrom <span class="ot">=</span> selectFrom <span class="op">.</span> <span class="fu">map</span> <span class="fu">return</span></a></code></pre></div>
<p>As an alternative to <code>selectFrom</code>, we can choose fairly among a tuple of distributions.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1">pickFrom2</a>
<a class="sourceLine" id="cb19-2" title="2"><span class="ot">  ::</span> (<span class="dt">Sample</span> a, <span class="dt">Sample</span> a)</a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="ot">-&gt;</span> <span class="dt">Sample</span> a</a>
<a class="sourceLine" id="cb19-4" title="4">pickFrom2 (a0, a1) <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-5" title="5">  i <span class="ot">&lt;-</span> randIn (<span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Int</span>, <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb19-6" title="6">  <span class="kw">case</span> i <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-7" title="7">    <span class="dv">0</span> <span class="ot">-&gt;</span> a0; _ <span class="ot">-&gt;</span> a1</a>
<a class="sourceLine" id="cb19-8" title="8"></a>
<a class="sourceLine" id="cb19-9" title="9">pickFrom3</a>
<a class="sourceLine" id="cb19-10" title="10"><span class="ot">  ::</span> (<span class="dt">Sample</span> a, <span class="dt">Sample</span> a, <span class="dt">Sample</span> a)</a>
<a class="sourceLine" id="cb19-11" title="11">  <span class="ot">-&gt;</span> <span class="dt">Sample</span> a</a>
<a class="sourceLine" id="cb19-12" title="12">pickFrom3 (a0, a1, a2) <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-13" title="13">  i <span class="ot">&lt;-</span> randIn (<span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Int</span>, <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb19-14" title="14">  <span class="kw">case</span> i <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-15" title="15">    <span class="dv">0</span> <span class="ot">-&gt;</span> a0; <span class="dv">1</span> <span class="ot">-&gt;</span> a1; _ <span class="ot">-&gt;</span> a2</a>
<a class="sourceLine" id="cb19-16" title="16"></a>
<a class="sourceLine" id="cb19-17" title="17">pickFrom4</a>
<a class="sourceLine" id="cb19-18" title="18"><span class="ot">  ::</span> (<span class="dt">Sample</span> a, <span class="dt">Sample</span> a, <span class="dt">Sample</span> a, <span class="dt">Sample</span> a)</a>
<a class="sourceLine" id="cb19-19" title="19">  <span class="ot">-&gt;</span> <span class="dt">Sample</span> a</a>
<a class="sourceLine" id="cb19-20" title="20">pickFrom4 (a0, a1, a2, a3) <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-21" title="21">  i <span class="ot">&lt;-</span> randIn (<span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Int</span>, <span class="dv">3</span>)</a>
<a class="sourceLine" id="cb19-22" title="22">  <span class="kw">case</span> i <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-23" title="23">    <span class="dv">0</span> <span class="ot">-&gt;</span> a0; <span class="dv">1</span> <span class="ot">-&gt;</span> a1; <span class="dv">2</span> <span class="ot">-&gt;</span> a2; _ <span class="ot">-&gt;</span> a3</a>
<a class="sourceLine" id="cb19-24" title="24"></a>
<a class="sourceLine" id="cb19-25" title="25">pickFrom5</a>
<a class="sourceLine" id="cb19-26" title="26"><span class="ot">  ::</span> (<span class="dt">Sample</span> a, <span class="dt">Sample</span> a, <span class="dt">Sample</span> a, <span class="dt">Sample</span> a, <span class="dt">Sample</span> a)</a>
<a class="sourceLine" id="cb19-27" title="27">  <span class="ot">-&gt;</span> <span class="dt">Sample</span> a</a>
<a class="sourceLine" id="cb19-28" title="28">pickFrom5 (a1, a2, a3, a4, a5) <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-29" title="29">  i <span class="ot">&lt;-</span> randIn (<span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Int</span>, <span class="dv">4</span>)</a>
<a class="sourceLine" id="cb19-30" title="30">  <span class="kw">case</span> i <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-31" title="31">    <span class="dv">0</span> <span class="ot">-&gt;</span> a1; <span class="dv">1</span> <span class="ot">-&gt;</span> a2; <span class="dv">2</span> <span class="ot">-&gt;</span> a3; <span class="dv">3</span> <span class="ot">-&gt;</span> a4; _ <span class="ot">-&gt;</span> a5</a>
<a class="sourceLine" id="cb19-32" title="32"></a>
<a class="sourceLine" id="cb19-33" title="33">pickFrom6</a>
<a class="sourceLine" id="cb19-34" title="34"><span class="ot">  ::</span> (<span class="dt">Sample</span> a, <span class="dt">Sample</span> a, <span class="dt">Sample</span> a, <span class="dt">Sample</span> a, <span class="dt">Sample</span> a, <span class="dt">Sample</span> a)</a>
<a class="sourceLine" id="cb19-35" title="35">  <span class="ot">-&gt;</span> <span class="dt">Sample</span> a</a>
<a class="sourceLine" id="cb19-36" title="36">pickFrom6 (a1, a2, a3, a4, a5, a6) <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb19-37" title="37">  i <span class="ot">&lt;-</span> randIn (<span class="dv">0</span><span class="ot"> ::</span> <span class="dt">Int</span>, <span class="dv">5</span>)</a>
<a class="sourceLine" id="cb19-38" title="38">  <span class="kw">case</span> i <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-39" title="39">    <span class="dv">0</span> <span class="ot">-&gt;</span> a1; <span class="dv">1</span> <span class="ot">-&gt;</span> a2; <span class="dv">2</span> <span class="ot">-&gt;</span> a3; <span class="dv">3</span> <span class="ot">-&gt;</span> a4; <span class="dv">4</span> <span class="ot">-&gt;</span> a5; _ <span class="ot">-&gt;</span> a6</a></code></pre></div>
<p><code>freq</code> is a variant of <code>selectFrom</code> allowing us to weight the input distributions. For example, in</p>
<div class="example">
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1">z <span class="ot">=</span> freq</a>
<a class="sourceLine" id="cb20-2" title="2">  [ (<span class="dv">1</span>, x)</a>
<a class="sourceLine" id="cb20-3" title="3">  , (<span class="dv">2</span>, y)</a>
<a class="sourceLine" id="cb20-4" title="4">  ]</a></code></pre></div>
</div>
<p>when <code>z</code> is sampled, it draws from <code>x</code> 1/3 of the time and from <code>y</code> 2/3 of the time.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1">freq</a>
<a class="sourceLine" id="cb21-2" title="2"><span class="ot">  ::</span> <span class="kw">forall</span> a<span class="op">.</span> [(<span class="dt">Int</span>, <span class="dt">Sample</span> a)] <span class="ot">-&gt;</span> <span class="dt">Sample</span> a</a>
<a class="sourceLine" id="cb21-3" title="3">freq ws <span class="ot">=</span> <span class="kw">case</span> ws <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-4" title="4">  [] <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;freq: undefined on []&quot;</span></a>
<a class="sourceLine" id="cb21-5" title="5">  (k0,x0)<span class="op">:</span>vs <span class="ot">-&gt;</span> <span class="kw">if</span> <span class="fu">any</span> (<span class="op">&lt;</span> <span class="dv">0</span>) <span class="op">$</span> <span class="fu">map</span> <span class="fu">fst</span> ws</a>
<a class="sourceLine" id="cb21-6" title="6">    <span class="kw">then</span> <span class="fu">error</span> <span class="st">&quot;freq: negative weight&quot;</span></a>
<a class="sourceLine" id="cb21-7" title="7">    <span class="kw">else</span> <span class="kw">if</span> <span class="fu">all</span> (<span class="op">==</span> <span class="dv">0</span>) <span class="op">$</span> <span class="fu">map</span> <span class="fu">fst</span> ws</a>
<a class="sourceLine" id="cb21-8" title="8">      <span class="kw">then</span> <span class="fu">error</span> <span class="st">&quot;Kreb.Prop.Sample.freq: all weights zero&quot;</span></a>
<a class="sourceLine" id="cb21-9" title="9">      <span class="kw">else</span> randIn (<span class="dv">1</span>, total) <span class="op">&gt;&gt;=</span> thresh vs</a>
<a class="sourceLine" id="cb21-10" title="10">        <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-11" title="11"><span class="ot">          total ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb21-12" title="12">          total <span class="ot">=</span> <span class="fu">sum</span> <span class="op">$</span> <span class="fu">map</span> <span class="fu">fst</span> ws</a>
<a class="sourceLine" id="cb21-13" title="13"></a>
<a class="sourceLine" id="cb21-14" title="14">          thresh</a>
<a class="sourceLine" id="cb21-15" title="15"><span class="ot">            ::</span> [(<span class="dt">Int</span>, <span class="dt">Sample</span> a)] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Sample</span> a</a>
<a class="sourceLine" id="cb21-16" title="16">          thresh zs n <span class="ot">=</span> <span class="kw">case</span> zs <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-17" title="17">            [] <span class="ot">-&gt;</span> x0</a>
<a class="sourceLine" id="cb21-18" title="18">            (k,x)<span class="op">:</span>us <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="op">&lt;=</span> k</a>
<a class="sourceLine" id="cb21-19" title="19">              <span class="kw">then</span> x</a>
<a class="sourceLine" id="cb21-20" title="20">              <span class="kw">else</span> thresh us (n<span class="op">-</span>k)</a></code></pre></div>
<p>The next combinator lets us vary the seed stream using an integer; it will be handy when we start generating random functions. This implementation comes directly from QuickCheck, and features a clever application of the <a href="https://en.wikipedia.org/wiki/Elias_gamma_coding">Elias gamma encoding</a> of integers to guarantee that calling <code>twiddle n</code> for different <code>n</code> generates independent seeds.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1">twiddle</a>
<a class="sourceLine" id="cb22-2" title="2"><span class="ot">  ::</span> ( <span class="dt">Integral</span> n )</a>
<a class="sourceLine" id="cb22-3" title="3">  <span class="ot">=&gt;</span> n <span class="ot">-&gt;</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> <span class="dt">Sample</span> a</a>
<a class="sourceLine" id="cb22-4" title="4">twiddle k x <span class="ot">=</span></a>
<a class="sourceLine" id="cb22-5" title="5">  fiddle (twiddleInt (<span class="fu">toInteger</span> k)) <span class="op">&gt;&gt;</span> x</a>
<a class="sourceLine" id="cb22-6" title="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-7" title="7">    twiddleInt</a>
<a class="sourceLine" id="cb22-8" title="8"><span class="ot">      ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span></a>
<a class="sourceLine" id="cb22-9" title="9">    twiddleInt k gen <span class="ot">=</span></a>
<a class="sourceLine" id="cb22-10" title="10">      <span class="kw">let</span> (gen1, gen2) <span class="ot">=</span> split gen</a>
<a class="sourceLine" id="cb22-11" title="11">      <span class="kw">in</span> <span class="kw">if</span> k <span class="op">&gt;=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb22-12" title="12">        <span class="kw">then</span> gamma k gen1</a>
<a class="sourceLine" id="cb22-13" title="13">        <span class="kw">else</span> gamma (<span class="dv">1</span><span class="op">-</span>k) gen2</a>
<a class="sourceLine" id="cb22-14" title="14"></a>
<a class="sourceLine" id="cb22-15" title="15">    gamma</a>
<a class="sourceLine" id="cb22-16" title="16"><span class="ot">      ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span></a>
<a class="sourceLine" id="cb22-17" title="17">    gamma n <span class="ot">=</span></a>
<a class="sourceLine" id="cb22-18" title="18">      <span class="kw">let</span> k <span class="ot">=</span> ilog2 n</a>
<a class="sourceLine" id="cb22-19" title="19">      <span class="kw">in</span> encode k <span class="op">.</span> zeroes k</a>
<a class="sourceLine" id="cb22-20" title="20">      <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-21" title="21"><span class="ot">        encode ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span></a>
<a class="sourceLine" id="cb22-22" title="22">        encode m gen <span class="ot">=</span> <span class="kw">if</span> m <span class="op">&lt;=</span> <span class="op">-</span><span class="dv">1</span></a>
<a class="sourceLine" id="cb22-23" title="23">          <span class="kw">then</span> gen</a>
<a class="sourceLine" id="cb22-24" title="24">          <span class="kw">else</span> <span class="kw">let</span> (gen1, gen2) <span class="ot">=</span> split gen <span class="kw">in</span></a>
<a class="sourceLine" id="cb22-25" title="25">            <span class="kw">if</span> testBit n m</a>
<a class="sourceLine" id="cb22-26" title="26">              <span class="kw">then</span> encode (m<span class="op">-</span><span class="dv">1</span>) gen2</a>
<a class="sourceLine" id="cb22-27" title="27">              <span class="kw">else</span> encode (m<span class="op">-</span><span class="dv">1</span>) gen1</a>
<a class="sourceLine" id="cb22-28" title="28"></a>
<a class="sourceLine" id="cb22-29" title="29">    zeroes</a>
<a class="sourceLine" id="cb22-30" title="30"><span class="ot">      ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span> <span class="ot">-&gt;</span> <span class="dt">StdGen</span></a>
<a class="sourceLine" id="cb22-31" title="31">    zeroes m gen <span class="ot">=</span> <span class="kw">if</span> m <span class="op">&lt;=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb22-32" title="32">      <span class="kw">then</span> gen</a>
<a class="sourceLine" id="cb22-33" title="33">      <span class="kw">else</span> <span class="fu">fst</span> <span class="op">$</span> split gen</a></code></pre></div>
<p>We can filter a distribution by tossing out generated values that don't satisfy a predicate. This is dangerous -- careless use of <code>satisfying</code> can make sampling fail to terminate.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1">satisfying</a>
<a class="sourceLine" id="cb23-2" title="2"><span class="ot">  ::</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Sample</span> a</a>
<a class="sourceLine" id="cb23-3" title="3">satisfying gen p <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-4" title="4">  mx <span class="ot">&lt;-</span> gen <span class="ot">`satisfyingMaybe`</span> p</a>
<a class="sourceLine" id="cb23-5" title="5">  <span class="kw">case</span> mx <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-6" title="6">    <span class="dt">Just</span> x <span class="ot">-&gt;</span> <span class="fu">return</span> x</a>
<a class="sourceLine" id="cb23-7" title="7">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-8" title="8">      k <span class="ot">&lt;-</span> size</a>
<a class="sourceLine" id="cb23-9" title="9">      withSize (k<span class="op">+</span><span class="dv">1</span>) (gen <span class="ot">`satisfying`</span> p)</a>
<a class="sourceLine" id="cb23-10" title="10"></a>
<a class="sourceLine" id="cb23-11" title="11">satisfyingMaybe</a>
<a class="sourceLine" id="cb23-12" title="12"><span class="ot">  ::</span> <span class="dt">Sample</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Sample</span> (<span class="dt">Maybe</span> a)</a>
<a class="sourceLine" id="cb23-13" title="13">satisfyingMaybe gen p <span class="ot">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-14" title="14">  n <span class="ot">&lt;-</span> size</a>
<a class="sourceLine" id="cb23-15" title="15">  try n (<span class="dv">2</span><span class="op">*</span>n)</a>
<a class="sourceLine" id="cb23-16" title="16">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-17" title="17">      try m n <span class="ot">=</span> <span class="kw">if</span> m <span class="op">&gt;</span> n</a>
<a class="sourceLine" id="cb23-18" title="18">        <span class="kw">then</span> <span class="fu">return</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb23-19" title="19">        <span class="kw">else</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb23-20" title="20">          x <span class="ot">&lt;-</span> withSize m gen</a>
<a class="sourceLine" id="cb23-21" title="21">          <span class="kw">if</span> p x</a>
<a class="sourceLine" id="cb23-22" title="22">            <span class="kw">then</span> <span class="fu">return</span> <span class="op">$</span> <span class="dt">Just</span> x</a>
<a class="sourceLine" id="cb23-23" title="23">            <span class="kw">else</span> try (m<span class="op">+</span><span class="dv">1</span>) n</a></code></pre></div>
<p>This is also a good place to dump some character specific combinators.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1">arbAsciiChar</a>
<a class="sourceLine" id="cb24-2" title="2"><span class="ot">  ::</span> <span class="dt">Sample</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb24-3" title="3">arbAsciiChar <span class="ot">=</span> randIn (<span class="ch">&#39;\0&#39;</span>, <span class="ch">&#39;\127&#39;</span>)</a>
<a class="sourceLine" id="cb24-4" title="4"></a>
<a class="sourceLine" id="cb24-5" title="5">arbPrintableAsciiChar</a>
<a class="sourceLine" id="cb24-6" title="6"><span class="ot">  ::</span> <span class="dt">Sample</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb24-7" title="7">arbPrintableAsciiChar <span class="ot">=</span> freq</a>
<a class="sourceLine" id="cb24-8" title="8">  [ (<span class="dv">95</span>, randIn (<span class="ch">&#39;\x20&#39;</span>, <span class="ch">&#39;\x7e&#39;</span>))</a>
<a class="sourceLine" id="cb24-9" title="9">  , (<span class="dv">1</span>,  <span class="fu">return</span> <span class="ch">&#39;\t&#39;</span>)</a>
<a class="sourceLine" id="cb24-10" title="10">  , (<span class="dv">1</span>,  <span class="fu">return</span> <span class="ch">&#39;\n&#39;</span>)</a>
<a class="sourceLine" id="cb24-11" title="11">  ]</a>
<a class="sourceLine" id="cb24-12" title="12"></a>
<a class="sourceLine" id="cb24-13" title="13">arbUnicodeChar</a>
<a class="sourceLine" id="cb24-14" title="14"><span class="ot">  ::</span> <span class="dt">Sample</span> <span class="dt">Char</span></a>
<a class="sourceLine" id="cb24-15" title="15">arbUnicodeChar <span class="ot">=</span></a>
<a class="sourceLine" id="cb24-16" title="16">  (randIn (<span class="ch">&#39;\0&#39;</span>, <span class="ch">&#39;\1114111&#39;</span>)) <span class="ot">`satisfying`</span> notSurrogate</a>
<a class="sourceLine" id="cb24-17" title="17">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-18" title="18">    notSurrogate c <span class="ot">=</span> <span class="dt">Surrogate</span> <span class="op">/=</span> generalCategory c</a></code></pre></div>
</section>
</article>
</body>
</html>
