<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Finger Trees</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="../../../../../../../styles/style.css">
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<article>
<header>
<h1 class="title">Finger Trees</h1>
</header>
<div class="contents">
<ul>
<li><a href="#introduction">Introduction</a>: The problem we're solving</li>
<li><a href="#internal-types">Internal Types</a>: Building toward polymorphic recursion</li>
<li><a href="#finger-trees">Finger Trees</a>: Not as scary as it sounds</li>
<li><a href="#cons-and-uncons">Cons and Uncons</a>: Building and destructuring finger trees</li>
<li><a href="#concatenation">Concatenation</a>: They were lists the whole time</li>
<li><a href="#splitting">Splitting</a>: Efficient search</li>
<li><a href="#testing-and-debugging">Testing and Debugging</a>: Validation and test case generation</li>
</ul>
</div>
<div class="frontmatter">
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">{-# LANGUAGE StandaloneDeriving, OverloadedStrings #-}</span></a></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">module</span> <span class="dt">Kreb.Struct.Data.FingerTree</span> (</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="dt">FingerTree</span>(<span class="op">..</span>)</a>
<a class="sourceLine" id="cb2-3" title="3">  , <span class="dt">NonEmptyFingerTree</span>()</a>
<a class="sourceLine" id="cb2-4" title="4">  , toAnnotatedList</a>
<a class="sourceLine" id="cb2-5" title="5"></a>
<a class="sourceLine" id="cb2-6" title="6">  , inflateWith</a>
<a class="sourceLine" id="cb2-7" title="7"></a>
<a class="sourceLine" id="cb2-8" title="8">  , <span class="dt">SplitResult</span>(<span class="op">..</span>)</a>
<a class="sourceLine" id="cb2-9" title="9">  , <span class="dt">Split</span>(splitWithContextL, splitWithContextR)</a>
<a class="sourceLine" id="cb2-10" title="10">  , splitL</a>
<a class="sourceLine" id="cb2-11" title="11">  , splitR</a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13">  , removeSplitsL</a>
<a class="sourceLine" id="cb2-14" title="14">  , removeSplitsR</a>
<a class="sourceLine" id="cb2-15" title="15"></a>
<a class="sourceLine" id="cb2-16" title="16">  , validateFingerTree</a>
<a class="sourceLine" id="cb2-17" title="17">  , validateNonEmptyFingerTree</a>
<a class="sourceLine" id="cb2-18" title="18">) <span class="kw">where</span></a></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">import</span> <span class="dt">Prelude</span> <span class="kw">hiding</span> (reverse)</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">import</span> <span class="dt">Data.Foldable</span></a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Kreb.Format</span> <span class="kw">as</span> <span class="dt">Fmt</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">import</span>           <span class="dt">Kreb.Format</span> (display, (&lt;+&gt;))</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">import</span>           <span class="dt">Kreb.Check</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="kw">import</span>           <span class="dt">Kreb.Control</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="kw">import</span>           <span class="dt">Kreb.Control.Constrained</span></a></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">import</span>           <span class="dt">Kreb.Struct.Class</span></a></code></pre></div>
</div>
<section class="level2">
<h2>Introduction</h2>
<p>The most basic requirement of a text editor is surely that it provide some mechanism for modeling and manipulating strings of characters. This mechanism had better be pretty robust and efficient, too, at least for common operations, since it will be doing most of the work during everyday use. Several different data structures have been developed for this purpose; two important examples are gap buffers and piece tables. But not all data structures translate cleanly to a language like Haskell where mutation is very strictly controlled and evaluation is lazy by default.</p>
<p>Choosing a data structure is all about making tradeoffs. We think about our particular application and what data and operations it needs, then choose a structure that makes those operations efficient. With that in mind, what exactly do we need for our simple text editor? I can think of a few things.</p>
<ol>
<li>Our data structure should essentially model a list of characters; that is, whatever weird branching or in-place mutating business is happening behind the scenes, the API is more or less that of lists.</li>
<li>Typically when editing text we've got a distinguished position called the <em>cursor</em> where our editing actions (insert, delete) have immediate effect. It is vital that interacting with and moving the cursor around be blazing fast, since that's where most of the work happens.</li>
<li>Another very common action when editing text is <em>search</em>. This takes a few forms -- jumping to a particular line and column position, or searching for a literal substring, or looking for matches to a given regular expression. We should be able to handle this too.</li>
</ol>
<p>There are others -- fast syntax highlighting is nice, for instance -- but these are the absolute essentials.</p>
<p>Lucky for us there's a powerful data structure that gives us all three, based on <em>finger trees</em>. These were introduced in the present form in the paper <a href="http://www.staff.city.ac.uk/~ross/papers/FingerTree.html"><em>Finger trees: a simple general-purpose data structure</em></a> by Hinze and Paterson. The funny name refers to the fact that trees of this type have <em>fingers</em> -- distinguished locations where read and write access is cheap.<span><label for="sn-0" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-0" class="margin-toggle"/><span class="sidenote">Finger trees are themselves an instance of a more general and very powerful pattern for designing data structures based on <em>numerical representations</em>. Okasaki's &lt;a href="https://www.cs.cmu.edu/~rwh/theses/okasaki.pdf"&gt;thesis&lt;/a&gt; on <em>Purely Functional Data Structures</em> (also available in book form) is the classic reference on this topic.<br />
<br />
</span></span></p>
<p>In this module we'll develop an API for working with finger trees by following the Hinze and Paterson paper pretty closely. There are existing implementations of this that we could use instead, but finger trees are quite elegant and seeing how they work by rolling our own is a worthwhile exercise.</p>
<p>The secret sauce behind finger trees is that they are not a single data structure but a whole family of structures, parameterized by a <em>monoid</em>, which permits an efficient and generic <em>search</em> algorithm. Different choices for the monoid yield specific structures with different behavior, but we can implement them all at once. This is a good case study on the principle that <em>throwing away detail</em> can lead to clean and general code.</p>
</section>
<section class="level2">
<h2>Internal Types</h2>
<p>Recursive data types are the bread and butter of functional programming -- after a little practice we whip up new recursive types without even thinking about it. Finger trees are also recursively defined, but exhibit a phenomenon called <em>polymorphic recursion</em> where at each level the "inner" and "outer" parameters have different types. To get there we first need to define some auxiliary types.</p>
<p>Finger trees have nested data of two forms: the <em>fingers</em>, which provide amortized constant complexity access to a small number of values on either "end" of the tree, and the <em>branches</em>, which carry more deeply nested values. These are implemented here as the types <code>Some</code> and <code>Node</code>, which are used only inside this module.</p>
<p>First for the fingers. The number of values on each end ranges from one to four. Why four? The short answer is that this is the number required to make the amortized complexity proofs work out; it provides just the right balance between <em>immediate access</em> at the fingers and <em>deep nesting</em> in the branches. The Hinze and Paterson paper has the details. We represent the fingers with the following <code>Some</code> type.<span><label for="sn-1" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-1" class="margin-toggle"/><span class="sidenote">Some is also a sum.<br />
<br />
</span></span></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">data</span> <span class="dt">Some</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="dt">Only1</span><span class="ot"> ::</span> (<span class="dt">Valued</span> a) <span class="ot">=&gt;</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> a                <span class="ot">-&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="dt">Only2</span><span class="ot"> ::</span> (<span class="dt">Valued</span> a) <span class="ot">=&gt;</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a           <span class="ot">-&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb6-4" title="4">  <span class="dt">Only3</span><span class="ot"> ::</span> (<span class="dt">Valued</span> a) <span class="ot">=&gt;</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a      <span class="ot">-&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb6-5" title="5">  <span class="dt">Only4</span><span class="ot"> ::</span> (<span class="dt">Valued</span> a) <span class="ot">=&gt;</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="kw">deriving</span> <span class="kw">instance</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Some</span> a)</a></code></pre></div>
<p>Note the <code>Valued</code> constraint on the item type <code>a</code>. This class is inhabited by types equipped with a special monoidal <em>valuation</em> function, <code>value</code>. Each <code>Some</code> constructor takes a value of type <code>Value a</code>, which must be the product of the values of the <code>a</code>s in the constructor. Maintaining this invariant is crucial to the correctness of our code; unfortunately we can't encode it in the type so we'll just have to be really careful.</p>
<p>If <code>a</code> has a valuation, then <code>Some a</code> does as well in the natural way -- assuming we've maintained the invariant we can return the cached valuation to save some effort.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">instance</span> (<span class="dt">Valued</span> a) <span class="ot">=&gt;</span> <span class="dt">Valued</span> (<span class="dt">Some</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="kw">type</span> <span class="dt">Value</span> (<span class="dt">Some</span> a) <span class="ot">=</span> <span class="dt">Value</span> a</a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="ot">  value ::</span> <span class="dt">Some</span> a <span class="ot">-&gt;</span> <span class="dt">Value</span> (<span class="dt">Some</span> a)</a>
<a class="sourceLine" id="cb7-5" title="5">  value w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="dt">Only1</span> v _       <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="dt">Only2</span> v _ _     <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb7-8" title="8">    <span class="dt">Only3</span> v _ _ _   <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb7-9" title="9">    <span class="dt">Only4</span> v _ _ _ _ <span class="ot">-&gt;</span> v</a></code></pre></div>
<p>To maintain the invariant that our cached value is accurate, it's important that we only create <code>Some</code> values using the following <em>smart constructors</em>. This idiom is common for Haskell types with invariants that can't (easily) be embedded in the type.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1">only1</a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb8-3" title="3">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb8-4" title="4">only1 a1 <span class="ot">=</span> <span class="dt">Only1</span> v a1</a>
<a class="sourceLine" id="cb8-5" title="5">  <span class="kw">where</span> v <span class="ot">=</span> value a1</a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7">only2</a>
<a class="sourceLine" id="cb8-8" title="8"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb8-9" title="9">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb8-10" title="10">only2 a1 a2 <span class="ot">=</span></a>
<a class="sourceLine" id="cb8-11" title="11">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb8-12" title="12">    v <span class="ot">=</span> <span class="fu">mconcat</span></a>
<a class="sourceLine" id="cb8-13" title="13">      [ value a1, value a2 ]</a>
<a class="sourceLine" id="cb8-14" title="14">  <span class="kw">in</span> <span class="dt">Only2</span> v a1 a2 </a>
<a class="sourceLine" id="cb8-15" title="15"></a>
<a class="sourceLine" id="cb8-16" title="16">only3</a>
<a class="sourceLine" id="cb8-17" title="17"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb8-18" title="18">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb8-19" title="19">only3 a1 a2 a3 <span class="ot">=</span></a>
<a class="sourceLine" id="cb8-20" title="20">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb8-21" title="21">    v <span class="ot">=</span> <span class="fu">mconcat</span></a>
<a class="sourceLine" id="cb8-22" title="22">      [ value a1, value a2, value a3 ]</a>
<a class="sourceLine" id="cb8-23" title="23">  <span class="kw">in</span> <span class="dt">Only3</span> v a1 a2 a3 </a>
<a class="sourceLine" id="cb8-24" title="24"></a>
<a class="sourceLine" id="cb8-25" title="25">only4</a>
<a class="sourceLine" id="cb8-26" title="26"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb8-27" title="27">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb8-28" title="28">only4 a1 a2 a3 a4 <span class="ot">=</span></a>
<a class="sourceLine" id="cb8-29" title="29">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb8-30" title="30">    v <span class="ot">=</span> <span class="fu">mconcat</span></a>
<a class="sourceLine" id="cb8-31" title="31">      [ value a1, value a2, value a3, value a4 ]</a>
<a class="sourceLine" id="cb8-32" title="32">  <span class="kw">in</span> <span class="dt">Only4</span> v a1 a2 a3 a4</a></code></pre></div>
<p>These constructors are not exposed outside this module since they are only used in the internal representation.</p>
<p>Because of the extra constraint on the type parameter, <code>Some</code> cannot be a functor -- at least not a functor on the category of all Haskell types. It is however a <em>constrained</em> functor on the (sub)category of types inhabiting the <code>Valued</code> class. We have a special class for constrained functors.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">instance</span> <span class="dt">ConstrainedFunctor</span> <span class="dt">Some</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="kw">type</span> <span class="dt">FunctorConstraint</span> <span class="dt">Some</span> <span class="ot">=</span> <span class="dt">Valued</span></a>
<a class="sourceLine" id="cb9-3" title="3"></a>
<a class="sourceLine" id="cb9-4" title="4">  fmapC</a>
<a class="sourceLine" id="cb9-5" title="5"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a, <span class="dt">Valued</span> b )</a>
<a class="sourceLine" id="cb9-6" title="6">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Some</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> b</a>
<a class="sourceLine" id="cb9-7" title="7">  fmapC f x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-8" title="8">    <span class="dt">Only1</span> _ u1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-9" title="9">      only1 (f u1)</a>
<a class="sourceLine" id="cb9-10" title="10">    <span class="dt">Only2</span> _ u1 u2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-11" title="11">      only2 (f u1) (f u2)</a>
<a class="sourceLine" id="cb9-12" title="12">    <span class="dt">Only3</span> _ u1 u2 u3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-13" title="13">      only3 (f u1) (f u2) (f u3)</a>
<a class="sourceLine" id="cb9-14" title="14">    <span class="dt">Only4</span> _ u1 u2 u3 u4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-15" title="15">      only4 (f u1) (f u2) (f u3) (f u4)</a></code></pre></div>
<p>We should test our intuition for how <code>fmapC</code> should behave with an example.</p>
<div class="doctest">
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="co">--   x, y :: Some (Counted Int)</span></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="co">--   x = only3 1 2 3</span></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="co">--   y = only3 2 4 6</span></a>
<a class="sourceLine" id="cb10-7" title="7"><span class="co">-- in y == fmapC (*2) x</span></a>
<a class="sourceLine" id="cb10-8" title="8"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb10-9" title="9"><span class="co">-- True</span></a></code></pre></div>
</div>
<p>Next we have a <code>Foldable</code> instance (this is where we use <code>InstanceSigs</code> for clarity). Here we do have a bona fide class instance because we don't need to use the smart constructors.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Some</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" title="2">  toList</a>
<a class="sourceLine" id="cb11-3" title="3"><span class="ot">    ::</span> <span class="dt">Some</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb11-4" title="4">  toList w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span> [a1]</a>
<a class="sourceLine" id="cb11-6" title="6">    <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span> [a1, a2]</a>
<a class="sourceLine" id="cb11-7" title="7">    <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span> [a1, a2, a3]</a>
<a class="sourceLine" id="cb11-8" title="8">    <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span> [a1, a2, a3, a4]</a>
<a class="sourceLine" id="cb11-9" title="9"></a>
<a class="sourceLine" id="cb11-10" title="10">  <span class="fu">foldr</span></a>
<a class="sourceLine" id="cb11-11" title="11"><span class="ot">    ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Some</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb11-12" title="12">  <span class="fu">foldr</span> f b w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-13" title="13">    <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-14" title="14">      f a1 b</a>
<a class="sourceLine" id="cb11-15" title="15">    <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-16" title="16">      f a1 (f a2 b)</a>
<a class="sourceLine" id="cb11-17" title="17">    <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-18" title="18">      f a1 (f a2 (f a3 b))</a>
<a class="sourceLine" id="cb11-19" title="19">    <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-20" title="20">      f a1 (f a2 (f a3 (f a4 b)))</a>
<a class="sourceLine" id="cb11-21" title="21"></a>
<a class="sourceLine" id="cb11-22" title="22">  <span class="fu">foldl</span></a>
<a class="sourceLine" id="cb11-23" title="23"><span class="ot">    ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Some</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb11-24" title="24">  <span class="fu">foldl</span> f b w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-25" title="25">    <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-26" title="26">      f b a1</a>
<a class="sourceLine" id="cb11-27" title="27">    <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-28" title="28">      f (f b a1) a2</a>
<a class="sourceLine" id="cb11-29" title="29">    <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-30" title="30">      f (f (f b a1) a2) a3</a>
<a class="sourceLine" id="cb11-31" title="31">    <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-32" title="32">      f (f (f (f b a1) a2) a3) a4</a></code></pre></div>
<p>This instance is mainly used as a helper for defining the instance for <code>FingerTree</code>. Because <code>Some</code> is not exposed outside of this module we won't rigorously check that this instance is lawful (though we will do this indirectly when we test the corresponding instance for finger trees). We can however manually check some small examples.</p>
<div class="doctest">
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb12-2" title="2"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb12-4" title="4"><span class="co">--   x :: Some (Counted Char)</span></a>
<a class="sourceLine" id="cb12-5" title="5"><span class="co">--   x = only3 (Counted &#39;a&#39;) (Counted &#39;b&#39;) (Counted &#39;c&#39;)</span></a>
<a class="sourceLine" id="cb12-6" title="6"><span class="co">-- in</span></a>
<a class="sourceLine" id="cb12-7" title="7"><span class="co">--   ( fmap unCounted $ foldr (:) [] x</span></a>
<a class="sourceLine" id="cb12-8" title="8"><span class="co">--   , fmap unCounted $ foldl (flip (:)) [] x</span></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="co">--   )</span></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb12-11" title="11"><span class="co">-- (&quot;abc&quot;,&quot;cba&quot;)</span></a></code></pre></div>
</div>
<p><code>Some</code> is also a contrained traversable functor:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">instance</span> <span class="dt">ConstrainedTraversable</span> <span class="dt">Some</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-2" title="2">  traverseC</a>
<a class="sourceLine" id="cb13-3" title="3"><span class="ot">    ::</span> ( <span class="dt">Applicative</span> f, <span class="dt">Valued</span> a, <span class="dt">Valued</span> b )</a>
<a class="sourceLine" id="cb13-4" title="4">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Some</span> a <span class="ot">-&gt;</span> f (<span class="dt">Some</span> b)</a>
<a class="sourceLine" id="cb13-5" title="5">  traverseC f w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-6" title="6">    <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-7" title="7">      only1 <span class="op">&lt;$&gt;</span> f a1</a>
<a class="sourceLine" id="cb13-8" title="8">    <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-9" title="9">      only2 <span class="op">&lt;$&gt;</span> f a1 <span class="op">&lt;*&gt;</span> f a2</a>
<a class="sourceLine" id="cb13-10" title="10">    <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-11" title="11">      only3 <span class="op">&lt;$&gt;</span> f a1 <span class="op">&lt;*&gt;</span> f a2 <span class="op">&lt;*&gt;</span> f a3</a>
<a class="sourceLine" id="cb13-12" title="12">    <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-13" title="13">      only4 <span class="op">&lt;$&gt;</span> f a1 <span class="op">&lt;*&gt;</span> f a2 <span class="op">&lt;*&gt;</span> f a3 <span class="op">&lt;*&gt;</span> f a4</a>
<a class="sourceLine" id="cb13-14" title="14"></a>
<a class="sourceLine" id="cb13-15" title="15">  sequenceAC</a>
<a class="sourceLine" id="cb13-16" title="16"><span class="ot">    ::</span> ( <span class="dt">Applicative</span> f, <span class="dt">Valued</span> a, <span class="dt">Valued</span> (f a) )</a>
<a class="sourceLine" id="cb13-17" title="17">    <span class="ot">=&gt;</span> <span class="dt">Some</span> (f a) <span class="ot">-&gt;</span> f (<span class="dt">Some</span> a)</a>
<a class="sourceLine" id="cb13-18" title="18">  sequenceAC w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-19" title="19">    <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-20" title="20">      <span class="fu">pure</span> only1 <span class="op">&lt;*&gt;</span> a1</a>
<a class="sourceLine" id="cb13-21" title="21">    <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-22" title="22">      <span class="fu">pure</span> only2 <span class="op">&lt;*&gt;</span> a1 <span class="op">&lt;*&gt;</span> a2</a>
<a class="sourceLine" id="cb13-23" title="23">    <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-24" title="24">      <span class="fu">pure</span> only3 <span class="op">&lt;*&gt;</span> a1 <span class="op">&lt;*&gt;</span> a2 <span class="op">&lt;*&gt;</span> a3</a>
<a class="sourceLine" id="cb13-25" title="25">    <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb13-26" title="26">      <span class="fu">pure</span> only4 <span class="op">&lt;*&gt;</span> a1 <span class="op">&lt;*&gt;</span> a2 <span class="op">&lt;*&gt;</span> a3 <span class="op">&lt;*&gt;</span> a4</a></code></pre></div>
<p>Next we have a nested tree type. Finger trees are basically rearranged 2-3 trees, and the nested <code>Node</code> type represents internal branching nodes of this sort.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">data</span> <span class="dt">Node</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-2" title="2">  <span class="dt">Node2</span><span class="ot"> ::</span> (<span class="dt">Valued</span> a) <span class="ot">=&gt;</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a      <span class="ot">-&gt;</span> <span class="dt">Node</span> a</a>
<a class="sourceLine" id="cb14-3" title="3">  <span class="dt">Node3</span><span class="ot"> ::</span> (<span class="dt">Valued</span> a) <span class="ot">=&gt;</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Node</span> a</a>
<a class="sourceLine" id="cb14-4" title="4"></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="kw">deriving</span> <span class="kw">instance</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">Node</span> a)</a></code></pre></div>
<p>Again we cache the value of the internal data, using smart constructors to maintain the integrity of the cache.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">instance</span> (<span class="dt">Valued</span> a) <span class="ot">=&gt;</span> <span class="dt">Valued</span> (<span class="dt">Node</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="kw">type</span> <span class="dt">Value</span> (<span class="dt">Node</span> a) <span class="ot">=</span> <span class="dt">Value</span> a</a>
<a class="sourceLine" id="cb15-3" title="3"></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="ot">  value ::</span> <span class="dt">Node</span> a <span class="ot">-&gt;</span> <span class="dt">Value</span> (<span class="dt">Node</span> a)</a>
<a class="sourceLine" id="cb15-5" title="5">  value w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-6" title="6">    <span class="dt">Node2</span> v _ _   <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb15-7" title="7">    <span class="dt">Node3</span> v _ _ _ <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb15-8" title="8"></a>
<a class="sourceLine" id="cb15-9" title="9">node2</a>
<a class="sourceLine" id="cb15-10" title="10"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb15-11" title="11">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Node</span> a</a>
<a class="sourceLine" id="cb15-12" title="12">node2 a1 a2 <span class="ot">=</span></a>
<a class="sourceLine" id="cb15-13" title="13">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb15-14" title="14">    v <span class="ot">=</span> <span class="fu">mconcat</span></a>
<a class="sourceLine" id="cb15-15" title="15">      [ value a1, value a2 ]</a>
<a class="sourceLine" id="cb15-16" title="16">  <span class="kw">in</span> <span class="dt">Node2</span> v a1 a2</a>
<a class="sourceLine" id="cb15-17" title="17"></a>
<a class="sourceLine" id="cb15-18" title="18">node3</a>
<a class="sourceLine" id="cb15-19" title="19"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb15-20" title="20">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Node</span> a</a>
<a class="sourceLine" id="cb15-21" title="21">node3 a1 a2 a3 <span class="ot">=</span></a>
<a class="sourceLine" id="cb15-22" title="22">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb15-23" title="23">    v <span class="ot">=</span> <span class="fu">mconcat</span></a>
<a class="sourceLine" id="cb15-24" title="24">      [ value a1, value a2, value a3 ]</a>
<a class="sourceLine" id="cb15-25" title="25">  <span class="kw">in</span> <span class="dt">Node3</span> v a1 a2 a3</a></code></pre></div>
<p><code>Node</code> is again a constrained functor:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">instance</span> <span class="dt">ConstrainedFunctor</span> <span class="dt">Node</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb16-2" title="2">  <span class="kw">type</span> <span class="dt">FunctorConstraint</span> <span class="dt">Node</span> <span class="ot">=</span> <span class="dt">Valued</span></a>
<a class="sourceLine" id="cb16-3" title="3"></a>
<a class="sourceLine" id="cb16-4" title="4">  fmapC</a>
<a class="sourceLine" id="cb16-5" title="5"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a, <span class="dt">Valued</span> b )</a>
<a class="sourceLine" id="cb16-6" title="6">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Node</span> a <span class="ot">-&gt;</span> <span class="dt">Node</span> b</a>
<a class="sourceLine" id="cb16-7" title="7">  fmapC f x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-8" title="8">    <span class="dt">Node2</span> _ u1 u2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb16-9" title="9">      node2 (f u1) (f u2)</a>
<a class="sourceLine" id="cb16-10" title="10">    <span class="dt">Node3</span> _ u1 u2 u3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb16-11" title="11">      node3 (f u1) (f u2) (f u3)</a></code></pre></div>
<p>And <code>Node</code> is foldable.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">Node</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-2" title="2">  toList</a>
<a class="sourceLine" id="cb17-3" title="3"><span class="ot">    ::</span> <span class="dt">Node</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb17-4" title="4">  toList w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-5" title="5">    <span class="dt">Node2</span> _ a1 a2 <span class="ot">-&gt;</span> [a1, a2]</a>
<a class="sourceLine" id="cb17-6" title="6">    <span class="dt">Node3</span> _ a1 a2 a3 <span class="ot">-&gt;</span> [a1, a2, a3]</a>
<a class="sourceLine" id="cb17-7" title="7"></a>
<a class="sourceLine" id="cb17-8" title="8">  <span class="fu">foldr</span></a>
<a class="sourceLine" id="cb17-9" title="9"><span class="ot">    ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Node</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb17-10" title="10">  <span class="fu">foldr</span> f b w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-11" title="11">    <span class="dt">Node2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-12" title="12">      f a1 (f a2 b)</a>
<a class="sourceLine" id="cb17-13" title="13">    <span class="dt">Node3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-14" title="14">      f a1 (f a2 (f a3 b))</a>
<a class="sourceLine" id="cb17-15" title="15"></a>
<a class="sourceLine" id="cb17-16" title="16">  <span class="fu">foldl</span></a>
<a class="sourceLine" id="cb17-17" title="17"><span class="ot">    ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Node</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb17-18" title="18">  <span class="fu">foldl</span> f b w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-19" title="19">    <span class="dt">Node2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-20" title="20">      f (f b a1) a2</a>
<a class="sourceLine" id="cb17-21" title="21">    <span class="dt">Node3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb17-22" title="22">      f (f (f b a1) a2) a3</a></code></pre></div>
<p>And <code>Node</code> is a constrained traversable functor.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">instance</span> <span class="dt">ConstrainedTraversable</span> <span class="dt">Node</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-2" title="2">  traverseC</a>
<a class="sourceLine" id="cb18-3" title="3"><span class="ot">    ::</span> ( <span class="dt">Applicative</span> f, <span class="dt">Valued</span> a, <span class="dt">Valued</span> b )</a>
<a class="sourceLine" id="cb18-4" title="4">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">Node</span> a <span class="ot">-&gt;</span> f (<span class="dt">Node</span> b)</a>
<a class="sourceLine" id="cb18-5" title="5">  traverseC f w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-6" title="6">    <span class="dt">Node2</span> _ u1 u2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-7" title="7">      node2 <span class="op">&lt;$&gt;</span> f u1 <span class="op">&lt;*&gt;</span> f u2</a>
<a class="sourceLine" id="cb18-8" title="8">    <span class="dt">Node3</span> _ u1 u2 u3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-9" title="9">      node3 <span class="op">&lt;$&gt;</span> f u1 <span class="op">&lt;*&gt;</span> f u2 <span class="op">&lt;*&gt;</span> f u3</a>
<a class="sourceLine" id="cb18-10" title="10"></a>
<a class="sourceLine" id="cb18-11" title="11">  sequenceAC</a>
<a class="sourceLine" id="cb18-12" title="12"><span class="ot">    ::</span> ( <span class="dt">Applicative</span> f, <span class="dt">Valued</span> a, <span class="dt">Valued</span> (f a) )</a>
<a class="sourceLine" id="cb18-13" title="13">    <span class="ot">=&gt;</span> <span class="dt">Node</span> (f a) <span class="ot">-&gt;</span> f (<span class="dt">Node</span> a)</a>
<a class="sourceLine" id="cb18-14" title="14">  sequenceAC w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-15" title="15">    <span class="dt">Node2</span> _ u1 u2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-16" title="16">      <span class="fu">pure</span> node2 <span class="op">&lt;*&gt;</span> u1 <span class="op">&lt;*&gt;</span> u2</a>
<a class="sourceLine" id="cb18-17" title="17">    <span class="dt">Node3</span> _ u1 u2 u3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-18" title="18">      <span class="fu">pure</span> node3 <span class="op">&lt;*&gt;</span> u1 <span class="op">&lt;*&gt;</span> u2 <span class="op">&lt;*&gt;</span> u3</a></code></pre></div>
<p>Finally, note that <code>Node</code> can be thought of as a strict subset of <code>Some</code>. We use a helper function, <code>toSome</code>, to make this formal.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1">toSome</a>
<a class="sourceLine" id="cb19-2" title="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb19-3" title="3">  <span class="ot">=&gt;</span> <span class="dt">Node</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb19-4" title="4">toSome w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-5" title="5">  <span class="dt">Node2</span> v a1 a2    <span class="ot">-&gt;</span> <span class="dt">Only2</span> v a1 a2</a>
<a class="sourceLine" id="cb19-6" title="6">  <span class="dt">Node3</span> v a1 a2 a3 <span class="ot">-&gt;</span> <span class="dt">Only3</span> v a1 a2 a3</a></code></pre></div>
</section>
<section class="level2">
<h2>Finger Trees</h2>
<p>Now for the big show. A finger tree is either empty, or consists of a single node (with its cached value), or has some left and right fingers with a nested finger tree in the middle (with the cached product of their values). We separate the possibly empty and nonempty cases into distinct types; this will allow consumers of this module to enforce a non-emptiness constraint on finger trees at the type level.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">data</span> <span class="dt">FingerTree</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-2" title="2">  <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb20-3" title="3"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb20-4" title="4">    <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb20-5" title="5">  <span class="dt">NonEmpty</span></a>
<a class="sourceLine" id="cb20-6" title="6"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb20-7" title="7">    <span class="ot">=&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb20-8" title="8">    <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb20-9" title="9"></a>
<a class="sourceLine" id="cb20-10" title="10"><span class="kw">deriving</span> <span class="kw">instance</span> (<span class="dt">Eq</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">FingerTree</span> a)</a>
<a class="sourceLine" id="cb20-11" title="11"></a>
<a class="sourceLine" id="cb20-12" title="12"><span class="kw">instance</span> (<span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">FingerTree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-13" title="13">  <span class="fu">show</span> x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb20-14" title="14">    <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="st">&quot;Empty&quot;</span></a>
<a class="sourceLine" id="cb20-15" title="15">    <span class="dt">NonEmpty</span> w <span class="ot">-&gt;</span> <span class="st">&quot;NonEmpty $ &quot;</span> <span class="op">++</span> <span class="fu">show</span> w</a>
<a class="sourceLine" id="cb20-16" title="16"></a>
<a class="sourceLine" id="cb20-17" title="17"><span class="kw">data</span> <span class="dt">NonEmptyFingerTree</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-18" title="18">  <span class="dt">Leaf</span></a>
<a class="sourceLine" id="cb20-19" title="19"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb20-20" title="20">    <span class="ot">=&gt;</span> <span class="dt">Value</span> a</a>
<a class="sourceLine" id="cb20-21" title="21">    <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb20-22" title="22">    <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb20-23" title="23">  <span class="dt">Branch</span></a>
<a class="sourceLine" id="cb20-24" title="24"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb20-25" title="25">    <span class="ot">=&gt;</span> <span class="dt">Value</span> a</a>
<a class="sourceLine" id="cb20-26" title="26">    <span class="ot">-&gt;</span> <span class="dt">Some</span> a                <span class="co">-- left fingers</span></a>
<a class="sourceLine" id="cb20-27" title="27">    <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> (<span class="dt">Node</span> a)   <span class="co">-- nested tree</span></a>
<a class="sourceLine" id="cb20-28" title="28">    <span class="ot">-&gt;</span> <span class="dt">Some</span> a                <span class="co">-- right fingers</span></a>
<a class="sourceLine" id="cb20-29" title="29">    <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a></code></pre></div>
<p>Both versions of finger trees are constrained containers; we will use this to implement a decent chunk of their API using classes.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">instance</span> <span class="dt">Container</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-2" title="2">  <span class="kw">type</span> <span class="dt">ContainerConstraint</span> <span class="dt">NonEmptyFingerTree</span> <span class="ot">=</span> <span class="dt">Valued</span></a>
<a class="sourceLine" id="cb21-3" title="3"></a>
<a class="sourceLine" id="cb21-4" title="4"><span class="kw">instance</span> <span class="dt">Container</span> <span class="dt">FingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb21-5" title="5">  <span class="kw">type</span> <span class="dt">ContainerConstraint</span> <span class="dt">FingerTree</span> <span class="ot">=</span> <span class="dt">Valued</span></a></code></pre></div>
<p>First, finger trees inherit a valuation from their item type.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">instance</span> (<span class="dt">Valued</span> a) <span class="ot">=&gt;</span> <span class="dt">Valued</span> (<span class="dt">FingerTree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-2" title="2">  <span class="kw">type</span> <span class="dt">Value</span> (<span class="dt">FingerTree</span> a) <span class="ot">=</span> <span class="dt">Value</span> a</a>
<a class="sourceLine" id="cb22-3" title="3"></a>
<a class="sourceLine" id="cb22-4" title="4"><span class="ot">  value ::</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">Value</span> (<span class="dt">FingerTree</span> a)</a>
<a class="sourceLine" id="cb22-5" title="5">  value w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-6" title="6">    <span class="dt">Empty</span>      <span class="ot">-&gt;</span> <span class="fu">mempty</span></a>
<a class="sourceLine" id="cb22-7" title="7">    <span class="dt">NonEmpty</span> x <span class="ot">-&gt;</span> value x</a>
<a class="sourceLine" id="cb22-8" title="8"></a>
<a class="sourceLine" id="cb22-9" title="9"><span class="kw">instance</span> (<span class="dt">Valued</span> a) <span class="ot">=&gt;</span> <span class="dt">Valued</span> (<span class="dt">NonEmptyFingerTree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb22-10" title="10">  <span class="kw">type</span> <span class="dt">Value</span> (<span class="dt">NonEmptyFingerTree</span> a) <span class="ot">=</span> <span class="dt">Value</span> a</a>
<a class="sourceLine" id="cb22-11" title="11"></a>
<a class="sourceLine" id="cb22-12" title="12"><span class="ot">  value ::</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">Value</span> (<span class="dt">NonEmptyFingerTree</span> a)</a>
<a class="sourceLine" id="cb22-13" title="13">  value w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-14" title="14">    <span class="dt">Leaf</span> v _       <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb22-15" title="15">    <span class="dt">Branch</span> v _ _ _ <span class="ot">-&gt;</span> v</a></code></pre></div>
<p>The nonempty finger trees form a subset of the possibly empty finger trees. We can express this using the <code>Subset</code> class.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">instance</span> <span class="dt">Subset</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" title="2">  <span class="kw">type</span> <span class="dt">SupersetOf</span> <span class="dt">NonEmptyFingerTree</span> <span class="ot">=</span> <span class="dt">FingerTree</span></a>
<a class="sourceLine" id="cb23-3" title="3"></a>
<a class="sourceLine" id="cb23-4" title="4">  inject</a>
<a class="sourceLine" id="cb23-5" title="5"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb23-6" title="6">    <span class="ot">=&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb23-7" title="7">  inject <span class="ot">=</span> <span class="dt">NonEmpty</span></a>
<a class="sourceLine" id="cb23-8" title="8"></a>
<a class="sourceLine" id="cb23-9" title="9">  restrict</a>
<a class="sourceLine" id="cb23-10" title="10"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb23-11" title="11">    <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">NonEmptyFingerTree</span> a)</a>
<a class="sourceLine" id="cb23-12" title="12">  restrict x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-13" title="13">    <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb23-14" title="14">    <span class="dt">NonEmpty</span> w <span class="ot">-&gt;</span> <span class="dt">Just</span> w</a></code></pre></div>
<p>It isn't too surprising that we have a <code>Foldable</code> instance for finger trees.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">FingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-2" title="2">  toList</a>
<a class="sourceLine" id="cb24-3" title="3"><span class="ot">    ::</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb24-4" title="4">  toList w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-5" title="5">    <span class="dt">Empty</span>      <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb24-6" title="6">    <span class="dt">NonEmpty</span> z <span class="ot">-&gt;</span> toList z</a>
<a class="sourceLine" id="cb24-7" title="7"></a>
<a class="sourceLine" id="cb24-8" title="8">  <span class="fu">foldr</span></a>
<a class="sourceLine" id="cb24-9" title="9"><span class="ot">    ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb24-10" title="10">  <span class="fu">foldr</span> f b w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-11" title="11">    <span class="dt">Empty</span>      <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb24-12" title="12">    <span class="dt">NonEmpty</span> z <span class="ot">-&gt;</span> <span class="fu">foldr</span> f b z</a>
<a class="sourceLine" id="cb24-13" title="13"></a>
<a class="sourceLine" id="cb24-14" title="14">  <span class="fu">foldl</span></a>
<a class="sourceLine" id="cb24-15" title="15"><span class="ot">    ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb24-16" title="16">  <span class="fu">foldl</span> f b w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-17" title="17">    <span class="dt">Empty</span>      <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb24-18" title="18">    <span class="dt">NonEmpty</span> z <span class="ot">-&gt;</span> <span class="fu">foldl</span> f b z</a>
<a class="sourceLine" id="cb24-19" title="19"></a>
<a class="sourceLine" id="cb24-20" title="20"><span class="kw">instance</span> <span class="dt">Foldable</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-21" title="21">  toList</a>
<a class="sourceLine" id="cb24-22" title="22"><span class="ot">    ::</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb24-23" title="23">  toList z <span class="ot">=</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-24" title="24">    <span class="dt">Leaf</span> _ a             <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb24-25" title="25">    <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span> <span class="fu">concat</span></a>
<a class="sourceLine" id="cb24-26" title="26">      [ toList as1, <span class="fu">concatMap</span> toList as2, toList as3 ]</a>
<a class="sourceLine" id="cb24-27" title="27"></a>
<a class="sourceLine" id="cb24-28" title="28">  <span class="fu">foldr</span></a>
<a class="sourceLine" id="cb24-29" title="29"><span class="ot">    ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb24-30" title="30">  <span class="fu">foldr</span> f b z <span class="ot">=</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-31" title="31">    <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> f a b</a>
<a class="sourceLine" id="cb24-32" title="32">    <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-33" title="33">      <span class="fu">foldr</span> f</a>
<a class="sourceLine" id="cb24-34" title="34">        (<span class="fu">foldr</span> (<span class="fu">flip</span> (<span class="fu">foldr</span> f)) (<span class="fu">foldr</span> f b as3) as2) as1</a>
<a class="sourceLine" id="cb24-35" title="35"></a>
<a class="sourceLine" id="cb24-36" title="36">  <span class="fu">foldl</span></a>
<a class="sourceLine" id="cb24-37" title="37"><span class="ot">    ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb24-38" title="38">  <span class="fu">foldl</span> f b z <span class="ot">=</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb24-39" title="39">    <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> f b a</a>
<a class="sourceLine" id="cb24-40" title="40">    <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb24-41" title="41">      <span class="fu">foldl</span> f</a>
<a class="sourceLine" id="cb24-42" title="42">        (<span class="fu">foldl</span> (<span class="fu">foldl</span> f) (<span class="fu">foldl</span> f b as1) as2) as3</a></code></pre></div>
<p>Note that we didn't derive the <code>Eq</code> instance for nonempty finger trees. This is because in some sense the tree structure itself is only incidental, used for maintaining the fingers and caching values. The meat of the structure is the left-to-right traversal of the leaf nodes and fingers, and the derived (structural) equality instance would be too granular. To get around this we'll instead check for equality on <code>FingerTree</code>s by converting to lists first, using the <code>Foldable</code> instance.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1"><span class="kw">instance</span> (<span class="dt">Eq</span> a, <span class="dt">Valued</span> a) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">NonEmptyFingerTree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb25-2" title="2">  u <span class="op">==</span> v <span class="ot">=</span> (toList u) <span class="op">==</span> (toList v)</a></code></pre></div>
<p>Next we define some basic constructors for finger trees. The relationship between the nonempty and possibly empty variants is formalized by the <code>NonEmpty</code> class.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">instance</span> <span class="dt">NonEmpty</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-2" title="2">  empty</a>
<a class="sourceLine" id="cb26-3" title="3"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb26-4" title="4">    <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb26-5" title="5">  empty <span class="ot">=</span> <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb26-6" title="6"></a>
<a class="sourceLine" id="cb26-7" title="7">  isEmpty</a>
<a class="sourceLine" id="cb26-8" title="8"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb26-9" title="9">    <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb26-10" title="10">  isEmpty x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb26-11" title="11">    <span class="dt">Empty</span>      <span class="ot">-&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb26-12" title="12">    <span class="dt">NonEmpty</span> _ <span class="ot">-&gt;</span> <span class="dt">False</span></a></code></pre></div>
<p>And we also have <code>Singleton</code> instances for both variants. This class is inhabited by container types that can contain "only one item". Note how we make sure to respect the cached value invariant.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">instance</span> <span class="dt">Singleton</span> <span class="dt">FingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-2" title="2">  singleton</a>
<a class="sourceLine" id="cb27-3" title="3"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb27-4" title="4">    <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb27-5" title="5">  singleton <span class="ot">=</span> <span class="dt">NonEmpty</span> <span class="op">.</span> singleton</a>
<a class="sourceLine" id="cb27-6" title="6"></a>
<a class="sourceLine" id="cb27-7" title="7">  isSingleton</a>
<a class="sourceLine" id="cb27-8" title="8"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb27-9" title="9">    <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-10" title="10">  isSingleton x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb27-11" title="11">    <span class="dt">Empty</span>      <span class="ot">-&gt;</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb27-12" title="12">    <span class="dt">NonEmpty</span> w <span class="ot">-&gt;</span> isSingleton w</a>
<a class="sourceLine" id="cb27-13" title="13"></a>
<a class="sourceLine" id="cb27-14" title="14"><span class="kw">instance</span> <span class="dt">Singleton</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-15" title="15">  singleton</a>
<a class="sourceLine" id="cb27-16" title="16"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb27-17" title="17">    <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb27-18" title="18">  singleton a <span class="ot">=</span> <span class="dt">Leaf</span> m a</a>
<a class="sourceLine" id="cb27-19" title="19">    <span class="kw">where</span> m <span class="ot">=</span> value a</a>
<a class="sourceLine" id="cb27-20" title="20"></a>
<a class="sourceLine" id="cb27-21" title="21">  isSingleton</a>
<a class="sourceLine" id="cb27-22" title="22"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb27-23" title="23">    <span class="ot">=&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb27-24" title="24">  isSingleton x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb27-25" title="25">    <span class="dt">Leaf</span> _ _ <span class="ot">-&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb27-26" title="26">    _        <span class="ot">-&gt;</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb27-27" title="27"></a>
<a class="sourceLine" id="cb27-28" title="28"><span class="kw">instance</span> <span class="dt">SubsetSingleton</span> <span class="dt">NonEmptyFingerTree</span></a>
<a class="sourceLine" id="cb27-29" title="29"><span class="kw">instance</span> <span class="dt">NonEmptySingleton</span> <span class="dt">NonEmptyFingerTree</span></a></code></pre></div>
<p>We also need constructors for the branched case for both tree variants.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1">branch</a>
<a class="sourceLine" id="cb28-2" title="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb28-3" title="3">  <span class="ot">=&gt;</span> <span class="dt">Some</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> (<span class="dt">Node</span> a) <span class="ot">-&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb28-4" title="4">  <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb28-5" title="5">branch heads mids lasts <span class="ot">=</span></a>
<a class="sourceLine" id="cb28-6" title="6">  <span class="dt">NonEmpty</span> <span class="op">$</span> branchNonEmpty heads mids lasts</a>
<a class="sourceLine" id="cb28-7" title="7"></a>
<a class="sourceLine" id="cb28-8" title="8">branchNonEmpty</a>
<a class="sourceLine" id="cb28-9" title="9"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb28-10" title="10">  <span class="ot">=&gt;</span> <span class="dt">Some</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> (<span class="dt">Node</span> a) <span class="ot">-&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb28-11" title="11">  <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb28-12" title="12">branchNonEmpty heads mids lasts <span class="ot">=</span></a>
<a class="sourceLine" id="cb28-13" title="13">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb28-14" title="14">     m <span class="ot">=</span> <span class="fu">mconcat</span></a>
<a class="sourceLine" id="cb28-15" title="15">       [ value heads</a>
<a class="sourceLine" id="cb28-16" title="16">       , value mids</a>
<a class="sourceLine" id="cb28-17" title="17">       , value lasts</a>
<a class="sourceLine" id="cb28-18" title="18">       ]</a>
<a class="sourceLine" id="cb28-19" title="19">  <span class="kw">in</span> <span class="dt">Branch</span> m heads mids lasts</a></code></pre></div>
<p>These constructors are useful inside this module, where we know (and need to know) the internal structure of a finger tree. But outside this module it will be more useful to expose constructors with less concrete names.</p>
<p>Like <code>Some</code> and <code>Node</code>, both finger tree constructors are constrained functors.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">instance</span> <span class="dt">ConstrainedFunctor</span> <span class="dt">FingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-2" title="2">  <span class="kw">type</span> <span class="dt">FunctorConstraint</span> <span class="dt">FingerTree</span> <span class="ot">=</span> <span class="dt">Valued</span></a>
<a class="sourceLine" id="cb29-3" title="3"></a>
<a class="sourceLine" id="cb29-4" title="4">  fmapC</a>
<a class="sourceLine" id="cb29-5" title="5"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a, <span class="dt">Valued</span> b )</a>
<a class="sourceLine" id="cb29-6" title="6">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> b</a>
<a class="sourceLine" id="cb29-7" title="7">  fmapC f x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb29-8" title="8">    <span class="dt">Empty</span>      <span class="ot">-&gt;</span> empty</a>
<a class="sourceLine" id="cb29-9" title="9">    <span class="dt">NonEmpty</span> z <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> <span class="op">$</span> fmapC f z</a>
<a class="sourceLine" id="cb29-10" title="10"></a>
<a class="sourceLine" id="cb29-11" title="11"><span class="kw">instance</span> <span class="dt">ConstrainedFunctor</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-12" title="12">  <span class="kw">type</span> <span class="dt">FunctorConstraint</span> <span class="dt">NonEmptyFingerTree</span> <span class="ot">=</span> <span class="dt">Valued</span></a>
<a class="sourceLine" id="cb29-13" title="13"></a>
<a class="sourceLine" id="cb29-14" title="14">  fmapC</a>
<a class="sourceLine" id="cb29-15" title="15"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a, <span class="dt">Valued</span> b )</a>
<a class="sourceLine" id="cb29-16" title="16">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> b</a>
<a class="sourceLine" id="cb29-17" title="17">  fmapC f x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb29-18" title="18">    <span class="dt">Leaf</span> _ a          <span class="ot">-&gt;</span> singleton (f a)</a>
<a class="sourceLine" id="cb29-19" title="19">    <span class="dt">Branch</span> _ as bs cs <span class="ot">-&gt;</span> branchNonEmpty</a>
<a class="sourceLine" id="cb29-20" title="20">      (fmapC f as)</a>
<a class="sourceLine" id="cb29-21" title="21">      (fmapC (fmapC f) bs)</a>
<a class="sourceLine" id="cb29-22" title="22">      (fmapC f cs)</a></code></pre></div>
<p>In the constrained functor instance for nonempty finger trees, note that the type parameter of the outer appearance of <code>FingerTree</code> is simply <code>a</code>, while on the inner appearance it is <code>Node a</code>. This is polymorphic recursion, and it took me a while to wrap my head around what it means.</p>
<p>Both variants are also constrained traversable functors:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">instance</span> <span class="dt">ConstrainedTraversable</span> <span class="dt">FingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-2" title="2">  traverseC</a>
<a class="sourceLine" id="cb30-3" title="3"><span class="ot">    ::</span> ( <span class="dt">Applicative</span> f, <span class="dt">Valued</span> a, <span class="dt">Valued</span> b )</a>
<a class="sourceLine" id="cb30-4" title="4">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> f (<span class="dt">FingerTree</span> b)</a>
<a class="sourceLine" id="cb30-5" title="5">  traverseC f w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb30-6" title="6">    <span class="dt">Empty</span>      <span class="ot">-&gt;</span> <span class="fu">pure</span> empty</a>
<a class="sourceLine" id="cb30-7" title="7">    <span class="dt">NonEmpty</span> z <span class="ot">-&gt;</span> <span class="fu">fmap</span> <span class="dt">NonEmpty</span> <span class="op">$</span> traverseC f z</a>
<a class="sourceLine" id="cb30-8" title="8"></a>
<a class="sourceLine" id="cb30-9" title="9">  sequenceAC</a>
<a class="sourceLine" id="cb30-10" title="10"><span class="ot">    ::</span> ( <span class="dt">Applicative</span> f, <span class="dt">Valued</span> a, <span class="dt">Valued</span> (f a) )</a>
<a class="sourceLine" id="cb30-11" title="11">    <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> (f a) <span class="ot">-&gt;</span> f (<span class="dt">FingerTree</span> a)</a>
<a class="sourceLine" id="cb30-12" title="12">  sequenceAC w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb30-13" title="13">    <span class="dt">Empty</span>      <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="dt">Empty</span></a>
<a class="sourceLine" id="cb30-14" title="14">    <span class="dt">NonEmpty</span> z <span class="ot">-&gt;</span> <span class="fu">fmap</span> <span class="dt">NonEmpty</span> <span class="op">$</span> sequenceAC z</a>
<a class="sourceLine" id="cb30-15" title="15"></a>
<a class="sourceLine" id="cb30-16" title="16"><span class="kw">instance</span> <span class="dt">ConstrainedTraversable</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-17" title="17">  traverseC</a>
<a class="sourceLine" id="cb30-18" title="18"><span class="ot">    ::</span> ( <span class="dt">Applicative</span> f, <span class="dt">Valued</span> a, <span class="dt">Valued</span> b )</a>
<a class="sourceLine" id="cb30-19" title="19">    <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> f (<span class="dt">NonEmptyFingerTree</span> b)</a>
<a class="sourceLine" id="cb30-20" title="20">  traverseC f w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb30-21" title="21">    <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb30-22" title="22">      singleton <span class="op">&lt;$&gt;</span> f a</a>
<a class="sourceLine" id="cb30-23" title="23">    <span class="dt">Branch</span> _ as bs cs <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb30-24" title="24">      branchNonEmpty</a>
<a class="sourceLine" id="cb30-25" title="25">        <span class="op">&lt;$&gt;</span> traverseC f as</a>
<a class="sourceLine" id="cb30-26" title="26">        <span class="op">&lt;*&gt;</span> traverseC (traverseC f) bs</a>
<a class="sourceLine" id="cb30-27" title="27">        <span class="op">&lt;*&gt;</span> traverseC f cs</a>
<a class="sourceLine" id="cb30-28" title="28"></a>
<a class="sourceLine" id="cb30-29" title="29">  sequenceAC</a>
<a class="sourceLine" id="cb30-30" title="30"><span class="ot">    ::</span> ( <span class="dt">Applicative</span> f, <span class="dt">Valued</span> a, <span class="dt">Valued</span> (f a) )</a>
<a class="sourceLine" id="cb30-31" title="31">    <span class="ot">=&gt;</span> <span class="dt">NonEmptyFingerTree</span> (f a) <span class="ot">-&gt;</span> f (<span class="dt">NonEmptyFingerTree</span> a)</a>
<a class="sourceLine" id="cb30-32" title="32">  sequenceAC w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb30-33" title="33">    <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb30-34" title="34">      <span class="fu">pure</span> singleton <span class="op">&lt;*&gt;</span> a</a>
<a class="sourceLine" id="cb30-35" title="35">    <span class="dt">Branch</span> _ as bs cs <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb30-36" title="36">      <span class="fu">pure</span> branchNonEmpty</a>
<a class="sourceLine" id="cb30-37" title="37">        <span class="op">&lt;*&gt;</span> sequenceAC as</a>
<a class="sourceLine" id="cb30-38" title="38">        <span class="op">&lt;*&gt;</span> traverseC sequenceAC bs</a>
<a class="sourceLine" id="cb30-39" title="39">        <span class="op">&lt;*&gt;</span> sequenceAC cs</a></code></pre></div>
<p>Finally, just as every <code>Node</code> can be converted into a <code>Some</code>, every <code>Some</code> can be converted to a <code>FingerTree</code>. This conversion will come in handy later so we define it here, but this code is not exposed outside of this module.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1">someToFingerTree</a>
<a class="sourceLine" id="cb31-2" title="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb31-3" title="3">  <span class="ot">=&gt;</span> <span class="dt">Some</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb31-4" title="4">someToFingerTree w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb31-5" title="5">  <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb31-6" title="6">    singleton a1</a>
<a class="sourceLine" id="cb31-7" title="7">  <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb31-8" title="8">    branch (only1 a1) empty (only1 a2)</a>
<a class="sourceLine" id="cb31-9" title="9">  <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb31-10" title="10">    branch (only2 a1 a2) empty (only1 a3)</a>
<a class="sourceLine" id="cb31-11" title="11">  <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb31-12" title="12">    branch (only2 a1 a2) empty (only2 a3 a4)</a>
<a class="sourceLine" id="cb31-13" title="13"></a>
<a class="sourceLine" id="cb31-14" title="14">maybeSomeToFingerTree</a>
<a class="sourceLine" id="cb31-15" title="15"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb31-16" title="16">  <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Some</span> a) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb31-17" title="17">maybeSomeToFingerTree w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb31-18" title="18">  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> empty</a>
<a class="sourceLine" id="cb31-19" title="19">  <span class="dt">Just</span> z  <span class="ot">-&gt;</span> someToFingerTree z</a></code></pre></div>
</section>
<section class="level2">
<h2>Cons and Uncons</h2>
<p>In this section we'll implement four of the most important functions on finger trees, which efficiently build and decompose finger trees by adding or removing items from one of the ends.</p>
<p>The traditional name for appending an item to a list is <em>cons</em>, after the Lisp function for this operation. Given a nonempty finger tree, if the left end does not have a full complement of fingers then <code>cons</code> is a constant time operation. If it does, then we take some of the fingers and recursively <code>cons</code> them as a node to the inner tree. This is the first place where the magic numbers 4 and 3, for the numbers of fingers and children per node, respectively, become important. <code>cons</code> also has an inverse, called <code>uncons</code>.<span><label for="sn-2" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-2" class="margin-toggle"/><span class="sidenote">The inverseness here is not literal, but can be made so if instead of cons we consider the coproduct of cons with the constant <code>stump</code> function, but for our purposes here that's splitting hairs.<br />
<br />
</span></span></p>
<p><code>cons</code> and <code>uncons</code> on list-like structures satisfy several laws and so they are implemented using a type class. Note the signature of <code>uncons</code> returns the "rest of the structure" using the same type. This means we cannot uncons a non-empty finger tree with only one item in it. To get around this limitation we have a second class for unconsing types which inhabit <code>NonEmpty</code>.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">instance</span> <span class="dt">Cons</span> <span class="dt">FingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-2" title="2">  cons</a>
<a class="sourceLine" id="cb32-3" title="3"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb32-4" title="4">    <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb32-5" title="5">  cons a w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb32-6" title="6">    <span class="dt">Empty</span>      <span class="ot">-&gt;</span> singleton a</a>
<a class="sourceLine" id="cb32-7" title="7">    <span class="dt">NonEmpty</span> z <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> <span class="op">$</span> cons a z</a>
<a class="sourceLine" id="cb32-8" title="8"></a>
<a class="sourceLine" id="cb32-9" title="9">  uncons</a>
<a class="sourceLine" id="cb32-10" title="10"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb32-11" title="11">    <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb32-12" title="12">    <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">FingerTree</span> a)</a>
<a class="sourceLine" id="cb32-13" title="13">  uncons w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb32-14" title="14">    <span class="dt">Empty</span>      <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb32-15" title="15">    <span class="dt">NonEmpty</span> z <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">$</span> unconsNonEmpty z</a>
<a class="sourceLine" id="cb32-16" title="16"></a>
<a class="sourceLine" id="cb32-17" title="17"><span class="kw">instance</span> <span class="dt">SingletonCons</span> <span class="dt">FingerTree</span></a>
<a class="sourceLine" id="cb32-18" title="18"></a>
<a class="sourceLine" id="cb32-19" title="19"><span class="kw">instance</span> <span class="dt">Cons</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb32-20" title="20">  cons</a>
<a class="sourceLine" id="cb32-21" title="21"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb32-22" title="22">    <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb32-23" title="23">  cons u z <span class="ot">=</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb32-24" title="24">    <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-25" title="25">      branchNonEmpty (only1 u) empty (only1 a)</a>
<a class="sourceLine" id="cb32-26" title="26">    <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span> <span class="kw">case</span> as1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb32-27" title="27">      <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-28" title="28">        branchNonEmpty (only2 u a1) as2 as3</a>
<a class="sourceLine" id="cb32-29" title="29">      <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-30" title="30">        branchNonEmpty (only3 u a1 a2) as2 as3</a>
<a class="sourceLine" id="cb32-31" title="31">      <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-32" title="32">        branchNonEmpty (only4 u a1 a2 a3) as2 as3</a>
<a class="sourceLine" id="cb32-33" title="33">      <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-34" title="34">        branchNonEmpty (only2 u a1) (cons (node3 a2 a3 a4) as2) as3</a>
<a class="sourceLine" id="cb32-35" title="35"></a>
<a class="sourceLine" id="cb32-36" title="36">  uncons</a>
<a class="sourceLine" id="cb32-37" title="37"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb32-38" title="38">    <span class="ot">=&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">NonEmptyFingerTree</span> a)</a>
<a class="sourceLine" id="cb32-39" title="39">  uncons w <span class="ot">=</span></a>
<a class="sourceLine" id="cb32-40" title="40">    <span class="kw">let</span> (a, z) <span class="ot">=</span> unconsNonEmpty w</a>
<a class="sourceLine" id="cb32-41" title="41">    <span class="kw">in</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb32-42" title="42">      <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb32-43" title="43">      <span class="dt">NonEmpty</span> u <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, u)</a>
<a class="sourceLine" id="cb32-44" title="44"></a>
<a class="sourceLine" id="cb32-45" title="45"><span class="kw">instance</span> <span class="dt">SingletonCons</span> <span class="dt">NonEmptyFingerTree</span></a>
<a class="sourceLine" id="cb32-46" title="46"><span class="kw">instance</span> <span class="dt">SubsetCons</span> <span class="dt">NonEmptyFingerTree</span></a></code></pre></div>
<p>The real work happens in <code>unconsNonEmpty</code>. Like <code>cons</code>, <code>unconsNonEmpty</code> is very fast if the left side of the tree has fingers to spare. But if not, we have to do a kind of recursive borrowing.<span><label for="sn-3" class="margin-toggle sidenote-number"></label><input type="checkbox" id="sn-3" class="margin-toggle"/><span class="sidenote">Think "borrow" as in the usual algorithm for subtracting natural numbers.<br />
<br />
</span></span> This borrowing function will be useful on its own later in this module, so we give it its own name.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" title="1"><span class="kw">instance</span> <span class="dt">UnconsNonEmpty</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-2" title="2">  unconsNonEmpty</a>
<a class="sourceLine" id="cb33-3" title="3"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb33-4" title="4">    <span class="ot">=&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb33-5" title="5">    <span class="ot">-&gt;</span> (a, <span class="dt">FingerTree</span> a)</a>
<a class="sourceLine" id="cb33-6" title="6">  unconsNonEmpty w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb33-7" title="7">    <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> (a, empty)</a>
<a class="sourceLine" id="cb33-8" title="8">    <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb33-9" title="9">      <span class="kw">let</span> (a, as) <span class="ot">=</span> unconsSome as1</a>
<a class="sourceLine" id="cb33-10" title="10">      <span class="kw">in</span> (a, borrowL as as2 as3)</a>
<a class="sourceLine" id="cb33-11" title="11">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb33-12" title="12">      unconsSome</a>
<a class="sourceLine" id="cb33-13" title="13"><span class="ot">        ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb33-14" title="14">        <span class="ot">=&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb33-15" title="15">        <span class="ot">-&gt;</span> (a, <span class="dt">Maybe</span> (<span class="dt">Some</span> a))</a>
<a class="sourceLine" id="cb33-16" title="16">      unconsSome w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb33-17" title="17">        <span class="dt">Only1</span> _ a1          <span class="ot">-&gt;</span> (a1, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb33-18" title="18">        <span class="dt">Only2</span> _ a1 a2       <span class="ot">-&gt;</span> (a1, <span class="dt">Just</span> (only1 a2))</a>
<a class="sourceLine" id="cb33-19" title="19">        <span class="dt">Only3</span> _ a1 a2 a3    <span class="ot">-&gt;</span> (a1, <span class="dt">Just</span> (only2 a2 a3))</a>
<a class="sourceLine" id="cb33-20" title="20">        <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span> (a1, <span class="dt">Just</span> (only3 a2 a3 a4))</a>
<a class="sourceLine" id="cb33-21" title="21"></a>
<a class="sourceLine" id="cb33-22" title="22">borrowL</a>
<a class="sourceLine" id="cb33-23" title="23"><span class="ot"> ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb33-24" title="24"> <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Some</span> a)</a>
<a class="sourceLine" id="cb33-25" title="25"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> (<span class="dt">Node</span> a)</a>
<a class="sourceLine" id="cb33-26" title="26"> <span class="ot">-&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb33-27" title="27"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb33-28" title="28">borrowL w as2 as3 <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb33-29" title="29"> <span class="dt">Just</span> as1 <span class="ot">-&gt;</span> branch as1 as2 as3</a>
<a class="sourceLine" id="cb33-30" title="30"> <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">case</span> uncons as2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb33-31" title="31">   <span class="dt">Nothing</span> <span class="ot">-&gt;</span> someToFingerTree as3</a>
<a class="sourceLine" id="cb33-32" title="32">   <span class="dt">Just</span> (a, as) <span class="ot">-&gt;</span> branch (toSome a) as as3</a></code></pre></div>
<p>The mirror operations -- appending and decomposing on the right -- are defined similarly. These are called <code>snoc</code> and <code>unsnoc</code>.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1"><span class="kw">instance</span> <span class="dt">Snoc</span> <span class="dt">FingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-2" title="2">  snoc</a>
<a class="sourceLine" id="cb34-3" title="3"><span class="ot">   ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb34-4" title="4">   <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb34-5" title="5">  snoc a w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb34-6" title="6">    <span class="dt">Empty</span> <span class="ot">-&gt;</span> singleton a</a>
<a class="sourceLine" id="cb34-7" title="7">    <span class="dt">NonEmpty</span> z <span class="ot">-&gt;</span> <span class="dt">NonEmpty</span> <span class="op">$</span> snoc a z</a>
<a class="sourceLine" id="cb34-8" title="8"></a>
<a class="sourceLine" id="cb34-9" title="9">  unsnoc</a>
<a class="sourceLine" id="cb34-10" title="10"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb34-11" title="11">    <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb34-12" title="12">    <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">FingerTree</span> a)</a>
<a class="sourceLine" id="cb34-13" title="13">  unsnoc w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb34-14" title="14">    <span class="dt">Empty</span>      <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb34-15" title="15">    <span class="dt">NonEmpty</span> z <span class="ot">-&gt;</span> <span class="dt">Just</span> <span class="op">$</span> unsnocNonEmpty z</a>
<a class="sourceLine" id="cb34-16" title="16"></a>
<a class="sourceLine" id="cb34-17" title="17"><span class="kw">instance</span> <span class="dt">SingletonSnoc</span> <span class="dt">FingerTree</span></a>
<a class="sourceLine" id="cb34-18" title="18"><span class="kw">instance</span> <span class="dt">ConsSnoc</span> <span class="dt">FingerTree</span></a>
<a class="sourceLine" id="cb34-19" title="19"></a>
<a class="sourceLine" id="cb34-20" title="20"><span class="kw">instance</span> <span class="dt">Snoc</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb34-21" title="21">  snoc</a>
<a class="sourceLine" id="cb34-22" title="22"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb34-23" title="23">    <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb34-24" title="24">  snoc u z <span class="ot">=</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb34-25" title="25">    <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb34-26" title="26">      branchNonEmpty (only1 a) empty (only1 u)</a>
<a class="sourceLine" id="cb34-27" title="27">    <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span> <span class="kw">case</span> as3 <span class="kw">of</span></a>
<a class="sourceLine" id="cb34-28" title="28">      <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb34-29" title="29">        branchNonEmpty as1 as2 (only2 a1 u)</a>
<a class="sourceLine" id="cb34-30" title="30">      <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb34-31" title="31">        branchNonEmpty as1 as2 (only3 a1 a2 u)</a>
<a class="sourceLine" id="cb34-32" title="32">      <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb34-33" title="33">        branchNonEmpty as1 as2 (only4 a1 a2 a3 u)</a>
<a class="sourceLine" id="cb34-34" title="34">      <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb34-35" title="35">        branchNonEmpty as1 (snoc (node3 a1 a2 a3) as2) (only2 a4 u)</a>
<a class="sourceLine" id="cb34-36" title="36"></a>
<a class="sourceLine" id="cb34-37" title="37">  unsnoc</a>
<a class="sourceLine" id="cb34-38" title="38"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb34-39" title="39">    <span class="ot">=&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">NonEmptyFingerTree</span> a)</a>
<a class="sourceLine" id="cb34-40" title="40">  unsnoc w <span class="ot">=</span></a>
<a class="sourceLine" id="cb34-41" title="41">    <span class="kw">let</span> (a, z) <span class="ot">=</span> unsnocNonEmpty w</a>
<a class="sourceLine" id="cb34-42" title="42">    <span class="kw">in</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb34-43" title="43">      <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb34-44" title="44">      <span class="dt">NonEmpty</span> u <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, u)</a>
<a class="sourceLine" id="cb34-45" title="45"></a>
<a class="sourceLine" id="cb34-46" title="46"><span class="kw">instance</span> <span class="dt">SingletonSnoc</span> <span class="dt">NonEmptyFingerTree</span></a>
<a class="sourceLine" id="cb34-47" title="47"><span class="kw">instance</span> <span class="dt">SubsetSnoc</span> <span class="dt">NonEmptyFingerTree</span></a>
<a class="sourceLine" id="cb34-48" title="48"><span class="kw">instance</span> <span class="dt">ConsSnoc</span> <span class="dt">NonEmptyFingerTree</span></a></code></pre></div>
<p>And <code>unsnocNonEmpty</code> is analogous to <code>unconsNonEmpty</code>, with a corresponding right-borrow.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" title="1"><span class="kw">instance</span> <span class="dt">UnsnocNonEmpty</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-2" title="2">  unsnocNonEmpty</a>
<a class="sourceLine" id="cb35-3" title="3"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb35-4" title="4">    <span class="ot">=&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb35-5" title="5">    <span class="ot">-&gt;</span> (a, <span class="dt">FingerTree</span> a)</a>
<a class="sourceLine" id="cb35-6" title="6">  unsnocNonEmpty z <span class="ot">=</span> <span class="kw">case</span> z <span class="kw">of</span></a>
<a class="sourceLine" id="cb35-7" title="7">    <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> (a, empty)</a>
<a class="sourceLine" id="cb35-8" title="8">    <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb35-9" title="9">      <span class="kw">let</span> (a, as) <span class="ot">=</span> unsnocSome as3</a>
<a class="sourceLine" id="cb35-10" title="10">      <span class="kw">in</span> (a, borrowR as1 as2 as)</a>
<a class="sourceLine" id="cb35-11" title="11">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-12" title="12">      unsnocSome</a>
<a class="sourceLine" id="cb35-13" title="13"><span class="ot">        ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb35-14" title="14">        <span class="ot">=&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb35-15" title="15">        <span class="ot">-&gt;</span> (a, <span class="dt">Maybe</span> (<span class="dt">Some</span> a))</a>
<a class="sourceLine" id="cb35-16" title="16">      unsnocSome w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb35-17" title="17">        <span class="dt">Only1</span> _ a1          <span class="ot">-&gt;</span> (a1, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb35-18" title="18">        <span class="dt">Only2</span> _ a1 a2       <span class="ot">-&gt;</span> (a2, <span class="dt">Just</span> (only1 a1))</a>
<a class="sourceLine" id="cb35-19" title="19">        <span class="dt">Only3</span> _ a1 a2 a3    <span class="ot">-&gt;</span> (a3, <span class="dt">Just</span> (only2 a1 a2))</a>
<a class="sourceLine" id="cb35-20" title="20">        <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span> (a4, <span class="dt">Just</span> (only3 a1 a2 a3))</a>
<a class="sourceLine" id="cb35-21" title="21"></a>
<a class="sourceLine" id="cb35-22" title="22">borrowR</a>
<a class="sourceLine" id="cb35-23" title="23"><span class="ot"> ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb35-24" title="24"> <span class="ot">=&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb35-25" title="25"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> (<span class="dt">Node</span> a)</a>
<a class="sourceLine" id="cb35-26" title="26"> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Some</span> a)</a>
<a class="sourceLine" id="cb35-27" title="27"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb35-28" title="28">borrowR as1 as2 w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb35-29" title="29"> <span class="dt">Just</span> as3 <span class="ot">-&gt;</span> branch as1 as2 as3</a>
<a class="sourceLine" id="cb35-30" title="30"> <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">case</span> unsnoc as2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb35-31" title="31">   <span class="dt">Nothing</span> <span class="ot">-&gt;</span> someToFingerTree as1</a>
<a class="sourceLine" id="cb35-32" title="32">   <span class="dt">Just</span> (a, as) <span class="ot">-&gt;</span> branch as1 as (toSome a)</a></code></pre></div>
<p>Now's a good time for some examples.</p>
<div class="doctest">
<div class="sourceCode" id="cb36"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb36-2" title="2"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb36-3" title="3"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb36-4" title="4"><span class="co">--   x :: FingerTree (Counted Char)</span></a>
<a class="sourceLine" id="cb36-5" title="5"><span class="co">--   x = fromList [ Counted &#39;a&#39;, Counted &#39;b&#39;, Counted &#39;c&#39; ]</span></a>
<a class="sourceLine" id="cb36-6" title="6"><span class="co">-- in uncons x</span></a>
<a class="sourceLine" id="cb36-7" title="7"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb36-8" title="8"><span class="co">-- Just (Counted &#39;a&#39;,NonEmpty $ fromList [Counted &#39;b&#39;,Counted &#39;c&#39;])</span></a>
<a class="sourceLine" id="cb36-9" title="9"><span class="co">--</span></a>
<a class="sourceLine" id="cb36-10" title="10"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb36-11" title="11"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb36-12" title="12"><span class="co">--   x :: FingerTree (Counted Char)</span></a>
<a class="sourceLine" id="cb36-13" title="13"><span class="co">--   x = fromList [ Counted &#39;a&#39;, Counted &#39;b&#39;, Counted &#39;c&#39; ]</span></a>
<a class="sourceLine" id="cb36-14" title="14"><span class="co">-- in unsnoc x</span></a>
<a class="sourceLine" id="cb36-15" title="15"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb36-16" title="16"><span class="co">-- Just (Counted &#39;c&#39;,NonEmpty $ fromList [Counted &#39;a&#39;,Counted &#39;b&#39;])</span></a></code></pre></div>
</div>
<p>With <code>cons</code> and <code>snoc</code> in hand we can define some helper functions. These convert from ordinary lists to finger trees, and are useful for testing.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" title="1"><span class="kw">instance</span> <span class="dt">FromList</span> <span class="dt">FingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-2" title="2">  fromList</a>
<a class="sourceLine" id="cb37-3" title="3"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb37-4" title="4">    <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb37-5" title="5">  fromList <span class="ot">=</span> <span class="fu">foldr</span> cons empty</a>
<a class="sourceLine" id="cb37-6" title="6"></a>
<a class="sourceLine" id="cb37-7" title="7"><span class="kw">instance</span> <span class="dt">FromListMonoid</span> <span class="dt">FingerTree</span></a>
<a class="sourceLine" id="cb37-8" title="8"><span class="kw">instance</span> <span class="dt">FromListConsSnocReverse</span> <span class="dt">FingerTree</span></a>
<a class="sourceLine" id="cb37-9" title="9"></a>
<a class="sourceLine" id="cb37-10" title="10"><span class="kw">instance</span> <span class="dt">FromList</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb37-11" title="11">  fromList</a>
<a class="sourceLine" id="cb37-12" title="12"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb37-13" title="13">    <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb37-14" title="14">  fromList xs <span class="ot">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb37-15" title="15">    []   <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;FingerTree: fromList expects a nonempty argument&quot;</span></a>
<a class="sourceLine" id="cb37-16" title="16">    a<span class="op">:</span>as <span class="ot">-&gt;</span> foldl&#39; (<span class="fu">flip</span> snoc) (singleton a) as</a>
<a class="sourceLine" id="cb37-17" title="17"></a>
<a class="sourceLine" id="cb37-18" title="18"><span class="kw">instance</span> <span class="dt">FromListConsSnocReverse</span> <span class="dt">NonEmptyFingerTree</span></a></code></pre></div>
<p>With <code>fromList</code> in hand we can also give a convenient <code>Show</code> instance for nonempty finger trees. Note that the derived instance would include a lot of superfluous information about the internal structure of the tree.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1"><span class="kw">instance</span> (<span class="dt">Show</span> a, <span class="dt">Valued</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">NonEmptyFingerTree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb38-2" title="2">  <span class="fu">show</span> a <span class="ot">=</span> <span class="st">&quot;fromList &quot;</span> <span class="op">++</span> <span class="fu">show</span> (toList a)</a></code></pre></div>
<p>We can test our intuition so far with some examples.</p>
<div class="doctest">
<div class="sourceCode" id="cb39"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" title="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb39-2" title="2"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb39-3" title="3"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb39-4" title="4"><span class="co">--   x :: FingerTree (Counted Char)</span></a>
<a class="sourceLine" id="cb39-5" title="5"><span class="co">--   x = fromList [ Counted &#39;a&#39;, Counted &#39;b&#39;, Counted &#39;c&#39;]</span></a>
<a class="sourceLine" id="cb39-6" title="6"><span class="co">-- in x</span></a>
<a class="sourceLine" id="cb39-7" title="7"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb39-8" title="8"><span class="co">-- NonEmpty $ fromList [Counted &#39;a&#39;,Counted &#39;b&#39;,Counted &#39;c&#39;]</span></a>
<a class="sourceLine" id="cb39-9" title="9"><span class="co">--</span></a>
<a class="sourceLine" id="cb39-10" title="10"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb39-11" title="11"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb39-12" title="12"><span class="co">--   x :: FingerTree (Counted Char)</span></a>
<a class="sourceLine" id="cb39-13" title="13"><span class="co">--   x = fromList [ Counted &#39;b&#39;, Counted &#39;c&#39;, Counted &#39;d&#39; ]</span></a>
<a class="sourceLine" id="cb39-14" title="14"><span class="co">-- in cons (Counted &#39;a&#39;) x</span></a>
<a class="sourceLine" id="cb39-15" title="15"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb39-16" title="16"><span class="co">-- NonEmpty $ fromList [Counted &#39;a&#39;,Counted &#39;b&#39;,Counted &#39;c&#39;,Counted &#39;d&#39;]</span></a></code></pre></div>
</div>
<p>With <code>snoc</code> we can also reverse the tree.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" title="1"><span class="kw">instance</span> <span class="dt">Reverse</span> <span class="dt">FingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-2" title="2">  <span class="fu">reverse</span></a>
<a class="sourceLine" id="cb40-3" title="3"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb40-4" title="4">    <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb40-5" title="5">  <span class="fu">reverse</span> <span class="ot">=</span> <span class="fu">foldr</span> snoc empty</a>
<a class="sourceLine" id="cb40-6" title="6"></a>
<a class="sourceLine" id="cb40-7" title="7"><span class="kw">instance</span> <span class="dt">ReverseSemigroup</span> <span class="dt">FingerTree</span></a>
<a class="sourceLine" id="cb40-8" title="8"><span class="kw">instance</span> <span class="dt">ReverseMonoid</span> <span class="dt">FingerTree</span></a>
<a class="sourceLine" id="cb40-9" title="9"><span class="kw">instance</span> <span class="dt">ReverseSingleton</span> <span class="dt">FingerTree</span></a>
<a class="sourceLine" id="cb40-10" title="10"><span class="kw">instance</span> <span class="dt">ReverseConsSnoc</span> <span class="dt">FingerTree</span></a>
<a class="sourceLine" id="cb40-11" title="11"></a>
<a class="sourceLine" id="cb40-12" title="12"><span class="kw">instance</span> <span class="dt">Reverse</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-13" title="13">  <span class="fu">reverse</span></a>
<a class="sourceLine" id="cb40-14" title="14"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb40-15" title="15">    <span class="ot">=&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb40-16" title="16">  <span class="fu">reverse</span> x <span class="ot">=</span></a>
<a class="sourceLine" id="cb40-17" title="17">    <span class="kw">let</span> (a, as) <span class="ot">=</span> unsnocNonEmpty x</a>
<a class="sourceLine" id="cb40-18" title="18">    <span class="kw">in</span> <span class="kw">case</span> as <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-19" title="19">      <span class="dt">Empty</span> <span class="ot">-&gt;</span> singleton a</a>
<a class="sourceLine" id="cb40-20" title="20">      <span class="dt">NonEmpty</span> w <span class="ot">-&gt;</span> <span class="fu">foldr</span> snoc (singleton a) w</a>
<a class="sourceLine" id="cb40-21" title="21"></a>
<a class="sourceLine" id="cb40-22" title="22"><span class="kw">instance</span> <span class="dt">ReverseSemigroup</span> <span class="dt">NonEmptyFingerTree</span></a>
<a class="sourceLine" id="cb40-23" title="23"><span class="kw">instance</span> <span class="dt">ReverseSubset</span> <span class="dt">NonEmptyFingerTree</span></a>
<a class="sourceLine" id="cb40-24" title="24"><span class="kw">instance</span> <span class="dt">ReverseSingleton</span> <span class="dt">NonEmptyFingerTree</span></a>
<a class="sourceLine" id="cb40-25" title="25"><span class="kw">instance</span> <span class="dt">ReverseConsSnoc</span> <span class="dt">NonEmptyFingerTree</span></a></code></pre></div>
<p>For example:</p>
<div class="doctest">
<div class="sourceCode" id="cb41"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" title="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb41-2" title="2"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb41-3" title="3"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb41-4" title="4"><span class="co">--   x :: FingerTree (Counted Char)</span></a>
<a class="sourceLine" id="cb41-5" title="5"><span class="co">--   x = fromList [ Counted &#39;a&#39;, Counted &#39;b&#39; ]</span></a>
<a class="sourceLine" id="cb41-6" title="6"><span class="co">-- in reverse x</span></a>
<a class="sourceLine" id="cb41-7" title="7"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb41-8" title="8"><span class="co">-- NonEmpty $ fromList [Counted &#39;b&#39;,Counted &#39;a&#39;]</span></a>
<a class="sourceLine" id="cb41-9" title="9"><span class="co">--</span></a>
<a class="sourceLine" id="cb41-10" title="10"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb41-11" title="11"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb41-12" title="12"><span class="co">--   x :: FingerTree (Counted Char)</span></a>
<a class="sourceLine" id="cb41-13" title="13"><span class="co">--   x = fromList [ Counted &#39;a&#39;, Counted &#39;b&#39;, Counted &#39;c&#39; ]</span></a>
<a class="sourceLine" id="cb41-14" title="14"><span class="co">-- in reverse x</span></a>
<a class="sourceLine" id="cb41-15" title="15"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb41-16" title="16"><span class="co">-- NonEmpty $ fromList [Counted &#39;c&#39;,Counted &#39;b&#39;,Counted &#39;a&#39;]</span></a></code></pre></div>
</div>
<p>With <code>uncons</code>, we can define an alternate version of <code>toList</code> (from the <code>Foldable</code> class) that also returns the accumulated value annotations. This will be handy in a few places.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" title="1">toAnnotatedList</a>
<a class="sourceLine" id="cb42-2" title="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb42-3" title="3"> <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> [(a, <span class="dt">Value</span> a)]</a>
<a class="sourceLine" id="cb42-4" title="4">toAnnotatedList xs <span class="ot">=</span> foo <span class="fu">mempty</span> xs</a>
<a class="sourceLine" id="cb42-5" title="5"> <span class="kw">where</span></a>
<a class="sourceLine" id="cb42-6" title="6">   foo e z <span class="ot">=</span> <span class="kw">case</span> uncons z <span class="kw">of</span></a>
<a class="sourceLine" id="cb42-7" title="7">     <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb42-8" title="8">     <span class="dt">Just</span> (a, ys) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb42-9" title="9">       <span class="kw">let</span> u <span class="ot">=</span> e <span class="op">&lt;&gt;</span> value a</a>
<a class="sourceLine" id="cb42-10" title="10">       <span class="kw">in</span> (a, u) <span class="op">:</span> foo u ys</a></code></pre></div>
</section>
<section class="level2">
<h2>Concatenation</h2>
<p>Despite the name, finger trees are really list-like, and on such structures it's typically handy to be able to append one list to another. The fancy word for this is <em>concatenation</em>. Before defining concatenation proper we start with a generalized version that takes an additional list of elements to insert between the concatenands.</p>
<p>We're defining this using a class to avoid giving this operation different names for possibly empty and nonempty finger trees.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" title="1"><span class="kw">class</span> <span class="dt">ConcatWithList</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-2" title="2"><span class="ot">  concatWithList ::</span> (<span class="dt">Valued</span> a) <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb43-3" title="3"></a>
<a class="sourceLine" id="cb43-4" title="4"><span class="kw">instance</span> <span class="dt">ConcatWithList</span> <span class="dt">FingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-5" title="5">  concatWithList</a>
<a class="sourceLine" id="cb43-6" title="6"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb43-7" title="7">    <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb43-8" title="8">    <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb43-9" title="9">  concatWithList u as v <span class="ot">=</span> <span class="kw">case</span> u <span class="kw">of</span></a>
<a class="sourceLine" id="cb43-10" title="10">    <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="fu">foldr</span> cons v as</a>
<a class="sourceLine" id="cb43-11" title="11">    <span class="dt">NonEmpty</span> z <span class="ot">-&gt;</span> <span class="kw">case</span> v <span class="kw">of</span></a>
<a class="sourceLine" id="cb43-12" title="12">      <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="fu">foldl</span> (<span class="fu">flip</span> snoc) u as</a>
<a class="sourceLine" id="cb43-13" title="13">      <span class="dt">NonEmpty</span> w <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb43-14" title="14">        <span class="dt">NonEmpty</span> <span class="op">$</span> concatWithList z as w</a>
<a class="sourceLine" id="cb43-15" title="15"></a>
<a class="sourceLine" id="cb43-16" title="16"><span class="kw">instance</span> <span class="dt">ConcatWithList</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-17" title="17">  concatWithList</a>
<a class="sourceLine" id="cb43-18" title="18"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb43-19" title="19">    <span class="ot">=&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb43-20" title="20">    <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb43-21" title="21">  concatWithList u as v <span class="ot">=</span> <span class="kw">case</span> u <span class="kw">of</span></a>
<a class="sourceLine" id="cb43-22" title="22">    <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> cons a (<span class="fu">foldr</span> cons v as)</a>
<a class="sourceLine" id="cb43-23" title="23">    <span class="dt">Branch</span> _ us1 us2 us3 <span class="ot">-&gt;</span> <span class="kw">case</span> v <span class="kw">of</span></a>
<a class="sourceLine" id="cb43-24" title="24">      <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> snoc a (<span class="fu">foldl</span> (<span class="fu">flip</span> snoc) u as)</a>
<a class="sourceLine" id="cb43-25" title="25">      <span class="dt">Branch</span> _ vs1 vs2 vs3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb43-26" title="26">        <span class="kw">let</span> ns <span class="ot">=</span> (toList us3) <span class="op">++</span> as <span class="op">++</span> (toList vs1)</a>
<a class="sourceLine" id="cb43-27" title="27">        <span class="kw">in</span> branchNonEmpty us1 (concatWithList us2 (toNodes ns) vs2) vs3</a>
<a class="sourceLine" id="cb43-28" title="28">    <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-29" title="29">      toNodes</a>
<a class="sourceLine" id="cb43-30" title="30"><span class="ot">        ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb43-31" title="31">        <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Node</span> a]</a>
<a class="sourceLine" id="cb43-32" title="32">      toNodes w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb43-33" title="33">        [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb43-34" title="34">        [a1, a2] <span class="ot">-&gt;</span> [node2 a1 a2]</a>
<a class="sourceLine" id="cb43-35" title="35">        [a1, a2, a3] <span class="ot">-&gt;</span> [node3 a1 a2 a3]</a>
<a class="sourceLine" id="cb43-36" title="36">        [a1, a2, a3, a4] <span class="ot">-&gt;</span> [node2 a1 a2, node2 a3 a4]</a>
<a class="sourceLine" id="cb43-37" title="37">        a1<span class="op">:</span>a2<span class="op">:</span>a3<span class="op">:</span>a4<span class="op">:</span>as <span class="ot">-&gt;</span> (node3 a1 a2 a3) <span class="op">:</span> toNodes (a4<span class="op">:</span>as)</a>
<a class="sourceLine" id="cb43-38" title="38">        _ <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;toNodes: panic&quot;</span></a></code></pre></div>
<p>We can check that this works as expected with an example.</p>
<div class="doctest">
<div class="sourceCode" id="cb44"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" title="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb44-2" title="2"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb44-3" title="3"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb44-4" title="4"><span class="co">--   x1, x2 :: FingerTree (Counted Char)</span></a>
<a class="sourceLine" id="cb44-5" title="5"><span class="co">--   x1 = fromList [ Counted &#39;a&#39;, Counted &#39;b&#39; ]</span></a>
<a class="sourceLine" id="cb44-6" title="6"><span class="co">--   x2 = fromList [ Counted &#39;d&#39;, Counted &#39;e&#39; ]</span></a>
<a class="sourceLine" id="cb44-7" title="7"><span class="co">-- in concatWithList x1 [ Counted &#39;c&#39; ] x2</span></a>
<a class="sourceLine" id="cb44-8" title="8"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb44-9" title="9"><span class="co">-- NonEmpty $ fromList [Counted &#39;a&#39;,Counted &#39;b&#39;,Counted &#39;c&#39;,Counted &#39;d&#39;,Counted &#39;e&#39;]</span></a></code></pre></div>
</div>
<p>Now the real <code>cat</code> is a specialization of <code>concatWithList</code>, and makes both varieties of finger trees into semigroups. Along with <code>empty</code> the possibly empty finger trees form a monoid.</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" title="1"><span class="kw">instance</span> (<span class="dt">Valued</span> a) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">NonEmptyFingerTree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb45-2" title="2">  u <span class="op">&lt;&gt;</span> v <span class="ot">=</span> concatWithList u [] v</a>
<a class="sourceLine" id="cb45-3" title="3"></a>
<a class="sourceLine" id="cb45-4" title="4"><span class="kw">instance</span> (<span class="dt">Valued</span> a) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">FingerTree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb45-5" title="5">  u <span class="op">&lt;&gt;</span> v <span class="ot">=</span> concatWithList u [] v</a>
<a class="sourceLine" id="cb45-6" title="6"></a>
<a class="sourceLine" id="cb45-7" title="7"><span class="kw">instance</span> (<span class="dt">Valued</span> a) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">FingerTree</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb45-8" title="8">  <span class="fu">mempty</span> <span class="ot">=</span> empty</a></code></pre></div>
<p>There's a bit more to be said about concatenation. At this point we have a type, <code>NonEmptyFingerTree</code>, which is canonically a "subtype" of another, <code>FingerTree</code>, and both of these types are semigroups. In fact the nonempty finger trees form a <em>subsemigroup</em> of the possibly empty finger trees (a relationship which carries laws, but no additional operations). A natural question to ask is whether a subsemigroup is an <em>ideal</em>, and in this case it is. Ideals are subsets of a semigroup which are <em>absorptive</em> under the semigroup operation; this is reflected in the type of the left- and right- absorption operators.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb46-1" title="1"><span class="kw">instance</span> <span class="dt">Subsemigroup</span> <span class="dt">NonEmptyFingerTree</span></a>
<a class="sourceLine" id="cb46-2" title="2"></a>
<a class="sourceLine" id="cb46-3" title="3"><span class="kw">instance</span> <span class="dt">Ideal</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb46-4" title="4">  (<span class="op">@&gt;</span>)</a>
<a class="sourceLine" id="cb46-5" title="5"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb46-6" title="6">    <span class="ot">=&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb46-7" title="7">  u <span class="op">@&gt;</span> v <span class="ot">=</span> <span class="kw">case</span> v <span class="kw">of</span></a>
<a class="sourceLine" id="cb46-8" title="8">    <span class="dt">Empty</span>      <span class="ot">-&gt;</span> u</a>
<a class="sourceLine" id="cb46-9" title="9">    <span class="dt">NonEmpty</span> w <span class="ot">-&gt;</span> u <span class="op">&lt;&gt;</span> w</a>
<a class="sourceLine" id="cb46-10" title="10"></a>
<a class="sourceLine" id="cb46-11" title="11">  (<span class="op">&lt;@</span>)</a>
<a class="sourceLine" id="cb46-12" title="12"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb46-13" title="13">    <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb46-14" title="14">  u <span class="op">&lt;@</span> v <span class="ot">=</span> <span class="kw">case</span> u <span class="kw">of</span></a>
<a class="sourceLine" id="cb46-15" title="15">    <span class="dt">Empty</span>      <span class="ot">-&gt;</span> v</a>
<a class="sourceLine" id="cb46-16" title="16">    <span class="dt">NonEmpty</span> w <span class="ot">-&gt;</span> w <span class="op">&lt;&gt;</span> v</a></code></pre></div>
<p>We also have a kind of specialized <code>join</code> on finger trees called <code>inflateWith</code>. The intuition behind this function is that each entry in an input finger tree is expanded to a subsequence.</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb47-1" title="1">inflateWith</a>
<a class="sourceLine" id="cb47-2" title="2"><span class="ot">  ::</span> <span class="kw">forall</span> a b</a>
<a class="sourceLine" id="cb47-3" title="3">   <span class="op">.</span> ( <span class="dt">Valued</span> a, <span class="dt">Valued</span> b )</a>
<a class="sourceLine" id="cb47-4" title="4">  <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> [b]) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> b</a>
<a class="sourceLine" id="cb47-5" title="5">inflateWith f w <span class="ot">=</span> inflate w</a>
<a class="sourceLine" id="cb47-6" title="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb47-7" title="7"><span class="ot">    inflate ::</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> b</a>
<a class="sourceLine" id="cb47-8" title="8">    inflate w <span class="ot">=</span> <span class="kw">case</span> uncons w <span class="kw">of</span></a>
<a class="sourceLine" id="cb47-9" title="9">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">mempty</span></a>
<a class="sourceLine" id="cb47-10" title="10">      <span class="dt">Just</span> (a, as) <span class="ot">-&gt;</span> (fromList (f a)) <span class="op">&lt;&gt;</span> inflate as</a></code></pre></div>
</section>
<section class="level2">
<h2>Splitting</h2>
<p>The killer operation on finger trees, and the reason for caching the value at each node, is efficient <em>splitting</em>. This operation, which comes in left and right handed variants, takes a predicate <code>p</code> on <code>Value a</code> and a finger tree <code>w</code> and attempts to break it into three pieces, <code>as</code>, <code>x</code>, and <code>bs</code>. We can think of <code>x</code> as a <em>search result</em> and of <code>as</code> and <code>bs</code> as the prefix and suffix of the search. Moreover, the search result must satisfy three <em>left-splitting properties</em>:</p>
<ol>
<li>That <code>w == as &lt;&gt; singleton x &lt;&gt; bs</code> -- so that splitting is a bona fide cat-factorization;</li>
<li>That <code>p (value as)</code> is false -- so the portion of the list <em>up to</em> the search result doesn't satisfy <code>p</code>; and</li>
<li>That <code>p (value as &lt;&gt; value x)</code> is true -- so the portion of the list <em>up to and including</em> the search result does satisfy <code>p</code>.</li>
</ol>
<p>(The right-splitting properties are dual.) The internal structure of finger trees allows this to be done efficiently. Note that the splitting properties do not say anything about the result being <em>unique</em>, or even extremal in any sense (leftmost or rightmost), and in general there may be many possible places to break the tree, with the result not guaranteed to be special in any way. Even worse, the splitting properties to not guarantee that if a valid splitting exists, one will be found. But with a judicious choice of <code>Value a</code> and the predicate we can guarantee uniqueness of the split, and that it will be found, and can perform this operation quickly.</p>
<p>It's natural to wonder why this is a useful thing to do. Well, for a well-chosen monoid and predicate, splitting can do some interesting things. As a simple example, with the <code>Count</code> monoid and a predicate like $p(k) = (k \geq N)$ we can break the finger tree at a specific index. Later on we'll use it to break a text buffer at a specific line and column position or screen coordinate.</p>
<p>To make life a little easier for consumers of this module, we'll wrap the result of a splitting behind a type, <code>SplitResult</code>, rather than returning a tuple with no context.</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb48-1" title="1"><span class="kw">data</span> <span class="dt">SplitResult</span> a</a>
<a class="sourceLine" id="cb48-2" title="2">  <span class="ot">=</span> <span class="dt">NotFound</span></a>
<a class="sourceLine" id="cb48-3" title="3">  <span class="op">|</span> <span class="dt">Found</span> (<span class="dt">FingerTree</span> a) a (<span class="dt">FingerTree</span> a)</a>
<a class="sourceLine" id="cb48-4" title="4">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>We also wrap the splitting operation itself in a type class because (1) it has associated laws, and (2) we have two implementations, possibly empty and nonempty, and want to use the same names for both. As we'll see in a moment, splitting is implemented recursively in terms of a "split with context" operation which takes a monoidal value.</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb49-1" title="1"><span class="kw">class</span> <span class="dt">Split</span> f <span class="kw">where</span></a>
<a class="sourceLine" id="cb49-2" title="2">  toFingerTree</a>
<a class="sourceLine" id="cb49-3" title="3"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb49-4" title="4">    <span class="ot">=&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb49-5" title="5"></a>
<a class="sourceLine" id="cb49-6" title="6">  splitWithContextL</a>
<a class="sourceLine" id="cb49-7" title="7"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb49-8" title="8">    <span class="ot">=&gt;</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> (<span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb49-9" title="9">    <span class="ot">-&gt;</span> <span class="dt">SplitResult</span> a</a>
<a class="sourceLine" id="cb49-10" title="10"></a>
<a class="sourceLine" id="cb49-11" title="11">  splitWithContextR</a>
<a class="sourceLine" id="cb49-12" title="12"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb49-13" title="13">    <span class="ot">=&gt;</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> (<span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb49-14" title="14">    <span class="ot">-&gt;</span> <span class="dt">SplitResult</span> a</a></code></pre></div>
<p>Then the actual splitting operations are contextual splits with a trivial context.</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb50-1" title="1">splitL</a>
<a class="sourceLine" id="cb50-2" title="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a, <span class="dt">Split</span> f )</a>
<a class="sourceLine" id="cb50-3" title="3">  <span class="ot">=&gt;</span> (<span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb50-4" title="4">  <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb50-5" title="5">  <span class="ot">-&gt;</span> <span class="dt">SplitResult</span> a</a>
<a class="sourceLine" id="cb50-6" title="6">splitL <span class="ot">=</span> splitWithContextL <span class="fu">mempty</span></a>
<a class="sourceLine" id="cb50-7" title="7"></a>
<a class="sourceLine" id="cb50-8" title="8">splitR</a>
<a class="sourceLine" id="cb50-9" title="9"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a, <span class="dt">Split</span> f )</a>
<a class="sourceLine" id="cb50-10" title="10">  <span class="ot">=&gt;</span> (<span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb50-11" title="11">  <span class="ot">-&gt;</span> f a</a>
<a class="sourceLine" id="cb50-12" title="12">  <span class="ot">-&gt;</span> <span class="dt">SplitResult</span> a</a>
<a class="sourceLine" id="cb50-13" title="13">splitR <span class="ot">=</span> splitWithContextR <span class="fu">mempty</span></a></code></pre></div>
<p>Now we'll get to the business of implementing this code: first we need a version of splitting on the fingers. This is pretty tedious because we're essentially using brute force to make sure the output satisfies the splitting properties. (<code>splitSome</code> is only used inside this module.) Tedious though it is, note that both variants of <code>splitSome</code> have constant complexity.</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb51-1" title="1">splitSomeL</a>
<a class="sourceLine" id="cb51-2" title="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb51-3" title="3"> <span class="ot">=&gt;</span> (<span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb51-4" title="4"> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Maybe</span> (<span class="dt">Some</span> a), a, <span class="dt">Maybe</span> (<span class="dt">Some</span> a))</a>
<a class="sourceLine" id="cb51-5" title="5">splitSomeL p i w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb51-6" title="6"> <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb51-7" title="7">   <span class="kw">let</span> v1 <span class="ot">=</span> i <span class="op">&lt;&gt;</span> (value a1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-8" title="8">   <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb51-9" title="9">     <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb51-10" title="10">     <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb51-11" title="11"> <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb51-12" title="12">   <span class="kw">let</span> v1 <span class="ot">=</span> i <span class="op">&lt;&gt;</span> (value a1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-13" title="13">   <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb51-14" title="14">     <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Just</span> (only1 a2))</a>
<a class="sourceLine" id="cb51-15" title="15">     <span class="kw">else</span></a>
<a class="sourceLine" id="cb51-16" title="16">       <span class="kw">let</span> v2 <span class="ot">=</span> v1 <span class="op">&lt;&gt;</span> (value a2) <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-17" title="17">       <span class="kw">if</span> p v2</a>
<a class="sourceLine" id="cb51-18" title="18">         <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only1 a1), a2, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb51-19" title="19">         <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb51-20" title="20"> <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb51-21" title="21">   <span class="kw">let</span> v1 <span class="ot">=</span> i <span class="op">&lt;&gt;</span> (value a1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-22" title="22">   <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb51-23" title="23">     <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Just</span> (only2 a2 a3))</a>
<a class="sourceLine" id="cb51-24" title="24">     <span class="kw">else</span></a>
<a class="sourceLine" id="cb51-25" title="25">       <span class="kw">let</span> v2 <span class="ot">=</span> v1 <span class="op">&lt;&gt;</span> (value a2) <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-26" title="26">       <span class="kw">if</span> p v2</a>
<a class="sourceLine" id="cb51-27" title="27">         <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only1 a1), a2, <span class="dt">Just</span> (only1 a3))</a>
<a class="sourceLine" id="cb51-28" title="28">         <span class="kw">else</span></a>
<a class="sourceLine" id="cb51-29" title="29">           <span class="kw">let</span> v3 <span class="ot">=</span> v2 <span class="op">&lt;&gt;</span> (value a3) <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-30" title="30">           <span class="kw">if</span> p v3</a>
<a class="sourceLine" id="cb51-31" title="31">             <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only2 a1 a2), a3, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb51-32" title="32">             <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb51-33" title="33"> <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb51-34" title="34">   <span class="kw">let</span> v1 <span class="ot">=</span> i <span class="op">&lt;&gt;</span> (value a1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-35" title="35">   <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb51-36" title="36">     <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Just</span> (only3 a2 a3 a4))</a>
<a class="sourceLine" id="cb51-37" title="37">     <span class="kw">else</span></a>
<a class="sourceLine" id="cb51-38" title="38">       <span class="kw">let</span> v2 <span class="ot">=</span> v1 <span class="op">&lt;&gt;</span> (value a2) <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-39" title="39">         <span class="kw">if</span> p v2</a>
<a class="sourceLine" id="cb51-40" title="40">           <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only1 a1), a2, <span class="dt">Just</span> (only2 a3 a4))</a>
<a class="sourceLine" id="cb51-41" title="41">           <span class="kw">else</span></a>
<a class="sourceLine" id="cb51-42" title="42">             <span class="kw">let</span> v3 <span class="ot">=</span> v2 <span class="op">&lt;&gt;</span> (value a3) <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-43" title="43">               <span class="kw">if</span> p v3</a>
<a class="sourceLine" id="cb51-44" title="44">                 <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only2 a1 a2), a3, <span class="dt">Just</span> (only1 a4))</a>
<a class="sourceLine" id="cb51-45" title="45">                 <span class="kw">else</span></a>
<a class="sourceLine" id="cb51-46" title="46">                   <span class="kw">let</span> v4 <span class="ot">=</span> v3 <span class="op">&lt;&gt;</span> (value a4) <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-47" title="47">                     <span class="kw">if</span> p v4</a>
<a class="sourceLine" id="cb51-48" title="48">                       <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only3 a1 a2 a3), a4, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb51-49" title="49">                       <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb51-50" title="50"></a>
<a class="sourceLine" id="cb51-51" title="51">splitSomeR</a>
<a class="sourceLine" id="cb51-52" title="52"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb51-53" title="53">  <span class="ot">=&gt;</span> (<span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> a</a>
<a class="sourceLine" id="cb51-54" title="54">  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Maybe</span> (<span class="dt">Some</span> a), a, <span class="dt">Maybe</span> (<span class="dt">Some</span> a))</a>
<a class="sourceLine" id="cb51-55" title="55">splitSomeR p i w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb51-56" title="56">  <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb51-57" title="57">    <span class="kw">let</span> v1 <span class="ot">=</span> (value a1) <span class="op">&lt;&gt;</span> i <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-58" title="58">    <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb51-59" title="59">      <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb51-60" title="60">      <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb51-61" title="61">  <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb51-62" title="62">    <span class="kw">let</span> v2 <span class="ot">=</span> (value a2) <span class="op">&lt;&gt;</span> i <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-63" title="63">    <span class="kw">if</span> p v2</a>
<a class="sourceLine" id="cb51-64" title="64">      <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only1 a1), a2, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb51-65" title="65">      <span class="kw">else</span></a>
<a class="sourceLine" id="cb51-66" title="66">        <span class="kw">let</span> v1 <span class="ot">=</span> (value a1) <span class="op">&lt;&gt;</span> v2 <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-67" title="67">        <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb51-68" title="68">          <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Just</span> (only1 a2))</a>
<a class="sourceLine" id="cb51-69" title="69">          <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb51-70" title="70">  <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb51-71" title="71">    <span class="kw">let</span> v3 <span class="ot">=</span> (value a3) <span class="op">&lt;&gt;</span> i <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-72" title="72">    <span class="kw">if</span> p v3</a>
<a class="sourceLine" id="cb51-73" title="73">      <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only2 a1 a2), a3, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb51-74" title="74">      <span class="kw">else</span></a>
<a class="sourceLine" id="cb51-75" title="75">        <span class="kw">let</span> v2 <span class="ot">=</span> (value a2) <span class="op">&lt;&gt;</span> v3 <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-76" title="76">        <span class="kw">if</span> p v2</a>
<a class="sourceLine" id="cb51-77" title="77">          <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only1 a1), a2, <span class="dt">Just</span> (only1 a3))</a>
<a class="sourceLine" id="cb51-78" title="78">          <span class="kw">else</span></a>
<a class="sourceLine" id="cb51-79" title="79">            <span class="kw">let</span> v1 <span class="ot">=</span> (value a1) <span class="op">&lt;&gt;</span> v2 <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-80" title="80">            <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb51-81" title="81">              <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Just</span> (only2 a2 a3))</a>
<a class="sourceLine" id="cb51-82" title="82">              <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb51-83" title="83">  <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb51-84" title="84">    <span class="kw">let</span> v4 <span class="ot">=</span> (value a4) <span class="op">&lt;&gt;</span> i <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-85" title="85">    <span class="kw">if</span> p v4</a>
<a class="sourceLine" id="cb51-86" title="86">      <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only3 a1 a2 a3), a4, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb51-87" title="87">      <span class="kw">else</span></a>
<a class="sourceLine" id="cb51-88" title="88">        <span class="kw">let</span> v3 <span class="ot">=</span> (value a3) <span class="op">&lt;&gt;</span> v4 <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-89" title="89">        <span class="kw">if</span> p v3</a>
<a class="sourceLine" id="cb51-90" title="90">          <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only2 a1 a2), a3, <span class="dt">Just</span> (only1 a4))</a>
<a class="sourceLine" id="cb51-91" title="91">          <span class="kw">else</span></a>
<a class="sourceLine" id="cb51-92" title="92">            <span class="kw">let</span> v2 <span class="ot">=</span> (value a2) <span class="op">&lt;&gt;</span> v3 <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-93" title="93">            <span class="kw">if</span> p v2</a>
<a class="sourceLine" id="cb51-94" title="94">              <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only1 a1), a2, <span class="dt">Just</span> (only2 a3 a4))</a>
<a class="sourceLine" id="cb51-95" title="95">              <span class="kw">else</span></a>
<a class="sourceLine" id="cb51-96" title="96">                <span class="kw">let</span> v1 <span class="ot">=</span> (value a1) <span class="op">&lt;&gt;</span> v2 <span class="kw">in</span></a>
<a class="sourceLine" id="cb51-97" title="97">                <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb51-98" title="98">                  <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Just</span> (only3 a2 a3 a4))</a>
<a class="sourceLine" id="cb51-99" title="99">                  <span class="kw">else</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>Now we can implement splitting proper. For <code>FingerTree</code> it's easy -- all the real work is offloaded to the nonempty case.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb52-1" title="1"><span class="kw">instance</span> <span class="dt">Split</span> <span class="dt">FingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb52-2" title="2">  toFingerTree <span class="ot">=</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb52-3" title="3"></a>
<a class="sourceLine" id="cb52-4" title="4">  splitWithContextL</a>
<a class="sourceLine" id="cb52-5" title="5"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb52-6" title="6">    <span class="ot">=&gt;</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> (<span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb52-7" title="7">    <span class="ot">-&gt;</span> <span class="dt">SplitResult</span> a</a>
<a class="sourceLine" id="cb52-8" title="8">  splitWithContextL i p w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb52-9" title="9">    <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="dt">NotFound</span></a>
<a class="sourceLine" id="cb52-10" title="10">    <span class="dt">NonEmpty</span> z <span class="ot">-&gt;</span> splitWithContextL i p z</a>
<a class="sourceLine" id="cb52-11" title="11"></a>
<a class="sourceLine" id="cb52-12" title="12">  splitWithContextR</a>
<a class="sourceLine" id="cb52-13" title="13"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb52-14" title="14">    <span class="ot">=&gt;</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> (<span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb52-15" title="15">    <span class="ot">-&gt;</span> <span class="dt">SplitResult</span> a</a>
<a class="sourceLine" id="cb52-16" title="16">  splitWithContextR i p w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb52-17" title="17">    <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="dt">NotFound</span></a>
<a class="sourceLine" id="cb52-18" title="18">    <span class="dt">NonEmpty</span> z <span class="ot">-&gt;</span> splitWithContextR i p z</a></code></pre></div>
<p>The nonempty case is where all the magic happens. This code looks complicated -- but all it's doing is looking at the cached valuations at each node to see if there is definitely an interior node where the valuation switches from false to true from left-to-right or right-to-left, depending on the direction of the split. If we can't be certain such a flip occurs, then the entire subtree is thrown out. This is what allows splitting to be efficient, but it's also what means there may be points in the tree which satisfy the splitting criteria, but which the splitting operation cannot find. To guarantee that splitting will succeed it is enough to make our predicates <em>monotone</em> -- to ensure that they switch from false to true at some point along the list and never switch back. The Hinze and Paterson paper has more detail on this, including proofs.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb53-1" title="1"><span class="kw">instance</span> <span class="dt">Split</span> <span class="dt">NonEmptyFingerTree</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb53-2" title="2">  toFingerTree <span class="ot">=</span> <span class="dt">NonEmpty</span></a>
<a class="sourceLine" id="cb53-3" title="3"></a>
<a class="sourceLine" id="cb53-4" title="4">  splitWithContextL</a>
<a class="sourceLine" id="cb53-5" title="5"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb53-6" title="6">    <span class="ot">=&gt;</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> (<span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb53-7" title="7">    <span class="ot">-&gt;</span> <span class="dt">SplitResult</span> a</a>
<a class="sourceLine" id="cb53-8" title="8">  splitWithContextL i p w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb53-9" title="9">    <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-10" title="10">      <span class="kw">let</span> va <span class="ot">=</span> i <span class="op">&lt;&gt;</span> (value a) <span class="kw">in</span></a>
<a class="sourceLine" id="cb53-11" title="11">      <span class="kw">if</span> p va</a>
<a class="sourceLine" id="cb53-12" title="12">        <span class="kw">then</span> <span class="dt">Found</span> empty a empty</a>
<a class="sourceLine" id="cb53-13" title="13">        <span class="kw">else</span> <span class="dt">NotFound</span></a>
<a class="sourceLine" id="cb53-14" title="14">    <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-15" title="15">      <span class="kw">let</span> vas1 <span class="ot">=</span> i <span class="op">&lt;&gt;</span> (value as1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb53-16" title="16">      <span class="co">-- look for a match in the left fingers</span></a>
<a class="sourceLine" id="cb53-17" title="17">      <span class="kw">case</span> splitSomeL p i as1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb53-18" title="18">        <span class="dt">Just</span> (ds1, x, ds3) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-19" title="19">          <span class="kw">let</span></a>
<a class="sourceLine" id="cb53-20" title="20">            bs1 <span class="ot">=</span> maybeSomeToFingerTree ds1</a>
<a class="sourceLine" id="cb53-21" title="21">            bs3 <span class="ot">=</span> borrowL ds3 as2 as3</a>
<a class="sourceLine" id="cb53-22" title="22">          <span class="kw">in</span> <span class="dt">Found</span> bs1 x bs3</a>
<a class="sourceLine" id="cb53-23" title="23">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-24" title="24">          <span class="kw">let</span> vas2 <span class="ot">=</span> vas1 <span class="op">&lt;&gt;</span> (value as2) <span class="kw">in</span></a>
<a class="sourceLine" id="cb53-25" title="25">          <span class="co">-- look for a match in the spine</span></a>
<a class="sourceLine" id="cb53-26" title="26">          <span class="kw">case</span> splitWithContextL vas1 p as2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb53-27" title="27">            <span class="dt">Found</span> cs1 xs cs3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-28" title="28">              <span class="kw">let</span> vs <span class="ot">=</span> vas1 <span class="op">&lt;&gt;</span> (value cs1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb53-29" title="29">              <span class="kw">case</span> splitSomeL p vs (toSome xs) <span class="kw">of</span></a>
<a class="sourceLine" id="cb53-30" title="30">                <span class="dt">Just</span> (ds1, x, ds3) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-31" title="31">                  <span class="kw">let</span></a>
<a class="sourceLine" id="cb53-32" title="32">                    bs1 <span class="ot">=</span> borrowR as1 cs1 ds1</a>
<a class="sourceLine" id="cb53-33" title="33">                    bs3 <span class="ot">=</span> borrowL ds3 cs3 as3</a>
<a class="sourceLine" id="cb53-34" title="34">                  <span class="kw">in</span> <span class="dt">Found</span> bs1 x bs3</a>
<a class="sourceLine" id="cb53-35" title="35">                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;splitWithContextL: panic&quot;</span></a>
<a class="sourceLine" id="cb53-36" title="36">            <span class="dt">NotFound</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-37" title="37">              <span class="kw">let</span> vas3 <span class="ot">=</span> vas2 <span class="op">&lt;&gt;</span> (value as3) <span class="kw">in</span></a>
<a class="sourceLine" id="cb53-38" title="38">              <span class="co">-- look for a match in the right fingers</span></a>
<a class="sourceLine" id="cb53-39" title="39">              <span class="kw">case</span> splitSomeL p vas2 as3 <span class="kw">of</span></a>
<a class="sourceLine" id="cb53-40" title="40">                <span class="dt">Just</span> (ds1, x, ds3) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-41" title="41">                  <span class="kw">let</span></a>
<a class="sourceLine" id="cb53-42" title="42">                    bs1 <span class="ot">=</span> borrowR as1 as2 ds1</a>
<a class="sourceLine" id="cb53-43" title="43">                    bs3 <span class="ot">=</span> maybeSomeToFingerTree ds3</a>
<a class="sourceLine" id="cb53-44" title="44">                  <span class="kw">in</span> <span class="dt">Found</span> bs1 x bs3</a>
<a class="sourceLine" id="cb53-45" title="45">                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">NotFound</span></a>
<a class="sourceLine" id="cb53-46" title="46"></a>
<a class="sourceLine" id="cb53-47" title="47">  splitWithContextR</a>
<a class="sourceLine" id="cb53-48" title="48"><span class="ot">    ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb53-49" title="49">    <span class="ot">=&gt;</span> <span class="dt">Value</span> a <span class="ot">-&gt;</span> (<span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a</a>
<a class="sourceLine" id="cb53-50" title="50">    <span class="ot">-&gt;</span> <span class="dt">SplitResult</span> a</a>
<a class="sourceLine" id="cb53-51" title="51">  splitWithContextR i p w <span class="ot">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb53-52" title="52">    <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-53" title="53">      <span class="kw">let</span> va <span class="ot">=</span> (value a) <span class="op">&lt;&gt;</span> i <span class="kw">in</span></a>
<a class="sourceLine" id="cb53-54" title="54">      <span class="kw">if</span> p va</a>
<a class="sourceLine" id="cb53-55" title="55">        <span class="kw">then</span> <span class="dt">Found</span> empty a empty</a>
<a class="sourceLine" id="cb53-56" title="56">        <span class="kw">else</span> <span class="dt">NotFound</span></a>
<a class="sourceLine" id="cb53-57" title="57">    <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-58" title="58">      <span class="kw">let</span> vas3 <span class="ot">=</span> (value as3) <span class="op">&lt;&gt;</span> i <span class="kw">in</span></a>
<a class="sourceLine" id="cb53-59" title="59">      <span class="co">-- look for a match in the right fingers</span></a>
<a class="sourceLine" id="cb53-60" title="60">      <span class="kw">case</span> splitSomeR p i as3 <span class="kw">of</span></a>
<a class="sourceLine" id="cb53-61" title="61">        <span class="dt">Just</span> (ds1, x, ds3) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-62" title="62">          <span class="kw">let</span></a>
<a class="sourceLine" id="cb53-63" title="63">            bs1 <span class="ot">=</span> borrowR as1 as2 ds1</a>
<a class="sourceLine" id="cb53-64" title="64">            bs3 <span class="ot">=</span> maybeSomeToFingerTree ds3</a>
<a class="sourceLine" id="cb53-65" title="65">          <span class="kw">in</span> <span class="dt">Found</span> bs1 x bs3</a>
<a class="sourceLine" id="cb53-66" title="66">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-67" title="67">          <span class="kw">let</span> vas2 <span class="ot">=</span> (value as2) <span class="op">&lt;&gt;</span> vas3 <span class="kw">in</span></a>
<a class="sourceLine" id="cb53-68" title="68">          <span class="co">-- look for a match in the spine</span></a>
<a class="sourceLine" id="cb53-69" title="69">          <span class="kw">case</span> splitWithContextR vas3 p as2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb53-70" title="70">            <span class="dt">Found</span> cs1 xs cs3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-71" title="71">              <span class="kw">let</span> vs <span class="ot">=</span> (value cs3) <span class="op">&lt;&gt;</span> vas3 <span class="kw">in</span></a>
<a class="sourceLine" id="cb53-72" title="72">              <span class="kw">case</span> splitSomeR p vs (toSome xs) <span class="kw">of</span></a>
<a class="sourceLine" id="cb53-73" title="73">                <span class="dt">Just</span> (ds1, x, ds3) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-74" title="74">                  <span class="kw">let</span></a>
<a class="sourceLine" id="cb53-75" title="75">                    bs1 <span class="ot">=</span> borrowR as1 cs1 ds1</a>
<a class="sourceLine" id="cb53-76" title="76">                    bs3 <span class="ot">=</span> borrowL ds3 cs3 as3</a>
<a class="sourceLine" id="cb53-77" title="77">                  <span class="kw">in</span> <span class="dt">Found</span> bs1 x bs3</a>
<a class="sourceLine" id="cb53-78" title="78">                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;splitWithContextR: panic&quot;</span></a>
<a class="sourceLine" id="cb53-79" title="79">            <span class="dt">NotFound</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-80" title="80">              <span class="kw">let</span> vas1 <span class="ot">=</span> (value as1) <span class="op">&lt;&gt;</span> vas2 <span class="kw">in</span></a>
<a class="sourceLine" id="cb53-81" title="81">              <span class="co">-- look for a match in the left fingers</span></a>
<a class="sourceLine" id="cb53-82" title="82">              <span class="kw">case</span> splitSomeR p vas2 as1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb53-83" title="83">                <span class="dt">Just</span> (ds1, x, ds3) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb53-84" title="84">                  <span class="kw">let</span></a>
<a class="sourceLine" id="cb53-85" title="85">                    bs1 <span class="ot">=</span> maybeSomeToFingerTree ds1</a>
<a class="sourceLine" id="cb53-86" title="86">                    bs3 <span class="ot">=</span> borrowL ds3 as2 as3</a>
<a class="sourceLine" id="cb53-87" title="87">                  <span class="kw">in</span> <span class="dt">Found</span> bs1 x bs3</a>
<a class="sourceLine" id="cb53-88" title="88">                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">NotFound</span></a></code></pre></div>
<p>Now's a good time for some examples.</p>
<div class="doctest">
<div class="sourceCode" id="cb54"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb54-1" title="1"><span class="co">-- $</span></a>
<a class="sourceLine" id="cb54-2" title="2"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb54-3" title="3"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb54-4" title="4"><span class="co">--   x :: FingerTree (Counted Char)</span></a>
<a class="sourceLine" id="cb54-5" title="5"><span class="co">--   x = fromList [Counted &#39;a&#39;, Counted &#39;b&#39;, Counted &#39;c&#39;, Counted &#39;d&#39;, Counted &#39;e&#39;]</span></a>
<a class="sourceLine" id="cb54-6" title="6"><span class="co">--   --</span></a>
<a class="sourceLine" id="cb54-7" title="7"><span class="co">--   us, vs :: FingerTree (Counted Char)</span></a>
<a class="sourceLine" id="cb54-8" title="8"><span class="co">--   us = fromList [ Counted &#39;a&#39;, Counted &#39;b&#39;, Counted &#39;c&#39; ]</span></a>
<a class="sourceLine" id="cb54-9" title="9"><span class="co">--   vs = fromList [ Counted &#39;e&#39; ]</span></a>
<a class="sourceLine" id="cb54-10" title="10"><span class="co">--   --</span></a>
<a class="sourceLine" id="cb54-11" title="11"><span class="co">--   p :: Count -&gt; Bool</span></a>
<a class="sourceLine" id="cb54-12" title="12"><span class="co">--   p (Count k) = k &gt; 3</span></a>
<a class="sourceLine" id="cb54-13" title="13"><span class="co">-- in Found us (Counted &#39;d&#39;) vs == splitL p x</span></a>
<a class="sourceLine" id="cb54-14" title="14"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb54-15" title="15"><span class="co">-- True</span></a>
<a class="sourceLine" id="cb54-16" title="16"><span class="co">--</span></a>
<a class="sourceLine" id="cb54-17" title="17"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb54-18" title="18"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb54-19" title="19"><span class="co">--   x :: FingerTree (Counted Char)</span></a>
<a class="sourceLine" id="cb54-20" title="20"><span class="co">--   x = fromList [ Counted &#39;a&#39;, Counted &#39;b&#39;, Counted &#39;c&#39;, Counted &#39;d&#39; ]</span></a>
<a class="sourceLine" id="cb54-21" title="21"><span class="co">--   --</span></a>
<a class="sourceLine" id="cb54-22" title="22"><span class="co">--   us, vs :: FingerTree (Counted Char)</span></a>
<a class="sourceLine" id="cb54-23" title="23"><span class="co">--   us = fromList [ Counted &#39;a&#39; ]</span></a>
<a class="sourceLine" id="cb54-24" title="24"><span class="co">--   vs = fromList [ Counted &#39;c&#39;, Counted &#39;d&#39; ]</span></a>
<a class="sourceLine" id="cb54-25" title="25"><span class="co">--   --</span></a>
<a class="sourceLine" id="cb54-26" title="26"><span class="co">--   p :: Count -&gt; Bool</span></a>
<a class="sourceLine" id="cb54-27" title="27"><span class="co">--   p (Count k) = k &gt;= 2</span></a>
<a class="sourceLine" id="cb54-28" title="28"><span class="co">-- in Found us (Counted &#39;b&#39;) vs == splitL p x</span></a>
<a class="sourceLine" id="cb54-29" title="29"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb54-30" title="30"><span class="co">-- True</span></a>
<a class="sourceLine" id="cb54-31" title="31"><span class="co">--</span></a>
<a class="sourceLine" id="cb54-32" title="32"><span class="co">-- &gt;&gt;&gt; :{</span></a>
<a class="sourceLine" id="cb54-33" title="33"><span class="co">-- let</span></a>
<a class="sourceLine" id="cb54-34" title="34"><span class="co">--   x :: FingerTree (Counted Char)</span></a>
<a class="sourceLine" id="cb54-35" title="35"><span class="co">--   x = fromList [ Counted &#39;a&#39;, Counted &#39;b&#39;, Counted &#39;c&#39;, Counted &#39;d&#39; ]</span></a>
<a class="sourceLine" id="cb54-36" title="36"><span class="co">--   --</span></a>
<a class="sourceLine" id="cb54-37" title="37"><span class="co">--   p :: Count -&gt; Bool</span></a>
<a class="sourceLine" id="cb54-38" title="38"><span class="co">--   p (Count k) = k &gt;= 7</span></a>
<a class="sourceLine" id="cb54-39" title="39"><span class="co">-- in splitL p x</span></a>
<a class="sourceLine" id="cb54-40" title="40"><span class="co">-- :}</span></a>
<a class="sourceLine" id="cb54-41" title="41"><span class="co">-- NotFound</span></a></code></pre></div>
</div>
</section>
<section class="level2">
<h2>Filtering</h2>
<div class="sourceCode" id="cb55"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb55-1" title="1">removeSplitsL</a>
<a class="sourceLine" id="cb55-2" title="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a, <span class="dt">Split</span> f )</a>
<a class="sourceLine" id="cb55-3" title="3">  <span class="ot">=&gt;</span> (<span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb55-4" title="4">  <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb55-5" title="5">removeSplitsL p x <span class="ot">=</span> <span class="kw">case</span> splitL p x <span class="kw">of</span></a>
<a class="sourceLine" id="cb55-6" title="6">  <span class="dt">NotFound</span> <span class="ot">-&gt;</span> toFingerTree x</a>
<a class="sourceLine" id="cb55-7" title="7">  <span class="dt">Found</span> as u bs <span class="ot">-&gt;</span> as <span class="op">&lt;&gt;</span> removeSplitsL p bs</a>
<a class="sourceLine" id="cb55-8" title="8"></a>
<a class="sourceLine" id="cb55-9" title="9">removeSplitsR</a>
<a class="sourceLine" id="cb55-10" title="10"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a, <span class="dt">Split</span> f )</a>
<a class="sourceLine" id="cb55-11" title="11">  <span class="ot">=&gt;</span> (<span class="dt">Value</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb55-12" title="12">  <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a</a>
<a class="sourceLine" id="cb55-13" title="13">removeSplitsR p x <span class="ot">=</span> <span class="kw">case</span> splitR p x <span class="kw">of</span></a>
<a class="sourceLine" id="cb55-14" title="14">  <span class="dt">NotFound</span> <span class="ot">-&gt;</span> toFingerTree x</a>
<a class="sourceLine" id="cb55-15" title="15">  <span class="dt">Found</span> as u bs <span class="ot">-&gt;</span> as <span class="op">&lt;&gt;</span> removeSplitsR p bs</a></code></pre></div>
</section>
<section class="level2">
<h2>Testing and Debugging</h2>
<p>Finally we define some utilities to help with testing. First, to interoperate with our testing framework, we need <code>FingerTree</code> to be an instance of some type classes.</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb56-1" title="1"><span class="kw">instance</span> (<span class="dt">Fmt.Display</span> a) <span class="ot">=&gt;</span> <span class="dt">Fmt.Display</span> (<span class="dt">Some</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb56-2" title="2">  display x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb56-3" title="3">    <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb56-4" title="4">      <span class="st">&quot;Only1&quot;</span> <span class="op">&lt;+&gt;</span> display a1</a>
<a class="sourceLine" id="cb56-5" title="5">    <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb56-6" title="6">      <span class="st">&quot;Only2&quot;</span> <span class="op">&lt;+&gt;</span> display a1 <span class="op">&lt;+&gt;</span> display a2</a>
<a class="sourceLine" id="cb56-7" title="7">    <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb56-8" title="8">      <span class="st">&quot;Only3&quot;</span> <span class="op">&lt;+&gt;</span> display a1 <span class="op">&lt;+&gt;</span> display a2 <span class="op">&lt;+&gt;</span> display a3</a>
<a class="sourceLine" id="cb56-9" title="9">    <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb56-10" title="10">      <span class="st">&quot;Only4&quot;</span> <span class="op">&lt;+&gt;</span> display a1 <span class="op">&lt;+&gt;</span> display a2 <span class="op">&lt;+&gt;</span> display a3 <span class="op">&lt;+&gt;</span> display a4</a></code></pre></div>
<div class="sourceCode" id="cb57"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb57-1" title="1"><span class="kw">instance</span> (<span class="dt">Fmt.Display</span> a) <span class="ot">=&gt;</span> <span class="dt">Fmt.Display</span> (<span class="dt">Node</span> a) <span class="kw">where</span></a>
<a class="sourceLine" id="cb57-2" title="2">  display x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb57-3" title="3">    <span class="dt">Node2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb57-4" title="4">      <span class="st">&quot;Node2&quot;</span> <span class="op">&lt;+&gt;</span> display a1 <span class="op">&lt;+&gt;</span> display a2</a>
<a class="sourceLine" id="cb57-5" title="5">    <span class="dt">Node3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb57-6" title="6">      <span class="st">&quot;Node3&quot;</span> <span class="op">&lt;+&gt;</span> display a1 <span class="op">&lt;+&gt;</span> display a2 <span class="op">&lt;+&gt;</span> display a3</a></code></pre></div>
<div class="sourceCode" id="cb58"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb58-1" title="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb58-2" title="2">  ( <span class="dt">Fmt.Display</span> a, <span class="dt">Valued</span> a</a>
<a class="sourceLine" id="cb58-3" title="3">  ) <span class="ot">=&gt;</span> <span class="dt">Fmt.Display</span> (<span class="dt">FingerTree</span> a)</a>
<a class="sourceLine" id="cb58-4" title="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb58-5" title="5">    display x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb58-6" title="6">      <span class="dt">Empty</span>      <span class="ot">-&gt;</span> <span class="st">&quot;Empty&quot;</span></a>
<a class="sourceLine" id="cb58-7" title="7">      <span class="dt">NonEmpty</span> z <span class="ot">-&gt;</span> <span class="st">&quot;NonEmpty&quot;</span> <span class="op">&lt;+&gt;</span> display z</a>
<a class="sourceLine" id="cb58-8" title="8"></a>
<a class="sourceLine" id="cb58-9" title="9"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb58-10" title="10">  ( <span class="dt">Arb</span> a, <span class="dt">Valued</span> a</a>
<a class="sourceLine" id="cb58-11" title="11">  ) <span class="ot">=&gt;</span> <span class="dt">Arb</span> (<span class="dt">FingerTree</span> a)</a>
<a class="sourceLine" id="cb58-12" title="12">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb58-13" title="13">    arb <span class="ot">=</span> fromList <span class="op">&lt;$&gt;</span> arb</a>
<a class="sourceLine" id="cb58-14" title="14"></a>
<a class="sourceLine" id="cb58-15" title="15"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb58-16" title="16">  ( <span class="dt">Prune</span> a, <span class="dt">Valued</span> a</a>
<a class="sourceLine" id="cb58-17" title="17">  ) <span class="ot">=&gt;</span> <span class="dt">Prune</span> (<span class="dt">FingerTree</span> a)</a>
<a class="sourceLine" id="cb58-18" title="18">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb58-19" title="19">    prune <span class="ot">=</span></a>
<a class="sourceLine" id="cb58-20" title="20">      <span class="fu">map</span> fromList <span class="op">.</span> prune <span class="op">.</span> toList</a>
<a class="sourceLine" id="cb58-21" title="21"></a>
<a class="sourceLine" id="cb58-22" title="22"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb58-23" title="23">  ( <span class="dt">CoArb</span> a, <span class="dt">Valued</span> a</a>
<a class="sourceLine" id="cb58-24" title="24">  ) <span class="ot">=&gt;</span> <span class="dt">CoArb</span> (<span class="dt">FingerTree</span> a)</a>
<a class="sourceLine" id="cb58-25" title="25">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb58-26" title="26">    coarb x <span class="ot">=</span> coarb (toList x)</a>
<a class="sourceLine" id="cb58-27" title="27"></a>
<a class="sourceLine" id="cb58-28" title="28"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb58-29" title="29">  ( <span class="dt">MakeTo</span> a, <span class="dt">Valued</span> a</a>
<a class="sourceLine" id="cb58-30" title="30">  ) <span class="ot">=&gt;</span> <span class="dt">MakeTo</span> (<span class="dt">FingerTree</span> a)</a>
<a class="sourceLine" id="cb58-31" title="31">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb58-32" title="32">    makeTo <span class="ot">=</span> makeToExtendWith</a>
<a class="sourceLine" id="cb58-33" title="33">      makeTo toList fromList</a></code></pre></div>
<p>Similarly for <code>NonEmptyFingerTree</code>:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb59-1" title="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb59-2" title="2">  ( <span class="dt">Fmt.Display</span> a, <span class="dt">Valued</span> a</a>
<a class="sourceLine" id="cb59-3" title="3">  ) <span class="ot">=&gt;</span> <span class="dt">Fmt.Display</span> (<span class="dt">NonEmptyFingerTree</span> a)</a>
<a class="sourceLine" id="cb59-4" title="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb59-5" title="5">    display x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb59-6" title="6">      <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> <span class="st">&quot;Leaf&quot;</span> <span class="op">&lt;+&gt;</span> display a</a>
<a class="sourceLine" id="cb59-7" title="7">      <span class="dt">Branch</span> _ as bs cs <span class="ot">-&gt;</span> <span class="st">&quot;Branch&quot;</span></a>
<a class="sourceLine" id="cb59-8" title="8">        <span class="op">&lt;+&gt;</span> display as <span class="op">&lt;+&gt;</span> display bs <span class="op">&lt;+&gt;</span> display cs</a>
<a class="sourceLine" id="cb59-9" title="9"></a>
<a class="sourceLine" id="cb59-10" title="10"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb59-11" title="11">  ( <span class="dt">Arb</span> a, <span class="dt">Valued</span> a</a>
<a class="sourceLine" id="cb59-12" title="12">  ) <span class="ot">=&gt;</span> <span class="dt">Arb</span> (<span class="dt">NonEmptyFingerTree</span> a)</a>
<a class="sourceLine" id="cb59-13" title="13">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb59-14" title="14">    arb <span class="ot">=</span></a>
<a class="sourceLine" id="cb59-15" title="15">      fromList <span class="op">&lt;$&gt;</span> (<span class="fu">pure</span> (<span class="op">:</span>) <span class="op">&lt;*&gt;</span> arb <span class="op">&lt;*&gt;</span> arb)</a>
<a class="sourceLine" id="cb59-16" title="16"></a>
<a class="sourceLine" id="cb59-17" title="17"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb59-18" title="18">  ( <span class="dt">Prune</span> a, <span class="dt">Valued</span> a</a>
<a class="sourceLine" id="cb59-19" title="19">  ) <span class="ot">=&gt;</span> <span class="dt">Prune</span> (<span class="dt">NonEmptyFingerTree</span> a)</a>
<a class="sourceLine" id="cb59-20" title="20">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb59-21" title="21">    prune <span class="ot">=</span></a>
<a class="sourceLine" id="cb59-22" title="22">      <span class="fu">map</span> fromList <span class="op">.</span> <span class="fu">filter</span> (<span class="fu">not</span> <span class="op">.</span> <span class="fu">null</span>) <span class="op">.</span> prune <span class="op">.</span> toList</a>
<a class="sourceLine" id="cb59-23" title="23"></a>
<a class="sourceLine" id="cb59-24" title="24"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb59-25" title="25">  ( <span class="dt">CoArb</span> a, <span class="dt">Valued</span> a</a>
<a class="sourceLine" id="cb59-26" title="26">  ) <span class="ot">=&gt;</span> <span class="dt">CoArb</span> (<span class="dt">NonEmptyFingerTree</span> a)</a>
<a class="sourceLine" id="cb59-27" title="27">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb59-28" title="28">    coarb x <span class="ot">=</span> coarb (toList x)</a>
<a class="sourceLine" id="cb59-29" title="29"></a>
<a class="sourceLine" id="cb59-30" title="30"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb59-31" title="31">  ( <span class="dt">MakeTo</span> a, <span class="dt">Valued</span> a</a>
<a class="sourceLine" id="cb59-32" title="32">  ) <span class="ot">=&gt;</span> <span class="dt">MakeTo</span> (<span class="dt">NonEmptyFingerTree</span> a)</a>
<a class="sourceLine" id="cb59-33" title="33">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb59-34" title="34">    makeTo <span class="ot">=</span> makeToExtendWith</a>
<a class="sourceLine" id="cb59-35" title="35">      makeTo toList fromList</a></code></pre></div>
<p>Finally, recall that our finger tree type has an internal invariant that needs to be maintained in order for the complexity and correctness proofs of our algorithms to hold. Namely, the cached monoidal value at each Node vust be the product of the monoidal values of the node's contents. We introduce a function (only used for testing) to check this.</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb60-1" title="1">validateFingerTree</a>
<a class="sourceLine" id="cb60-2" title="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb60-3" title="3">  <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb60-4" title="4">validateFingerTree <span class="ot">=</span></a>
<a class="sourceLine" id="cb60-5" title="5">  validateFingerTree&#39; (<span class="fu">const</span> <span class="dt">True</span>)</a>
<a class="sourceLine" id="cb60-6" title="6"></a>
<a class="sourceLine" id="cb60-7" title="7">validateNonEmptyFingerTree</a>
<a class="sourceLine" id="cb60-8" title="8"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb60-9" title="9">  <span class="ot">=&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb60-10" title="10">validateNonEmptyFingerTree <span class="ot">=</span></a>
<a class="sourceLine" id="cb60-11" title="11">  validateNonEmptyFingerTree&#39; (<span class="fu">const</span> <span class="dt">True</span>)</a></code></pre></div>
<p>Note how polymorphic recursion makes this a little tricky -- we define our validators in terms of an auxiliary predicate that builds up nested calls to <code>validateNode</code>.</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb61-1" title="1">validateFingerTree&#39;</a>
<a class="sourceLine" id="cb61-2" title="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb61-3" title="3">  <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb61-4" title="4">validateFingerTree&#39; p x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb61-5" title="5">  <span class="dt">Empty</span> <span class="ot">-&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb61-6" title="6">  <span class="dt">NonEmpty</span> w <span class="ot">-&gt;</span> validateNonEmptyFingerTree&#39; p w</a>
<a class="sourceLine" id="cb61-7" title="7"></a>
<a class="sourceLine" id="cb61-8" title="8">validateNonEmptyFingerTree&#39;</a>
<a class="sourceLine" id="cb61-9" title="9"><span class="ot">  ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb61-10" title="10">  <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">NonEmptyFingerTree</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb61-11" title="11">validateNonEmptyFingerTree&#39; p x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb61-12" title="12">  <span class="dt">Leaf</span> v a <span class="ot">-&gt;</span> <span class="fu">and</span></a>
<a class="sourceLine" id="cb61-13" title="13">    [ p a</a>
<a class="sourceLine" id="cb61-14" title="14">    , v <span class="op">==</span> value a</a>
<a class="sourceLine" id="cb61-15" title="15">    ]</a>
<a class="sourceLine" id="cb61-16" title="16">  <span class="dt">Branch</span> v as x bs <span class="ot">-&gt;</span> <span class="fu">and</span></a>
<a class="sourceLine" id="cb61-17" title="17">    [ v <span class="op">==</span> <span class="fu">mconcat</span> [ value as, value x, value bs ]</a>
<a class="sourceLine" id="cb61-18" title="18">    , validateSome p as</a>
<a class="sourceLine" id="cb61-19" title="19">    , validateFingerTree&#39; (validateNode p) x</a>
<a class="sourceLine" id="cb61-20" title="20">    , validateSome p bs</a>
<a class="sourceLine" id="cb61-21" title="21">    ]</a>
<a class="sourceLine" id="cb61-22" title="22">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb61-23" title="23">    validateSome</a>
<a class="sourceLine" id="cb61-24" title="24"><span class="ot">      ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb61-25" title="25">      <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Some</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb61-26" title="26">    validateSome valid x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb61-27" title="27">      <span class="dt">Only1</span> v a1 <span class="ot">-&gt;</span> <span class="fu">and</span></a>
<a class="sourceLine" id="cb61-28" title="28">        [ v <span class="op">==</span> value a1</a>
<a class="sourceLine" id="cb61-29" title="29">        , valid a1</a>
<a class="sourceLine" id="cb61-30" title="30">        ]</a>
<a class="sourceLine" id="cb61-31" title="31">      <span class="dt">Only2</span> v a1 a2 <span class="ot">-&gt;</span> <span class="fu">and</span></a>
<a class="sourceLine" id="cb61-32" title="32">        [ v <span class="op">==</span> <span class="fu">mconcat</span> [ value a1, value a2 ]</a>
<a class="sourceLine" id="cb61-33" title="33">        , valid a1, valid a2</a>
<a class="sourceLine" id="cb61-34" title="34">        ]</a>
<a class="sourceLine" id="cb61-35" title="35">      <span class="dt">Only3</span> v a1 a2 a3 <span class="ot">-&gt;</span> <span class="fu">and</span></a>
<a class="sourceLine" id="cb61-36" title="36">        [ v <span class="op">==</span> <span class="fu">mconcat</span> [ value a1, value a2, value a3 ]</a>
<a class="sourceLine" id="cb61-37" title="37">        , valid a1, valid a2, valid a3</a>
<a class="sourceLine" id="cb61-38" title="38">        ]</a>
<a class="sourceLine" id="cb61-39" title="39">      <span class="dt">Only4</span> v a1 a2 a3 a4 <span class="ot">-&gt;</span> <span class="fu">and</span></a>
<a class="sourceLine" id="cb61-40" title="40">        [ v <span class="op">==</span> <span class="fu">mconcat</span> [ value a1, value a2, value a3, value a4 ]</a>
<a class="sourceLine" id="cb61-41" title="41">        , valid a1, valid a2, valid a3, valid a4</a>
<a class="sourceLine" id="cb61-42" title="42">        ]</a>
<a class="sourceLine" id="cb61-43" title="43"></a>
<a class="sourceLine" id="cb61-44" title="44">    validateNode</a>
<a class="sourceLine" id="cb61-45" title="45"><span class="ot">      ::</span> ( <span class="dt">Valued</span> a )</a>
<a class="sourceLine" id="cb61-46" title="46">      <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Node</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb61-47" title="47">    validateNode valid x <span class="ot">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb61-48" title="48">      <span class="dt">Node2</span> v a1 a2 <span class="ot">-&gt;</span> <span class="fu">and</span></a>
<a class="sourceLine" id="cb61-49" title="49">        [ v <span class="op">==</span> <span class="fu">mconcat</span> [ value a1, value a2 ]</a>
<a class="sourceLine" id="cb61-50" title="50">        , valid a1, valid a2</a>
<a class="sourceLine" id="cb61-51" title="51">        ]</a>
<a class="sourceLine" id="cb61-52" title="52">      <span class="dt">Node3</span> v a1 a2 a3 <span class="ot">-&gt;</span> <span class="fu">and</span></a>
<a class="sourceLine" id="cb61-53" title="53">        [ v <span class="op">==</span> <span class="fu">mconcat</span> [ value a1, value a2, value a3 ]</a>
<a class="sourceLine" id="cb61-54" title="54">        , valid a1, valid a2, valid a3</a>
<a class="sourceLine" id="cb61-55" title="55">        ]</a></code></pre></div>
<div class="epigraph">
<p>&lt;blockquote&gt; I can whistle with my fingers, especially if I have a whistle.</p>
<p>&lt;footer&gt;Mitch Hedberg, &lt;cite&gt;Live at the Congress Theater in Chicago, 2004&lt;/cite&gt;&lt;/footer&gt; &lt;/blockquote&gt;</p>
</div>
</section>
</article>
</body>
</html>
