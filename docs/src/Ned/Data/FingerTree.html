<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Ned.Data.FingerTree</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style type="text/css">
  /* Kudos to Pascal Hertleif                  */
  /* https://gist.github.com/killercup/5917178 */
  
  html {
    font-size: 100%;
    overflow-y: scroll;
    -webkit-text-size-adjust: 100%;
    -ms-text-size-adjust: 100%;
  }
  
  body {
    color: #444;
    font-family: Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman', serif;
    font-size: 12px;
    line-height: 1.7;
    padding: 1em;
    margin: auto;
    max-width: 42em;
    background: #fefefe;
  }
  
  a {
    color: #0645ad;
    text-decoration: none;
  }
  
  a:visited {
    color: #0b0080;
  }
  
  a:hover {
    color: #06e;
  }
  
  a:active {
    color: #faa700;
  }
  
  a:focus {
    outline: thin dotted;
  }
  
  *::-moz-selection {
    background: rgba(255, 255, 0, 0.3);
    color: #000;
  }
  
  *::selection {
    background: rgba(255, 255, 0, 0.3);
    color: #000;
  }
  
  a::-moz-selection {
    background: rgba(255, 255, 0, 0.3);
    color: #0645ad;
  }
  
  a::selection {
    background: rgba(255, 255, 0, 0.3);
    color: #0645ad;
  }
  
  p {
    margin: 1em 0;
  }
  
  img {
    max-width: 100%;
  }
  
  h1, h2, h3, h4, h5, h6 {
    color: #111;
    line-height: 125%;
    margin-top: 2em;
    font-weight: normal;
  }
  
  h4, h5, h6 {
    font-weight: bold;
  }
  
  h1 {
    font-size: 2.5em;
  }
  
  h2 {
    font-size: 2em;
  }
  
  h3 {
    font-size: 1.5em;
  }
  
  h4 {
    font-size: 1.2em;
  }
  
  h5 {
    font-size: 1em;
  }
  
  h6 {
    font-size: 0.9em;
  }
  
  blockquote {
    display: block;
    color: #666666;
    margin: 0;
    padding-left: 3em;
    border-left: 0.5em #EEE solid;
  }
  
  hr {
    display: block;
    height: 2px;
    border: 0;
    border-top: 1px solid #aaa;
    border-bottom: 1px solid #eee;
    margin: 1em 0;
    padding: 0;
  }
  
  pre, code, kbd, samp {
    color: #000;
    font-family: monospace, monospace;
    _font-family: 'courier new', monospace;
    font-size: 0.98em;
  }
  
  pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }
  
  b, strong {
    font-weight: bold;
  }
  
  dfn {
    font-style: italic;
  }
  
  ins {
    background: #ff9;
    color: #000;
    text-decoration: none;
  }
  
  mark {
    background: #ff0;
    color: #000;
    font-style: italic;
    font-weight: bold;
  }
  
  sub, sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
  }
  
  sup {
    top: -0.5em;
  }
  
  sub {
    bottom: -0.25em;
  }
  
  ul, ol {
    margin: 1em 0;
    padding: 0 0 0 2em;
  }
  
  li p:last-child {
    margin-bottom: 0;
  }
  
  ul ul, ol ol {
    margin: .3em 0;
  }
  
  dl {
    margin-bottom: 1em;
  }
  
  dt {
    font-weight: bold;
    margin-bottom: .8em;
  }
  
  dd {
    margin: 0 0 .8em 2em;
  }
  
  dd:last-child {
    margin-bottom: 0;
  }
  
  img {
    border: 0;
    -ms-interpolation-mode: bicubic;
    vertical-align: middle;
  }
  
  figure {
    display: block;
    text-align: center;
    margin: 1em 0;
  }
  
  figure img {
    border: none;
    margin: 0 auto;
  }
  
  figcaption {
    font-size: 0.8em;
    font-style: italic;
    margin: 0 0 .8em;
  }
  
  table {
    margin-bottom: 2em;
    border-bottom: 1px solid #ddd;
    border-right: 1px solid #ddd;
    border-spacing: 0;
    border-collapse: collapse;
  }
  
  table th {
    padding: .2em 1em;
    background-color: #eee;
    border-top: 1px solid #ddd;
    border-left: 1px solid #ddd;
  }
  
  table td {
    padding: .2em 1em;
    border-top: 1px solid #ddd;
    border-left: 1px solid #ddd;
    vertical-align: top;
  }
  
  .author {
    font-size: 1.2em;
    text-align: center;
  }
  
  .sourceCode {
    background-color: #eee;
  }
  
  @media only screen and (min-width: 480px) {
    body {
      font-size: 14px;
    }
  }
  @media only screen and (min-width: 768px) {
    body {
      font-size: 16px;
    }
  }
  @media print {
    * {
      background: transparent !important;
      color: black !important;
      filter: none !important;
      -ms-filter: none !important;
    }
  
    body {
      font-size: 12pt;
      max-width: 100%;
    }
  
    a, a:visited {
      text-decoration: underline;
    }
  
    hr {
      height: 1px;
      border: 0;
      border-bottom: 1px solid black;
    }
  
    a[href]:after {
      content: " (" attr(href) ")";
    }
  
    abbr[title]:after {
      content: " (" attr(title) ")";
    }
  
    .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after {
      content: "";
    }
  
    pre, blockquote {
      border: 1px solid #999;
      padding-right: 1em;
      page-break-inside: avoid;
    }
  
    tr, img {
      page-break-inside: avoid;
    }
  
    img {
      max-width: 100% !important;
    }
  
    @page :left {
      margin: 15mm 20mm 15mm 10mm;
  }
  
    @page :right {
      margin: 15mm 10mm 15mm 20mm;
  }
  
    p, h2, h3 {
      orphans: 3;
      widows: 3;
    }
  
    h2, h3 {
      page-break-after: avoid;
    }
  }
  </style>
</head>
<body>
<header>
<h1 class="title">Ned.Data.FingerTree</h1>
</header>
<blockquote>
<p>I can whistle with my fingers, especially if I have a whistle.</p>
<cite>Mitch Hedberg</cite>
</blockquote>
<p>In this module we develop the core data structure of our text editor: <em>finger trees</em>.</p>
<h2 id="contents">Contents</h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#exposed-api">Exposed API</a></li>
<li><a href="#the-valued-class">The Valued Class</a></li>
<li><a href="#internal-types">Internal Types</a></li>
<li><a href="#finger-trees">Finger Trees</a>
<ul>
<li><a href="#cons-and-uncons">Cons and Uncons</a></li>
<li><a href="#concatenation">Concatenation</a></li>
<li><a href="#splitting">Splitting</a></li>
<li><a href="#taking-subsequences">Taking subsequences</a></li>
<li><a href="#debugging">Debugging</a></li>
</ul></li>
</ul>
<h1 id="introduction">Introduction</h1>
<p>The most basic requirement of a text editor is surely that it provide some mechanism for modeling and manipulating strings of characters. This mechanism had better be pretty robust and efficient, too, at least for common operations, since it will be doing most of the work during everyday use. Several different data structures have been developed for this purpose, including gap buffers and piece tables, but not all of them translate cleanly to a language like Haskell where mutation is not allowed (or at least very strictly controlled) and evaluation is lazy by default.</p>
<p>Choosing a data structure is all about making tradeoffs. We think about our particular application and what data and operations it needs, then choose a structure that makes those operations efficient. With that in mind, what exactly do we need for our simple text editor? I can think of a few things.</p>
<ol type="1">
<li>Our data structure should essentially model a list of characters; that is, whatever weird branching or in-place mutating business is happening behind the scenes, the API is more or less that of lists.</li>
<li>Typically when editing text we’ve got a distinguished position called the <em>cursor</em> where our editing actions (insert, delete) have immediate effect. It is vital that interacting with and moving the cursor around be blazing fast, since that’s where most of the work happens.</li>
<li>Another very common action when editing text is <em>search</em>. This takes a few forms – jumping to a particular line and column position, or searching for a literal substring, or looking for matches to a given regular expression.</li>
</ol>
<p>There are others – fast syntax highlighting is nice, for instance – but these are the absolute essentials.</p>
<p>Lucky for us, there’s a powerful data structure that gives us all three, based on <em>finger trees</em>. These were introduced in the present form in the paper <a href="http://www.staff.city.ac.uk/~ross/papers/FingerTree.html"><em>Finger trees: a simple general-purpose data structure</em></a> by Hinze and Paterson. The funny name refers to the fact that trees of this type have <em>fingers</em> – distinguished locations where read and write access is cheap.</p>
<p>In this module we’ll develop an API for working with finger trees by following the Hinze and Paterson paper pretty closely. There are existing implementations of this that we could use instead, but finger trees are quite elegant and seeing how they work by rolling our own is a worthwhile exercise.</p>
<p>This code uses the following compiler extensions:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">    MultiParamTypeClasses</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">  , ScopedTypeVariables</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">  , FlexibleInstances</span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="ot">  , DeriveGeneric</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="ot">  , InstanceSigs</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="ot">  , Rank2Types</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"><span class="ot">#-}</span></a></code></pre></div>
<p>Some of these are essential, while others are just convenient. We will address them as we come to them.</p>
<h1 id="exposed-api">Exposed API</h1>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Ned.Data.FingerTree</span> (</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">  <span class="co">-- ** Valued</span></a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="dt">Valued</span>(<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  , <span class="dt">Count</span>(<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb2-5" data-line-number="5"></a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  <span class="co">-- ** FingerTree</span></a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  , <span class="dt">FingerTree</span>()</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">  , fmapFT</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  <span class="co">-- * Constructors</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  , fromListFT</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  , leaf</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  , cons</a>
<a class="sourceLine" id="cb2-14" data-line-number="14">  , snoc</a>
<a class="sourceLine" id="cb2-15" data-line-number="15"></a>
<a class="sourceLine" id="cb2-16" data-line-number="16">  <span class="co">-- * Destructors</span></a>
<a class="sourceLine" id="cb2-17" data-line-number="17">  , uncons</a>
<a class="sourceLine" id="cb2-18" data-line-number="18">  , unsnoc</a>
<a class="sourceLine" id="cb2-19" data-line-number="19"></a>
<a class="sourceLine" id="cb2-20" data-line-number="20">  <span class="co">-- * Operators</span></a>
<a class="sourceLine" id="cb2-21" data-line-number="21">  , reverseFT</a>
<a class="sourceLine" id="cb2-22" data-line-number="22">  , remeasureFT</a>
<a class="sourceLine" id="cb2-23" data-line-number="23">  , takeWhileValueFT</a>
<a class="sourceLine" id="cb2-24" data-line-number="24">  , breakPrefixWhileValueFT</a>
<a class="sourceLine" id="cb2-25" data-line-number="25"></a>
<a class="sourceLine" id="cb2-26" data-line-number="26">  <span class="co">-- * Queries</span></a>
<a class="sourceLine" id="cb2-27" data-line-number="27">  , isEmptyFT</a>
<a class="sourceLine" id="cb2-28" data-line-number="28">  , notEmptyFT</a>
<a class="sourceLine" id="cb2-29" data-line-number="29"></a>
<a class="sourceLine" id="cb2-30" data-line-number="30">  <span class="co">-- * Splitting</span></a>
<a class="sourceLine" id="cb2-31" data-line-number="31">  , splitFT</a>
<a class="sourceLine" id="cb2-32" data-line-number="32">  , splitTree</a>
<a class="sourceLine" id="cb2-33" data-line-number="33">  , takeFromSplitFT</a>
<a class="sourceLine" id="cb2-34" data-line-number="34"></a>
<a class="sourceLine" id="cb2-35" data-line-number="35">  <span class="co">-- ** Testing and Debugging</span></a>
<a class="sourceLine" id="cb2-36" data-line-number="36">  , toListDebugFT</a>
<a class="sourceLine" id="cb2-37" data-line-number="37">  , depthFT</a>
<a class="sourceLine" id="cb2-38" data-line-number="38">  , showInternalFT</a>
<a class="sourceLine" id="cb2-39" data-line-number="39">  , validateFT</a>
<a class="sourceLine" id="cb2-40" data-line-number="40">) <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-41" data-line-number="41"></a>
<a class="sourceLine" id="cb2-42" data-line-number="42"><span class="kw">import</span> <span class="dt">GHC.Generics</span></a>
<a class="sourceLine" id="cb2-43" data-line-number="43"></a>
<a class="sourceLine" id="cb2-44" data-line-number="44"><span class="kw">import</span> <span class="dt">Data.Monoid</span></a>
<a class="sourceLine" id="cb2-45" data-line-number="45"><span class="kw">import</span> <span class="dt">Data.Foldable</span></a>
<a class="sourceLine" id="cb2-46" data-line-number="46"><span class="kw">import</span> <span class="dt">Data.List</span> (unwords)</a></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Debug.Trace</span></a></code></pre></div>
<h1 id="the-valued-class">The Valued Class</h1>
<p>The secret power of finger trees is that they aren’t just <em>a</em> data structure. They are a whole <em>family</em> of data structures parameterized by a monoid. Different choices of this monoid give structures with different characteristics, but all are constructed and accessed in the same way.</p>
<p>The <em>content</em> type <code>a</code> of a finger tree must have a distinguished mapping into some monoid type <code>m</code>. We can enforce this in Haskell using a typeclass with two parameters. It looks a little bit like we’re saying that <code>a</code> has an <code>m</code>-valuation, so we’ll call this class <code>Valued</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="kw">class</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  ( <span class="dt">Monoid</span> m</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Valued</span> m a</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="ot">    value ::</span> a <span class="ot">-&gt;</span> m</a></code></pre></div>
<p>This is where the <code>MultiParamTypeClasses</code> extension is needed. And the extension is genuinely necessary here; in general we may want multiple valuations on the same <code>a</code>, and likewise multiple types valued by the same <code>m</code>. So as far as I can see we can’t drop MPTC in favor of some other mechanism like associated type families.</p>
<p>Note that the <code>Valued</code> class does not impose any laws. It can’t, really, because at this level of abstraction there’s no structure on <code>a</code> to relate to that of <code>m</code>. Normally this is a design smell – generally typeclasses should come with laws – but here we’ll let it slide.</p>
<p>Now lets define a concrete monoid and <code>Valued</code> instance for testing. Note that while <code>Valued</code> is a many-to-many type class constraint, for most applications we’ll want to define a specific monoid type <code>m</code> just for that purpose – even if it’s just a <code>newtype</code> wrapper around some other type. For example, here’s a wrapper around <code>Int</code> that is a monoid under addition.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Count</span></a>
<a class="sourceLine" id="cb5-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Count</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>, <span class="dt">Generic</span>)</a>
<a class="sourceLine" id="cb5-4" data-line-number="4"></a>
<a class="sourceLine" id="cb5-5" data-line-number="5"><span class="kw">instance</span> <span class="dt">Semigroup</span> <span class="dt">Count</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-6" data-line-number="6">  (<span class="dt">Count</span> a) <span class="fu">&lt;&gt;</span> (<span class="dt">Count</span> b) <span class="fu">=</span> <span class="dt">Count</span> (a <span class="fu">+</span> b)</a>
<a class="sourceLine" id="cb5-7" data-line-number="7"></a>
<a class="sourceLine" id="cb5-8" data-line-number="8"><span class="kw">instance</span> <span class="dt">Monoid</span> <span class="dt">Count</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb5-9" data-line-number="9">  mempty <span class="fu">=</span> <span class="dt">Count</span> <span class="dv">0</span></a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Valued</span> <span class="dt">Count</span> <span class="dt">Char</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2">  value _ <span class="fu">=</span> <span class="dt">Count</span> <span class="dv">1</span></a></code></pre></div>
<h1 id="internal-types">Internal Types</h1>
<p>Finger trees exhibit a phenomenon called <em>polymorphic recursion</em>, where at each level the ‘inner’ and ‘outer’ structures have different types. First we have the ‘fingers’ to the left and the right, which can number from one to four on each side. We represent this with the <code>Some</code> class.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Some</span> m a</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Only1</span> m a</a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Only2</span> m a a</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">Only3</span> m a a a</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">Only4</span> m a a a a</a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Note the <code>m</code> parameter; this is the cached <code>value</code> of the internal data.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb8-2" data-line-number="2">  ( <span class="dt">Monoid</span> m</a>
<a class="sourceLine" id="cb8-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Valued</span> m (<span class="dt">Some</span> m a)</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    value w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">      <span class="dt">Only1</span> m _ <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">      <span class="dt">Only2</span> m _ _ <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">      <span class="dt">Only3</span> m _ _ _ <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb8-9" data-line-number="9">      <span class="dt">Only4</span> m _ _ _ _ <span class="ot">-&gt;</span> m</a></code></pre></div>
<p>To maintain the invariant that our cached <code>value</code> is accurate, it’s important that we only create <code>Some</code> values using the following <em>smart constructors</em>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="ot">only1 ::</span> (<span class="dt">Valued</span> m a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> m a</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">only1 a1 <span class="fu">=</span> <span class="dt">Only1</span> m a1</a>
<a class="sourceLine" id="cb9-3" data-line-number="3">  <span class="kw">where</span> m <span class="fu">=</span> value a1</a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5">only2</a>
<a class="sourceLine" id="cb9-6" data-line-number="6"><span class="ot">  ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> m a</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">only2 a1 a2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    m <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb9-11" data-line-number="11">      [ value a1, value a2 ]</a>
<a class="sourceLine" id="cb9-12" data-line-number="12">  <span class="kw">in</span> <span class="dt">Only2</span> m a1 a2 </a>
<a class="sourceLine" id="cb9-13" data-line-number="13"></a>
<a class="sourceLine" id="cb9-14" data-line-number="14"><span class="ot">only3 ::</span> (<span class="dt">Valued</span> m a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> m a</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">only3 a1 a2 a3 <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-16" data-line-number="16">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb9-17" data-line-number="17">    m <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb9-18" data-line-number="18">      [ value a1, value a2, value a3 ]</a>
<a class="sourceLine" id="cb9-19" data-line-number="19">  <span class="kw">in</span> <span class="dt">Only3</span> m a1 a2 a3 </a>
<a class="sourceLine" id="cb9-20" data-line-number="20"></a>
<a class="sourceLine" id="cb9-21" data-line-number="21"><span class="ot">only4 ::</span> (<span class="dt">Valued</span> m a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Some</span> m a</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">only4 a1 a2 a3 a4 <span class="fu">=</span></a>
<a class="sourceLine" id="cb9-23" data-line-number="23">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb9-24" data-line-number="24">    m <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb9-25" data-line-number="25">      [ value a1, value a2, value a3, value a4 ]</a>
<a class="sourceLine" id="cb9-26" data-line-number="26">  <span class="kw">in</span> <span class="dt">Only4</span> m a1 a2 a3 a4 </a></code></pre></div>
<p>These constructors are not exposed outside this module since they are only used in the internal representation. For instance, we use them to define something like <code>fmap</code> for <code>Some</code> – although we can’t use the <code>Functor</code> typeclass for this due to the <code>Valued</code> constraint.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1">fmapSome</a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> m1 a1, <span class="dt">Valued</span> m2 a2 )</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">  <span class="ot">=&gt;</span> (a1 <span class="ot">-&gt;</span> a2) <span class="ot">-&gt;</span> <span class="dt">Some</span> m1 a1 <span class="ot">-&gt;</span> <span class="dt">Some</span> m2 a2</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">fmapSome f x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb10-5" data-line-number="5">  <span class="dt">Only1</span> _ u1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    only1 (f u1)</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  <span class="dt">Only2</span> _ u1 u2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-8" data-line-number="8">    only2 (f u1) (f u2)</a>
<a class="sourceLine" id="cb10-9" data-line-number="9">  <span class="dt">Only3</span> _ u1 u2 u3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    only3 (f u1) (f u2) (f u3)</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">  <span class="dt">Only4</span> _ u1 u2 u3 u4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">    only4 (f u1) (f u2) (f u3) (f u4)</a></code></pre></div>
<p>Next we have a <code>Foldable</code> instance (this is where we use <code>InstanceSigs</code> for clarity):</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Foldable</span> (<span class="dt">Some</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb11-2" data-line-number="2"> toList</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="ot">   ::</span> <span class="dt">Some</span> m a <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"> toList w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">   <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span> [a1]</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">   <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span> [a1, a2]</a>
<a class="sourceLine" id="cb11-7" data-line-number="7">   <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span> [a1, a2, a3]</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">   <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span> [a1, a2, a3, a4]</a>
<a class="sourceLine" id="cb11-9" data-line-number="9"></a>
<a class="sourceLine" id="cb11-10" data-line-number="10"> foldr</a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="ot">   ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Some</span> m a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb11-12" data-line-number="12"> foldr f b w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-13" data-line-number="13">   <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-14" data-line-number="14">     f a1 b</a>
<a class="sourceLine" id="cb11-15" data-line-number="15">   <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-16" data-line-number="16">     f a1 (f a2 b)</a>
<a class="sourceLine" id="cb11-17" data-line-number="17">   <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-18" data-line-number="18">     f a1 (f a2 (f a3 b))</a>
<a class="sourceLine" id="cb11-19" data-line-number="19">   <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-20" data-line-number="20">     f a1 (f a2 (f a3 (f a4 b)))</a>
<a class="sourceLine" id="cb11-21" data-line-number="21"></a>
<a class="sourceLine" id="cb11-22" data-line-number="22"> foldl</a>
<a class="sourceLine" id="cb11-23" data-line-number="23"><span class="ot">   ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Some</span> m a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb11-24" data-line-number="24"> foldl f b w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb11-25" data-line-number="25">   <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-26" data-line-number="26">     f b a1</a>
<a class="sourceLine" id="cb11-27" data-line-number="27">   <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-28" data-line-number="28">     f (f b a1) a2</a>
<a class="sourceLine" id="cb11-29" data-line-number="29">   <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-30" data-line-number="30">     f (f (f b a1) a2) a3</a>
<a class="sourceLine" id="cb11-31" data-line-number="31">   <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb11-32" data-line-number="32">     f (f (f (f b a1) a2) a3) a4</a></code></pre></div>
<p>This instance is mainly used as a helper for defining the instance for <code>FingerTree</code>.</p>
<p>Next we have the nested tree type. Finger trees are basically rearranged 2-3 trees, and the nested <code>Node</code> type represents internal branching nodes of this kind.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Node</span> m a</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"> <span class="fu">=</span> <span class="dt">Node2</span> m a a</a>
<a class="sourceLine" id="cb12-3" data-line-number="3"> <span class="fu">|</span> <span class="dt">Node3</span> m a a a</a>
<a class="sourceLine" id="cb12-4" data-line-number="4"> <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>Again we cache the value of the internal data, using smart constructors to maintain the integrity of the cache.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb13-2" data-line-number="2">  ( <span class="dt">Monoid</span> m</a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Valued</span> m (<span class="dt">Node</span> m a)</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">    value w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-6" data-line-number="6">      <span class="dt">Node2</span> m _ _ <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">      <span class="dt">Node3</span> m _ _ _ <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb13-8" data-line-number="8"></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">node2</a>
<a class="sourceLine" id="cb13-10" data-line-number="10"><span class="ot">  ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Node</span> m a</a>
<a class="sourceLine" id="cb13-12" data-line-number="12">node2 a1 a2 <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-13" data-line-number="13">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb13-14" data-line-number="14">    m <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb13-15" data-line-number="15">      [ value a1, value a2 ]</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">  <span class="kw">in</span> <span class="dt">Node2</span> m a1 a2</a>
<a class="sourceLine" id="cb13-17" data-line-number="17"></a>
<a class="sourceLine" id="cb13-18" data-line-number="18">node3</a>
<a class="sourceLine" id="cb13-19" data-line-number="19"><span class="ot">  ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb13-20" data-line-number="20">  <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Node</span> m a</a>
<a class="sourceLine" id="cb13-21" data-line-number="21">node3 a1 a2 a3 <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-22" data-line-number="22">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb13-23" data-line-number="23">    m <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb13-24" data-line-number="24">      [ value a1, value a2, value a3 ]</a>
<a class="sourceLine" id="cb13-25" data-line-number="25">  <span class="kw">in</span> <span class="dt">Node3</span> m a1 a2 a3</a></code></pre></div>
<p>From here we can give something like <code>fmap</code> for <code>Node</code>, again outside of the usual typeclass because of the <code>Valued</code> constraint.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1">fmapNode</a>
<a class="sourceLine" id="cb14-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> m1 a1, <span class="dt">Valued</span> m2 a2 )</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  <span class="ot">=&gt;</span> (a1 <span class="ot">-&gt;</span> a2) <span class="ot">-&gt;</span> <span class="dt">Node</span> m1 a1 <span class="ot">-&gt;</span> <span class="dt">Node</span> m2 a2</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">fmapNode f x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">  <span class="dt">Node2</span> _ u1 u2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">    node2 (f u1) (f u2)</a>
<a class="sourceLine" id="cb14-7" data-line-number="7">  <span class="dt">Node3</span> _ u1 u2 u3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-8" data-line-number="8">    node3 (f u1) (f u2) (f u3)</a></code></pre></div>
<p>And we need a <code>Foldable</code> instance:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1"><span class="kw">instance</span> <span class="dt">Foldable</span> (<span class="dt">Node</span> m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb15-2" data-line-number="2"> foldr</a>
<a class="sourceLine" id="cb15-3" data-line-number="3"><span class="ot">   ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Node</span> m a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb15-4" data-line-number="4"> foldr f b w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-5" data-line-number="5">   <span class="dt">Node2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">     f a1 (f a2 b)</a>
<a class="sourceLine" id="cb15-7" data-line-number="7">   <span class="dt">Node3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">     f a1 (f a2 (f a3 b))</a>
<a class="sourceLine" id="cb15-9" data-line-number="9"></a>
<a class="sourceLine" id="cb15-10" data-line-number="10"> foldl</a>
<a class="sourceLine" id="cb15-11" data-line-number="11"><span class="ot">   ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">Node</span> m a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb15-12" data-line-number="12"> foldl f b w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">   <span class="dt">Node2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-14" data-line-number="14">     f (f b a1) a2</a>
<a class="sourceLine" id="cb15-15" data-line-number="15">   <span class="dt">Node3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-16" data-line-number="16">     f (f (f b a1) a2) a3</a></code></pre></div>
<p>Finally, note that <code>Node</code> can be thought of as a strict subset of <code>Some</code>. We use a helper function, <code>toSome</code>, to make this formal.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">toSome</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">Node</span> m a <span class="ot">-&gt;</span> <span class="dt">Some</span> m a</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">toSome w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  <span class="dt">Node2</span> _ a1 a2 <span class="ot">-&gt;</span> only2 a1 a2</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">  <span class="dt">Node3</span> _ a1 a2 a3 <span class="ot">-&gt;</span> only3 a1 a2 a3</a></code></pre></div>
<h1 id="finger-trees">Finger Trees</h1>
<p>Now for the big show. A finger tree is either empty, or consists of a single node (with its cached value), or has some left and right fingers with a nested finger tree in the middle (with the cached product of their values).</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">data</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb17-2" data-line-number="2"> <span class="fu">=</span> <span class="dt">Stump</span></a>
<a class="sourceLine" id="cb17-3" data-line-number="3"> <span class="fu">|</span> <span class="dt">Leaf</span> m a</a>
<a class="sourceLine" id="cb17-4" data-line-number="4"> <span class="fu">|</span> <span class="dt">Branch</span> m (<span class="dt">Some</span> m a) (<span class="dt">FingerTree</span> m (<span class="dt">Node</span> m a)) (<span class="dt">Some</span> m a)</a></code></pre></div>
<p>As with <code>Some</code> and <code>Node</code>, <code>FingerTree</code> inherits an instance of <code>Valued</code> and to maintain integrity we must only use smart constructors to define them.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb18-2" data-line-number="2">  ( <span class="dt">Valued</span> m a</a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Valued</span> m (<span class="dt">FingerTree</span> m a)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">    value w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-6" data-line-number="6">      <span class="dt">Stump</span>          <span class="ot">-&gt;</span> mempty</a>
<a class="sourceLine" id="cb18-7" data-line-number="7">      <span class="dt">Leaf</span>   m _     <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb18-8" data-line-number="8">      <span class="dt">Branch</span> m _ _ _ <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb18-9" data-line-number="9"></a>
<a class="sourceLine" id="cb18-10" data-line-number="10">stump</a>
<a class="sourceLine" id="cb18-11" data-line-number="11"><span class="ot">  ::</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">stump <span class="fu">=</span> <span class="dt">Stump</span></a>
<a class="sourceLine" id="cb18-13" data-line-number="13"></a>
<a class="sourceLine" id="cb18-14" data-line-number="14">leaf</a>
<a class="sourceLine" id="cb18-15" data-line-number="15"><span class="ot">  ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb18-16" data-line-number="16">  <span class="ot">=&gt;</span> a</a>
<a class="sourceLine" id="cb18-17" data-line-number="17">  <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">leaf a <span class="fu">=</span> <span class="dt">Leaf</span> m a</a>
<a class="sourceLine" id="cb18-19" data-line-number="19">  <span class="kw">where</span> m <span class="fu">=</span> value a</a>
<a class="sourceLine" id="cb18-20" data-line-number="20"></a>
<a class="sourceLine" id="cb18-21" data-line-number="21">branch</a>
<a class="sourceLine" id="cb18-22" data-line-number="22"><span class="ot">  ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb18-23" data-line-number="23">  <span class="ot">=&gt;</span> <span class="dt">Some</span> m a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m (<span class="dt">Node</span> m a) <span class="ot">-&gt;</span> <span class="dt">Some</span> m a</a>
<a class="sourceLine" id="cb18-24" data-line-number="24">  <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb18-25" data-line-number="25">branch heads mids lasts <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-26" data-line-number="26">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb18-27" data-line-number="27">     m <span class="fu">=</span> mconcat</a>
<a class="sourceLine" id="cb18-28" data-line-number="28">       [ value heads, value mids, value lasts ]</a>
<a class="sourceLine" id="cb18-29" data-line-number="29">  <span class="kw">in</span> <span class="dt">Branch</span> m heads mids lasts</a></code></pre></div>
<p>And we can define something like <code>fmap</code> for finger trees:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">fmapFT</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">  ::</span> forall m1 m2 a1 a2</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">   <span class="fu">.</span> ( <span class="dt">Valued</span> m1 a1, <span class="dt">Valued</span> m2 a2 )</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  <span class="ot">=&gt;</span> (a1 <span class="ot">-&gt;</span> a2) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m1 a1 <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m2 a2</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">fmapFT f x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-6" data-line-number="6">  <span class="dt">Stump</span> <span class="ot">-&gt;</span> stump</a>
<a class="sourceLine" id="cb19-7" data-line-number="7">  <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> leaf (f a)</a>
<a class="sourceLine" id="cb19-8" data-line-number="8">  <span class="dt">Branch</span> _ as bs cs <span class="ot">-&gt;</span> branch</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">    (fmapSome f as)</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">    (fmapFT (fmapNode f) bs)</a>
<a class="sourceLine" id="cb19-11" data-line-number="11">    (fmapSome f cs)</a></code></pre></div>
<p>With this version of <code>fmap</code> we can do something interesting. Mapping with <code>id</code> can swap out the cached value monoid.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" data-line-number="1">remeasureFT</a>
<a class="sourceLine" id="cb20-2" data-line-number="2"><span class="ot"> ::</span> forall m1 m2 a</a>
<a class="sourceLine" id="cb20-3" data-line-number="3">  <span class="fu">.</span> ( <span class="dt">Valued</span> m1 a, <span class="dt">Valued</span> m2 a )</a>
<a class="sourceLine" id="cb20-4" data-line-number="4"> <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> m1 a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m2 a</a>
<a class="sourceLine" id="cb20-5" data-line-number="5">remeasureFT <span class="fu">=</span> fmapFT id</a></code></pre></div>
<p>Next we define some simple structural queries on finger trees. First to detect whether the tree is empty:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" data-line-number="1">isEmptyFT</a>
<a class="sourceLine" id="cb21-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb21-3" data-line-number="3">isEmptyFT x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-4" data-line-number="4">  <span class="dt">Stump</span> <span class="ot">-&gt;</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb21-5" data-line-number="5">  _     <span class="ot">-&gt;</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb21-6" data-line-number="6"></a>
<a class="sourceLine" id="cb21-7" data-line-number="7">notEmptyFT</a>
<a class="sourceLine" id="cb21-8" data-line-number="8"><span class="ot">  ::</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb21-9" data-line-number="9">notEmptyFT x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb21-10" data-line-number="10">  <span class="dt">Stump</span> <span class="ot">-&gt;</span> <span class="dt">False</span></a>
<a class="sourceLine" id="cb21-11" data-line-number="11">  _     <span class="ot">-&gt;</span> <span class="dt">True</span></a></code></pre></div>
<p>We can also compute the ‘depth’ of the tree. This function is only exposed for testing purposes. During normal use the internal structure of a finger tree is of no interest to us, but this will help us to ensure good test coverage later.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" data-line-number="1">depthFT</a>
<a class="sourceLine" id="cb22-2" data-line-number="2"><span class="ot"> ::</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb22-3" data-line-number="3">depthFT x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb22-4" data-line-number="4"> <span class="dt">Stump</span> <span class="ot">-&gt;</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb22-5" data-line-number="5"> <span class="dt">Leaf</span> _ _ <span class="ot">-&gt;</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb22-6" data-line-number="6"> <span class="dt">Branch</span> _ _ z _ <span class="ot">-&gt;</span> <span class="dv">1</span> <span class="fu">+</span> depthFT z</a></code></pre></div>
<p>Now we can define a <code>Foldable</code> instance:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb23-2" data-line-number="2">  <span class="dt">Foldable</span> (<span class="dt">FingerTree</span> m)</a>
<a class="sourceLine" id="cb23-3" data-line-number="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-4" data-line-number="4">    foldr</a>
<a class="sourceLine" id="cb23-5" data-line-number="5"><span class="ot">      ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb23-6" data-line-number="6">    foldr f b w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-7" data-line-number="7">      <span class="dt">Stump</span> <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb23-8" data-line-number="8">      <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> f a b</a>
<a class="sourceLine" id="cb23-9" data-line-number="9">      <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb23-10" data-line-number="10">        foldr f</a>
<a class="sourceLine" id="cb23-11" data-line-number="11">          (foldr (flip (foldr f)) (foldr f b as3) as2) as1</a>
<a class="sourceLine" id="cb23-12" data-line-number="12"></a>
<a class="sourceLine" id="cb23-13" data-line-number="13">    foldl</a>
<a class="sourceLine" id="cb23-14" data-line-number="14"><span class="ot">      ::</span> (b <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb23-15" data-line-number="15">    foldl f b w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb23-16" data-line-number="16">      <span class="dt">Stump</span> <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb23-17" data-line-number="17">      <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> f b a</a>
<a class="sourceLine" id="cb23-18" data-line-number="18">      <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb23-19" data-line-number="19">        foldl f</a>
<a class="sourceLine" id="cb23-20" data-line-number="20">          (foldl (foldl f) (foldl f b as1) as2) as3</a></code></pre></div>
<p>Note that we didn’t derive the <code>Eq</code> instance for <code>FingerTree</code>. This is because in some sense the tree structure itself is only incidental, used for maintaining the fingers and caching values. The meat of the structure is the left-to-right traversal of the leaf nodes and fingers, and the derived (structural) equality instance would be too granular. To get around this we’ll instead check for equality on <code>FingerTree</code>s by converting to lists first, using the <code>Foldable</code> instance.</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb24-2" data-line-number="2">  ( <span class="dt">Eq</span> a</a>
<a class="sourceLine" id="cb24-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">FingerTree</span> m a)</a>
<a class="sourceLine" id="cb24-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb24-5" data-line-number="5">    a <span class="fu">==</span> b <span class="fu">=</span></a>
<a class="sourceLine" id="cb24-6" data-line-number="6">      (toList a) <span class="fu">==</span> (toList b)</a></code></pre></div>
<p>As every <code>Node</code> can be converted into a <code>Some</code>, every <code>Some</code> can be converted to a <code>FingerTree</code>. This conversion will come in handy later so we define it here, though this code is not exposed outside of this module.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" data-line-number="1">someToFingerTree</a>
<a class="sourceLine" id="cb25-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb25-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">Some</span> m a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb25-4" data-line-number="4">someToFingerTree w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-5" data-line-number="5">  <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb25-6" data-line-number="6">    leaf a1</a>
<a class="sourceLine" id="cb25-7" data-line-number="7">  <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb25-8" data-line-number="8">    branch (only1 a1) stump (only1 a2)</a>
<a class="sourceLine" id="cb25-9" data-line-number="9">  <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb25-10" data-line-number="10">    branch (only2 a1 a2) stump (only1 a3)</a>
<a class="sourceLine" id="cb25-11" data-line-number="11">  <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb25-12" data-line-number="12">    branch (only2 a1 a2) stump (only2 a3 a4)</a>
<a class="sourceLine" id="cb25-13" data-line-number="13"></a>
<a class="sourceLine" id="cb25-14" data-line-number="14">maybeToFingerTree</a>
<a class="sourceLine" id="cb25-15" data-line-number="15"><span class="ot">  ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb25-16" data-line-number="16">  <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Some</span> m a) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb25-17" data-line-number="17">maybeToFingerTree w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb25-18" data-line-number="18">  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> stump</a>
<a class="sourceLine" id="cb25-19" data-line-number="19">  <span class="dt">Just</span> z <span class="ot">-&gt;</span> someToFingerTree z</a></code></pre></div>
<h2 id="cons-and-uncons">Cons and Uncons</h2>
<p><code>cons</code> is a traditional name for the function that appends an item to the head of the list; it originates in Lisp. For finger trees, if the left side does not have a full complement of fingers then <code>cons</code> is a constant time operation. If it does, then we take some of the fingers and recursively <code>cons</code> them as a node to the inner tree.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" data-line-number="1">cons</a>
<a class="sourceLine" id="cb26-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb26-3" data-line-number="3"> <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb26-4" data-line-number="4">cons u w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb26-5" data-line-number="5"> <span class="dt">Stump</span> <span class="ot">-&gt;</span> leaf u</a>
<a class="sourceLine" id="cb26-6" data-line-number="6"> <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> branch (only1 u) stump (only1 a)</a>
<a class="sourceLine" id="cb26-7" data-line-number="7"> <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span> <span class="kw">case</span> as1 <span class="kw">of</span></a>
<a class="sourceLine" id="cb26-8" data-line-number="8">   <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb26-9" data-line-number="9">     branch (only2 u a1) as2 as3</a>
<a class="sourceLine" id="cb26-10" data-line-number="10">   <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb26-11" data-line-number="11">     branch (only3 u a1 a2) as2 as3</a>
<a class="sourceLine" id="cb26-12" data-line-number="12">   <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb26-13" data-line-number="13">     branch (only4 u a1 a2 a3) as2 as3</a>
<a class="sourceLine" id="cb26-14" data-line-number="14">   <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb26-15" data-line-number="15">     branch (only2 u a1) (cons (node3 a2 a3 a4) as2) as3</a></code></pre></div>
<p>With <code>cons</code> in hand we can now write a helper for converting lists into finger trees; this is handy for testing.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" data-line-number="1">fromListFT</a>
<a class="sourceLine" id="cb27-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb27-3" data-line-number="3"> <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb27-4" data-line-number="4">fromListFT <span class="fu">=</span> foldr cons stump</a></code></pre></div>
<p>And with <code>fromListFT</code> we can also give a convenient <code>Show</code> instance. Note that the derived instance would include a lot of superfluous information about the internal structure of the tree.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb28-2" data-line-number="2">  ( <span class="dt">Show</span> a</a>
<a class="sourceLine" id="cb28-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">FingerTree</span> m a)</a>
<a class="sourceLine" id="cb28-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-5" data-line-number="5">    show a <span class="fu">=</span> <span class="st">&quot;fromListFT &quot;</span> <span class="fu">++</span> show (toList a)</a></code></pre></div>
<p>The mirror operation – appending on the right – is defined similarly. This is called <code>snoc</code>.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" data-line-number="1">snoc</a>
<a class="sourceLine" id="cb29-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb29-3" data-line-number="3"> <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb29-4" data-line-number="4">snoc u w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb29-5" data-line-number="5"> <span class="dt">Stump</span> <span class="ot">-&gt;</span> leaf u</a>
<a class="sourceLine" id="cb29-6" data-line-number="6"> <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> branch (only1 a) stump (only1 u)</a>
<a class="sourceLine" id="cb29-7" data-line-number="7"> <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span> <span class="kw">case</span> as3 <span class="kw">of</span></a>
<a class="sourceLine" id="cb29-8" data-line-number="8">   <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb29-9" data-line-number="9">     branch as1 as2 (only2 a1 u)</a>
<a class="sourceLine" id="cb29-10" data-line-number="10">   <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb29-11" data-line-number="11">     branch as1 as2 (only3 a1 a2 u)</a>
<a class="sourceLine" id="cb29-12" data-line-number="12">   <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb29-13" data-line-number="13">     branch as1 as2 (only4 a1 a2 a3 u)</a>
<a class="sourceLine" id="cb29-14" data-line-number="14">   <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb29-15" data-line-number="15">     branch as1 (snoc (node3 a1 a2 a3) as2) (only2 a4 u)</a></code></pre></div>
<p>With <code>snoc</code> we can reverse the tree.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" data-line-number="1">reverseFT</a>
<a class="sourceLine" id="cb30-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb30-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb30-4" data-line-number="4">reverseFT <span class="fu">=</span> foldr snoc mempty</a></code></pre></div>
<p><code>cons</code> also has an inverse, called <code>uncons</code>. (The inverse here is not literal, but can be made so if instead of cons we consider the coproduct of cons with the constant <code>stump</code> function, but for our purposes here that’s splitting hairs.)</p>
<p>Like <code>cons</code>, <code>uncons</code> is very fast if the left side of the tree has fingers to spare. But if not, we have to do a kind of recursive borrowing.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" data-line-number="1">uncons</a>
<a class="sourceLine" id="cb31-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb31-3" data-line-number="3"> <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb31-4" data-line-number="4"> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">FingerTree</span> m a)</a>
<a class="sourceLine" id="cb31-5" data-line-number="5">uncons w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb31-6" data-line-number="6"> <span class="dt">Stump</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb31-7" data-line-number="7"> <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, stump)</a>
<a class="sourceLine" id="cb31-8" data-line-number="8"> <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb31-9" data-line-number="9">   <span class="kw">let</span> (a, as) <span class="fu">=</span> uncons&#39; as1</a>
<a class="sourceLine" id="cb31-10" data-line-number="10">   <span class="kw">in</span> <span class="dt">Just</span> (a, borrowL as as2 as3)</a>
<a class="sourceLine" id="cb31-11" data-line-number="11"></a>
<a class="sourceLine" id="cb31-12" data-line-number="12">uncons&#39;</a>
<a class="sourceLine" id="cb31-13" data-line-number="13"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb31-14" data-line-number="14"> <span class="ot">=&gt;</span> <span class="dt">Some</span> m a</a>
<a class="sourceLine" id="cb31-15" data-line-number="15"> <span class="ot">-&gt;</span> (a, <span class="dt">Maybe</span> (<span class="dt">Some</span> m a))</a>
<a class="sourceLine" id="cb31-16" data-line-number="16">uncons&#39; w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb31-17" data-line-number="17"> <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span> (a1, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb31-18" data-line-number="18"> <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span> (a1, <span class="dt">Just</span> (only1 a2))</a>
<a class="sourceLine" id="cb31-19" data-line-number="19"> <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span> (a1, <span class="dt">Just</span> (only2 a2 a3))</a>
<a class="sourceLine" id="cb31-20" data-line-number="20"> <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span> (a1, <span class="dt">Just</span> (only3 a2 a3 a4))</a>
<a class="sourceLine" id="cb31-21" data-line-number="21"></a>
<a class="sourceLine" id="cb31-22" data-line-number="22">borrowL</a>
<a class="sourceLine" id="cb31-23" data-line-number="23"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb31-24" data-line-number="24"> <span class="ot">=&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Some</span> m a)</a>
<a class="sourceLine" id="cb31-25" data-line-number="25"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m (<span class="dt">Node</span> m a)</a>
<a class="sourceLine" id="cb31-26" data-line-number="26"> <span class="ot">-&gt;</span> <span class="dt">Some</span> m a</a>
<a class="sourceLine" id="cb31-27" data-line-number="27"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb31-28" data-line-number="28">borrowL w as2 as3 <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb31-29" data-line-number="29"> <span class="dt">Just</span> as1 <span class="ot">-&gt;</span> branch as1 as2 as3</a>
<a class="sourceLine" id="cb31-30" data-line-number="30"> <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">case</span> uncons as2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb31-31" data-line-number="31">   <span class="dt">Nothing</span> <span class="ot">-&gt;</span> someToFingerTree as3</a>
<a class="sourceLine" id="cb31-32" data-line-number="32">   <span class="dt">Just</span> (a, as) <span class="ot">-&gt;</span> branch (toSome a) as as3</a></code></pre></div>
<p>And there’s a similar analogue for <code>snoc</code>.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" data-line-number="1">unsnoc</a>
<a class="sourceLine" id="cb32-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb32-3" data-line-number="3"> <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb32-4" data-line-number="4"> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, <span class="dt">FingerTree</span> m a)</a>
<a class="sourceLine" id="cb32-5" data-line-number="5">unsnoc w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb32-6" data-line-number="6"> <span class="dt">Stump</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb32-7" data-line-number="7"> <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> <span class="dt">Just</span> (a, stump)</a>
<a class="sourceLine" id="cb32-8" data-line-number="8"> <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb32-9" data-line-number="9">   <span class="kw">let</span> (a, as) <span class="fu">=</span> unsnoc&#39; as3</a>
<a class="sourceLine" id="cb32-10" data-line-number="10">   <span class="kw">in</span> <span class="dt">Just</span> (a, borrowR as1 as2 as)</a>
<a class="sourceLine" id="cb32-11" data-line-number="11"></a>
<a class="sourceLine" id="cb32-12" data-line-number="12">unsnoc&#39;</a>
<a class="sourceLine" id="cb32-13" data-line-number="13"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb32-14" data-line-number="14"> <span class="ot">=&gt;</span> <span class="dt">Some</span> m a</a>
<a class="sourceLine" id="cb32-15" data-line-number="15"> <span class="ot">-&gt;</span> (a, <span class="dt">Maybe</span> (<span class="dt">Some</span> m a))</a>
<a class="sourceLine" id="cb32-16" data-line-number="16">unsnoc&#39; w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb32-17" data-line-number="17"> <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span> (a1, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb32-18" data-line-number="18"> <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span> (a2, <span class="dt">Just</span> (only1 a1))</a>
<a class="sourceLine" id="cb32-19" data-line-number="19"> <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span> (a3, <span class="dt">Just</span> (only2 a1 a2))</a>
<a class="sourceLine" id="cb32-20" data-line-number="20"> <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span> (a4, <span class="dt">Just</span> (only3 a1 a2 a3))</a>
<a class="sourceLine" id="cb32-21" data-line-number="21"></a>
<a class="sourceLine" id="cb32-22" data-line-number="22">borrowR</a>
<a class="sourceLine" id="cb32-23" data-line-number="23"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb32-24" data-line-number="24"> <span class="ot">=&gt;</span> <span class="dt">Some</span> m a</a>
<a class="sourceLine" id="cb32-25" data-line-number="25"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m (<span class="dt">Node</span> m a)</a>
<a class="sourceLine" id="cb32-26" data-line-number="26"> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Some</span> m a)</a>
<a class="sourceLine" id="cb32-27" data-line-number="27"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb32-28" data-line-number="28">borrowR as1 as2 w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb32-29" data-line-number="29"> <span class="dt">Just</span> as3 <span class="ot">-&gt;</span> branch as1 as2 as3</a>
<a class="sourceLine" id="cb32-30" data-line-number="30"> <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">case</span> unsnoc as2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb32-31" data-line-number="31">   <span class="dt">Nothing</span> <span class="ot">-&gt;</span> someToFingerTree as1</a>
<a class="sourceLine" id="cb32-32" data-line-number="32">   <span class="dt">Just</span> (a, as) <span class="ot">-&gt;</span> branch as1 as (toSome a)</a></code></pre></div>
<h2 id="concatenation">Concatenation</h2>
<p>Before defining concatenation proper, we start with a generalized version that takes an additional list of elements to insert between the concatenands.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb33-1" data-line-number="1">cat&#39;</a>
<a class="sourceLine" id="cb33-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb33-3" data-line-number="3"> <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb33-4" data-line-number="4"> <span class="ot">-&gt;</span> [a]</a>
<a class="sourceLine" id="cb33-5" data-line-number="5"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb33-6" data-line-number="6"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb33-7" data-line-number="7">cat&#39; u as v <span class="fu">=</span> <span class="kw">case</span> u <span class="kw">of</span></a>
<a class="sourceLine" id="cb33-8" data-line-number="8"> <span class="dt">Stump</span> <span class="ot">-&gt;</span> foldr cons v as</a>
<a class="sourceLine" id="cb33-9" data-line-number="9"> <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> cons a (foldr cons v as)</a>
<a class="sourceLine" id="cb33-10" data-line-number="10"> <span class="dt">Branch</span> _ us1 us2 us3 <span class="ot">-&gt;</span> <span class="kw">case</span> v <span class="kw">of</span></a>
<a class="sourceLine" id="cb33-11" data-line-number="11">   <span class="dt">Stump</span> <span class="ot">-&gt;</span> foldl (flip snoc) u as</a>
<a class="sourceLine" id="cb33-12" data-line-number="12">   <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> snoc a (foldl (flip snoc) u as)</a>
<a class="sourceLine" id="cb33-13" data-line-number="13">   <span class="dt">Branch</span> _ vs1 vs2 vs3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb33-14" data-line-number="14">     <span class="kw">let</span> ns <span class="fu">=</span> (toList us3) <span class="fu">++</span> as <span class="fu">++</span> (toList vs1)</a>
<a class="sourceLine" id="cb33-15" data-line-number="15">     <span class="kw">in</span> branch us1 (cat&#39; us2 (toNodes ns) vs2) vs3</a>
<a class="sourceLine" id="cb33-16" data-line-number="16"></a>
<a class="sourceLine" id="cb33-17" data-line-number="17">toNodes</a>
<a class="sourceLine" id="cb33-18" data-line-number="18"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb33-19" data-line-number="19"> <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [<span class="dt">Node</span> m a]</a>
<a class="sourceLine" id="cb33-20" data-line-number="20">toNodes w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb33-21" data-line-number="21"> [] <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb33-22" data-line-number="22"> [a1, a2] <span class="ot">-&gt;</span> [node2 a1 a2]</a>
<a class="sourceLine" id="cb33-23" data-line-number="23"> [a1, a2, a3] <span class="ot">-&gt;</span> [node3 a1 a2 a3]</a>
<a class="sourceLine" id="cb33-24" data-line-number="24"> [a1, a2, a3, a4] <span class="ot">-&gt;</span> [node2 a1 a2, node2 a3 a4]</a>
<a class="sourceLine" id="cb33-25" data-line-number="25"> a1<span class="fu">:</span>a2<span class="fu">:</span>a3<span class="fu">:</span>a4<span class="fu">:</span>as <span class="ot">-&gt;</span> (node3 a1 a2 a3) <span class="fu">:</span> toNodes (a4<span class="fu">:</span>as)</a>
<a class="sourceLine" id="cb33-26" data-line-number="26"> _ <span class="ot">-&gt;</span> error <span class="st">&quot;toNodes: panic&quot;</span></a></code></pre></div>
<p>Now the real <code>cat</code> is a specialization of <code>cat'</code>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" data-line-number="1">cat</a>
<a class="sourceLine" id="cb34-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb34-3" data-line-number="3"> <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb34-4" data-line-number="4"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb34-5" data-line-number="5"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb34-6" data-line-number="6">cat u v <span class="fu">=</span> cat&#39; u [] v</a></code></pre></div>
<p>And concat makes the type of finger trees into a monoid.</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb35-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb35-2" data-line-number="2"> ( <span class="dt">Valued</span> m a</a>
<a class="sourceLine" id="cb35-3" data-line-number="3"> ) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">FingerTree</span> m a)</a>
<a class="sourceLine" id="cb35-4" data-line-number="4"> <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-5" data-line-number="5">   (<span class="fu">&lt;&gt;</span>) <span class="fu">=</span> cat</a>
<a class="sourceLine" id="cb35-6" data-line-number="6"></a>
<a class="sourceLine" id="cb35-7" data-line-number="7"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb35-8" data-line-number="8"> ( <span class="dt">Valued</span> m a</a>
<a class="sourceLine" id="cb35-9" data-line-number="9"> ) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">FingerTree</span> m a)</a>
<a class="sourceLine" id="cb35-10" data-line-number="10"> <span class="kw">where</span></a>
<a class="sourceLine" id="cb35-11" data-line-number="11">   mempty <span class="fu">=</span> stump</a></code></pre></div>
<h2 id="splitting">Splitting</h2>
<p>The killer operation on finger trees, and the reason for caching the <code>m</code> value at each node, is efficient <em>splitting</em>. This operation takes a predicate <code>p</code> on <code>m</code> and a finger tree <code>w</code> and attempts to break it into three pieces, <code>as</code>, <code>x</code>, and <code>bs</code>, with the property that <code>w == as &lt;&gt; leaf x &lt;&gt; bs</code>, <code>p (value as)</code> is false, and <code>p (value as &lt;&gt; value x)</code> is true. The internal structure of finger trees allow this to be done efficiently. In general there may be many possible places to break the tree, but with a judicious choice of <code>m</code> and the predicate we can perform some complex operations quickly.</p>
<p>First we need a version of this operation on the fingers.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" data-line-number="1">splitSome</a>
<a class="sourceLine" id="cb36-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb36-3" data-line-number="3"> <span class="ot">=&gt;</span> (m <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Some</span> m a</a>
<a class="sourceLine" id="cb36-4" data-line-number="4"> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Maybe</span> (<span class="dt">Some</span> m a), a, <span class="dt">Maybe</span> (<span class="dt">Some</span> m a))</a>
<a class="sourceLine" id="cb36-5" data-line-number="5">splitSome p i w <span class="fu">=</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb36-6" data-line-number="6"> <span class="dt">Only1</span> _ a1 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb36-7" data-line-number="7">   <span class="kw">let</span> v1 <span class="fu">=</span> i <span class="fu">&lt;&gt;</span> (value a1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb36-8" data-line-number="8">   <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb36-9" data-line-number="9">     <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb36-10" data-line-number="10">     <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb36-11" data-line-number="11"> <span class="dt">Only2</span> _ a1 a2 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb36-12" data-line-number="12">   <span class="kw">let</span> v1 <span class="fu">=</span> i <span class="fu">&lt;&gt;</span> (value a1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb36-13" data-line-number="13">   <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb36-14" data-line-number="14">     <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Just</span> (only1 a2))</a>
<a class="sourceLine" id="cb36-15" data-line-number="15">     <span class="kw">else</span></a>
<a class="sourceLine" id="cb36-16" data-line-number="16">       <span class="kw">let</span> v2 <span class="fu">=</span> v1 <span class="fu">&lt;&gt;</span> (value a2) <span class="kw">in</span></a>
<a class="sourceLine" id="cb36-17" data-line-number="17">       <span class="kw">if</span> p v2</a>
<a class="sourceLine" id="cb36-18" data-line-number="18">         <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only1 a1), a2, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb36-19" data-line-number="19">         <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb36-20" data-line-number="20"> <span class="dt">Only3</span> _ a1 a2 a3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb36-21" data-line-number="21">   <span class="kw">let</span> v1 <span class="fu">=</span> i <span class="fu">&lt;&gt;</span> (value a1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb36-22" data-line-number="22">   <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb36-23" data-line-number="23">     <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Just</span> (only2 a2 a3))</a>
<a class="sourceLine" id="cb36-24" data-line-number="24">     <span class="kw">else</span></a>
<a class="sourceLine" id="cb36-25" data-line-number="25">       <span class="kw">let</span> v2 <span class="fu">=</span> v1 <span class="fu">&lt;&gt;</span> (value a2) <span class="kw">in</span></a>
<a class="sourceLine" id="cb36-26" data-line-number="26">       <span class="kw">if</span> p v2</a>
<a class="sourceLine" id="cb36-27" data-line-number="27">         <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only1 a1), a2, <span class="dt">Just</span> (only1 a3))</a>
<a class="sourceLine" id="cb36-28" data-line-number="28">         <span class="kw">else</span></a>
<a class="sourceLine" id="cb36-29" data-line-number="29">           <span class="kw">let</span> v3 <span class="fu">=</span> v2 <span class="fu">&lt;&gt;</span> (value a3) <span class="kw">in</span></a>
<a class="sourceLine" id="cb36-30" data-line-number="30">           <span class="kw">if</span> p v3</a>
<a class="sourceLine" id="cb36-31" data-line-number="31">             <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only2 a1 a2), a3, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb36-32" data-line-number="32">             <span class="kw">else</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb36-33" data-line-number="33"> <span class="dt">Only4</span> _ a1 a2 a3 a4 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb36-34" data-line-number="34">   <span class="kw">let</span> v1 <span class="fu">=</span> i <span class="fu">&lt;&gt;</span> (value a1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb36-35" data-line-number="35">   <span class="kw">if</span> p v1</a>
<a class="sourceLine" id="cb36-36" data-line-number="36">     <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Nothing</span>, a1, <span class="dt">Just</span> (only3 a2 a3 a4))</a>
<a class="sourceLine" id="cb36-37" data-line-number="37">     <span class="kw">else</span></a>
<a class="sourceLine" id="cb36-38" data-line-number="38">       <span class="kw">let</span> v2 <span class="fu">=</span> v1 <span class="fu">&lt;&gt;</span> (value a2) <span class="kw">in</span></a>
<a class="sourceLine" id="cb36-39" data-line-number="39">         <span class="kw">if</span> p v2</a>
<a class="sourceLine" id="cb36-40" data-line-number="40">           <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only1 a1), a2, <span class="dt">Just</span> (only2 a3 a4))</a>
<a class="sourceLine" id="cb36-41" data-line-number="41">           <span class="kw">else</span></a>
<a class="sourceLine" id="cb36-42" data-line-number="42">             <span class="kw">let</span> v3 <span class="fu">=</span> v2 <span class="fu">&lt;&gt;</span> (value a3) <span class="kw">in</span></a>
<a class="sourceLine" id="cb36-43" data-line-number="43">               <span class="kw">if</span> p v3</a>
<a class="sourceLine" id="cb36-44" data-line-number="44">                 <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only2 a1 a2), a3, <span class="dt">Just</span> (only1 a4))</a>
<a class="sourceLine" id="cb36-45" data-line-number="45">                 <span class="kw">else</span></a>
<a class="sourceLine" id="cb36-46" data-line-number="46">                   <span class="kw">let</span> v4 <span class="fu">=</span> v3 <span class="fu">&lt;&gt;</span> (value a4) <span class="kw">in</span></a>
<a class="sourceLine" id="cb36-47" data-line-number="47">                     <span class="kw">if</span> p v4</a>
<a class="sourceLine" id="cb36-48" data-line-number="48">                       <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">Just</span> (only3 a1 a2 a3), a4, <span class="dt">Nothing</span>)</a>
<a class="sourceLine" id="cb36-49" data-line-number="49">                       <span class="kw">else</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>Next we define a generalized split that prepends a given monoid value to the left of <code>value as</code>.</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb37-1" data-line-number="1">splitTree</a>
<a class="sourceLine" id="cb37-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb37-3" data-line-number="3"> <span class="ot">=&gt;</span> (m <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb37-4" data-line-number="4"> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">FingerTree</span> m a, a, <span class="dt">FingerTree</span> m a)</a>
<a class="sourceLine" id="cb37-5" data-line-number="5">splitTree p i w <span class="fu">=</span></a>
<a class="sourceLine" id="cb37-6" data-line-number="6">  <span class="kw">if</span> p i</a>
<a class="sourceLine" id="cb37-7" data-line-number="7">    <span class="kw">then</span> <span class="kw">case</span> uncons w <span class="kw">of</span></a>
<a class="sourceLine" id="cb37-8" data-line-number="8">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb37-9" data-line-number="9">      <span class="dt">Just</span> (x,bs) <span class="ot">-&gt;</span> <span class="dt">Just</span> (mempty, x, bs)</a>
<a class="sourceLine" id="cb37-10" data-line-number="10">    <span class="kw">else</span> <span class="kw">case</span> w <span class="kw">of</span></a>
<a class="sourceLine" id="cb37-11" data-line-number="11">      <span class="dt">Stump</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb37-12" data-line-number="12">      <span class="dt">Leaf</span> _ a <span class="ot">-&gt;</span> <span class="dt">Just</span> (stump, a, stump)</a>
<a class="sourceLine" id="cb37-13" data-line-number="13">      <span class="dt">Branch</span> _ as1 as2 as3 <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb37-14" data-line-number="14">        <span class="kw">let</span> vas1 <span class="fu">=</span> i <span class="fu">&lt;&gt;</span> (value as1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb37-15" data-line-number="15">        <span class="kw">if</span> p vas1</a>
<a class="sourceLine" id="cb37-16" data-line-number="16">          <span class="co">-- there&#39;s a match in the left fingers</span></a>
<a class="sourceLine" id="cb37-17" data-line-number="17">          <span class="kw">then</span> <span class="kw">case</span> (splitSome p i as1) <span class="kw">of</span></a>
<a class="sourceLine" id="cb37-18" data-line-number="18">            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;split: panic (1)&quot;</span></a>
<a class="sourceLine" id="cb37-19" data-line-number="19">            <span class="dt">Just</span> (ds1, x, ds3) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb37-20" data-line-number="20">              <span class="kw">let</span></a>
<a class="sourceLine" id="cb37-21" data-line-number="21">                bs1 <span class="fu">=</span> maybeToFingerTree ds1</a>
<a class="sourceLine" id="cb37-22" data-line-number="22">                bs3 <span class="fu">=</span> borrowL ds3 as2 as3</a>
<a class="sourceLine" id="cb37-23" data-line-number="23">              <span class="kw">in</span></a>
<a class="sourceLine" id="cb37-24" data-line-number="24">                <span class="dt">Just</span> (bs1, x, bs3)</a>
<a class="sourceLine" id="cb37-25" data-line-number="25">          <span class="kw">else</span></a>
<a class="sourceLine" id="cb37-26" data-line-number="26">            <span class="kw">let</span> vas2 <span class="fu">=</span> vas1 <span class="fu">&lt;&gt;</span> (value as2) <span class="kw">in</span></a>
<a class="sourceLine" id="cb37-27" data-line-number="27">            <span class="kw">if</span> p vas2</a>
<a class="sourceLine" id="cb37-28" data-line-number="28">              <span class="co">-- there&#39;s a match in the spine</span></a>
<a class="sourceLine" id="cb37-29" data-line-number="29">              <span class="kw">then</span> <span class="kw">case</span> splitTree p vas1 as2 <span class="kw">of</span></a>
<a class="sourceLine" id="cb37-30" data-line-number="30">                <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;split: panic (2)&quot;</span></a>
<a class="sourceLine" id="cb37-31" data-line-number="31">                <span class="dt">Just</span> (cs1, xs, cs3) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb37-32" data-line-number="32">                  <span class="kw">let</span> vs <span class="fu">=</span> vas1 <span class="fu">&lt;&gt;</span> (value cs1) <span class="kw">in</span></a>
<a class="sourceLine" id="cb37-33" data-line-number="33">                  <span class="kw">case</span> splitSome p vs (toSome xs) <span class="kw">of</span></a>
<a class="sourceLine" id="cb37-34" data-line-number="34">                    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;split: panic (3)&quot;</span></a>
<a class="sourceLine" id="cb37-35" data-line-number="35">                    <span class="dt">Just</span> (ds1, x, ds3) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb37-36" data-line-number="36">                      <span class="kw">let</span></a>
<a class="sourceLine" id="cb37-37" data-line-number="37">                        bs1 <span class="fu">=</span> borrowR as1 cs1 ds1</a>
<a class="sourceLine" id="cb37-38" data-line-number="38">                        bs3 <span class="fu">=</span> borrowL ds3 cs3 as3</a>
<a class="sourceLine" id="cb37-39" data-line-number="39">                      <span class="kw">in</span></a>
<a class="sourceLine" id="cb37-40" data-line-number="40">                        <span class="dt">Just</span> (bs1, x, bs3)</a>
<a class="sourceLine" id="cb37-41" data-line-number="41">              <span class="kw">else</span></a>
<a class="sourceLine" id="cb37-42" data-line-number="42">                <span class="kw">let</span> vas3 <span class="fu">=</span> vas2 <span class="fu">&lt;&gt;</span> (value as3) <span class="kw">in</span></a>
<a class="sourceLine" id="cb37-43" data-line-number="43">                <span class="kw">if</span> p vas3</a>
<a class="sourceLine" id="cb37-44" data-line-number="44">                  <span class="co">-- there&#39;s a match in the right fingers</span></a>
<a class="sourceLine" id="cb37-45" data-line-number="45">                  <span class="kw">then</span> <span class="kw">case</span> (splitSome p vas2 as3) <span class="kw">of</span></a>
<a class="sourceLine" id="cb37-46" data-line-number="46">                    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> error <span class="st">&quot;split: panic (4)&quot;</span></a>
<a class="sourceLine" id="cb37-47" data-line-number="47">                    <span class="dt">Just</span> (ds1, x, ds3) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb37-48" data-line-number="48">                      <span class="kw">let</span></a>
<a class="sourceLine" id="cb37-49" data-line-number="49">                        bs1 <span class="fu">=</span> borrowR as1 as2 ds1</a>
<a class="sourceLine" id="cb37-50" data-line-number="50">                        bs3 <span class="fu">=</span> maybeToFingerTree ds3</a>
<a class="sourceLine" id="cb37-51" data-line-number="51">                      <span class="kw">in</span></a>
<a class="sourceLine" id="cb37-52" data-line-number="52">                        <span class="dt">Just</span> (bs1, x, bs3)</a>
<a class="sourceLine" id="cb37-53" data-line-number="53">                  <span class="kw">else</span> <span class="dt">Nothing</span> <span class="co">-- precondition violated</span></a></code></pre></div>
<p>Now the general <code>split</code> function specializes to the identity.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" data-line-number="1">splitFT</a>
<a class="sourceLine" id="cb38-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb38-3" data-line-number="3"> <span class="ot">=&gt;</span> (m <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb38-4" data-line-number="4"> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb38-5" data-line-number="5"> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">FingerTree</span> m a, a, <span class="dt">FingerTree</span> m a)</a>
<a class="sourceLine" id="cb38-6" data-line-number="6">splitFT p w <span class="fu">=</span> splitTree p mempty w</a></code></pre></div>
<div class="sourceCode" id="cb39"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb39-1" data-line-number="1">takeFromSplitFT</a>
<a class="sourceLine" id="cb39-2" data-line-number="2"><span class="ot">  ::</span> forall m a</a>
<a class="sourceLine" id="cb39-3" data-line-number="3">   <span class="fu">.</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb39-4" data-line-number="4">  <span class="ot">=&gt;</span> (m <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb39-5" data-line-number="5">  <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> m <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb39-6" data-line-number="6">  <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb39-7" data-line-number="7">  <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb39-8" data-line-number="8">  <span class="ot">-&gt;</span> [(<span class="dt">FingerTree</span> m a, m)]</a>
<a class="sourceLine" id="cb39-9" data-line-number="9">takeFromSplitFT p q k w <span class="fu">=</span></a>
<a class="sourceLine" id="cb39-10" data-line-number="10">  <span class="kw">case</span> splitFT p w <span class="kw">of</span></a>
<a class="sourceLine" id="cb39-11" data-line-number="11">    <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb39-12" data-line-number="12">    <span class="dt">Just</span> (as,x,bs) <span class="ot">-&gt;</span> f <span class="dv">0</span> (cons x bs) (value<span class="ot"> as ::</span> m) []</a>
<a class="sourceLine" id="cb39-13" data-line-number="13">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb39-14" data-line-number="14">    f</a>
<a class="sourceLine" id="cb39-15" data-line-number="15"><span class="ot">      ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb39-16" data-line-number="16">      <span class="ot">-&gt;</span> [(<span class="dt">FingerTree</span> m a, m)] <span class="ot">-&gt;</span> [(<span class="dt">FingerTree</span> m a, m)]</a>
<a class="sourceLine" id="cb39-17" data-line-number="17">    f t z m us <span class="fu">=</span></a>
<a class="sourceLine" id="cb39-18" data-line-number="18">      <span class="kw">if</span> (isEmptyFT z) <span class="fu">||</span> (t <span class="fu">&gt;=</span> k)</a>
<a class="sourceLine" id="cb39-19" data-line-number="19">        <span class="kw">then</span> reverse us</a>
<a class="sourceLine" id="cb39-20" data-line-number="20">        <span class="kw">else</span> <span class="kw">case</span> splitTree (q t) m z <span class="kw">of</span></a>
<a class="sourceLine" id="cb39-21" data-line-number="21">          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> reverse us</a>
<a class="sourceLine" id="cb39-22" data-line-number="22">          <span class="dt">Just</span> (as,x,bs) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb39-23" data-line-number="23">            f (t<span class="fu">+</span><span class="dv">1</span>) bs (m <span class="fu">&lt;&gt;</span> value (snoc x as)) ((snoc x as,m)<span class="fu">:</span>us)</a></code></pre></div>
<h2 id="taking-subsequences">Taking subsequences</h2>
<p>Now we have some miscellaneous functions for taking subsequences of a finger tree.</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" data-line-number="1">breakPrefixWhileValueFT</a>
<a class="sourceLine" id="cb40-2" data-line-number="2"><span class="ot">  ::</span> forall m a</a>
<a class="sourceLine" id="cb40-3" data-line-number="3">   <span class="fu">.</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb40-4" data-line-number="4">  <span class="ot">=&gt;</span> (m <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb40-5" data-line-number="5">  <span class="ot">-&gt;</span> (<span class="dt">FingerTree</span> m a, <span class="dt">FingerTree</span> m a)</a>
<a class="sourceLine" id="cb40-6" data-line-number="6">breakPrefixWhileValueFT p xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb40-7" data-line-number="7">  break mempty xs</a>
<a class="sourceLine" id="cb40-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb40-9" data-line-number="9">    break</a>
<a class="sourceLine" id="cb40-10" data-line-number="10"><span class="ot">      ::</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a</a>
<a class="sourceLine" id="cb40-11" data-line-number="11">      <span class="ot">-&gt;</span> (<span class="dt">FingerTree</span> m a, <span class="dt">FingerTree</span> m a)</a>
<a class="sourceLine" id="cb40-12" data-line-number="12">    break as bs <span class="fu">=</span> <span class="kw">case</span> uncons bs <span class="kw">of</span></a>
<a class="sourceLine" id="cb40-13" data-line-number="13">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> (as, mempty)</a>
<a class="sourceLine" id="cb40-14" data-line-number="14">      <span class="dt">Just</span> (x,cs) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb40-15" data-line-number="15">        <span class="kw">if</span> p (value as <span class="fu">&lt;&gt;</span> value x)</a>
<a class="sourceLine" id="cb40-16" data-line-number="16">          <span class="kw">then</span> break (snoc x as) cs</a>
<a class="sourceLine" id="cb40-17" data-line-number="17">          <span class="kw">else</span> (as, bs)</a></code></pre></div>
<div class="sourceCode" id="cb41"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb41-1" data-line-number="1">takeWhileValueFT</a>
<a class="sourceLine" id="cb41-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb41-3" data-line-number="3"> <span class="ot">=&gt;</span> m <span class="ot">-&gt;</span> (m <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> [(a, m)]</a>
<a class="sourceLine" id="cb41-4" data-line-number="4">takeWhileValueFT e p xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb41-5" data-line-number="5"> <span class="kw">case</span> uncons xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb41-6" data-line-number="6">   <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb41-7" data-line-number="7">   <span class="dt">Just</span> (a, ys) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb41-8" data-line-number="8">     <span class="kw">let</span> z <span class="fu">=</span> e <span class="fu">&lt;&gt;</span> value a <span class="kw">in</span></a>
<a class="sourceLine" id="cb41-9" data-line-number="9">     <span class="kw">if</span> p z</a>
<a class="sourceLine" id="cb41-10" data-line-number="10">       <span class="kw">then</span> (a, z) <span class="fu">:</span> takeWhileValueFT z p ys</a>
<a class="sourceLine" id="cb41-11" data-line-number="11">       <span class="kw">else</span> []</a></code></pre></div>
<h2 id="debugging">Debugging</h2>
<p>Even the most thoroughly tested code can go wrong sometimes. For when that happens, we’ll also provide a basic debugging function that exposes the accumulated value of the finger tree at each position.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb42-1" data-line-number="1">validateFT</a>
<a class="sourceLine" id="cb42-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Eq</span> m, <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb42-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb42-4" data-line-number="4">validateFT <span class="fu">=</span> validateFT&#39; (const <span class="dt">True</span>)</a>
<a class="sourceLine" id="cb42-5" data-line-number="5"></a>
<a class="sourceLine" id="cb42-6" data-line-number="6">validateFT&#39;</a>
<a class="sourceLine" id="cb42-7" data-line-number="7"><span class="ot">  ::</span> ( <span class="dt">Eq</span> m, <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb42-8" data-line-number="8">  <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb42-9" data-line-number="9">validateFT&#39; valid xs <span class="fu">=</span> <span class="kw">case</span> xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb42-10" data-line-number="10">  <span class="dt">Stump</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb42-11" data-line-number="11">    <span class="dt">True</span></a>
<a class="sourceLine" id="cb42-12" data-line-number="12">  <span class="dt">Leaf</span> m a <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb42-13" data-line-number="13">    m <span class="fu">==</span> value a</a>
<a class="sourceLine" id="cb42-14" data-line-number="14">  <span class="dt">Branch</span> m as x bs <span class="ot">-&gt;</span> and</a>
<a class="sourceLine" id="cb42-15" data-line-number="15">    [ validateSome valid as</a>
<a class="sourceLine" id="cb42-16" data-line-number="16">    , validateFT&#39; (validateNode valid) x</a>
<a class="sourceLine" id="cb42-17" data-line-number="17">    , validateSome valid bs</a>
<a class="sourceLine" id="cb42-18" data-line-number="18">    , m <span class="fu">==</span> mconcat [ value as, value x, value bs ]</a>
<a class="sourceLine" id="cb42-19" data-line-number="19">    ]</a>
<a class="sourceLine" id="cb42-20" data-line-number="20"></a>
<a class="sourceLine" id="cb42-21" data-line-number="21">validateSome</a>
<a class="sourceLine" id="cb42-22" data-line-number="22"><span class="ot">  ::</span> ( <span class="dt">Eq</span> m, <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb42-23" data-line-number="23">  <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Some</span> m a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb42-24" data-line-number="24">validateSome valid x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb42-25" data-line-number="25">  <span class="dt">Only1</span> m a1 <span class="ot">-&gt;</span> and</a>
<a class="sourceLine" id="cb42-26" data-line-number="26">    [ m <span class="fu">==</span> value a1</a>
<a class="sourceLine" id="cb42-27" data-line-number="27">    , valid a1</a>
<a class="sourceLine" id="cb42-28" data-line-number="28">    ]</a>
<a class="sourceLine" id="cb42-29" data-line-number="29">  <span class="dt">Only2</span> m a1 a2 <span class="ot">-&gt;</span> and</a>
<a class="sourceLine" id="cb42-30" data-line-number="30">    [ m <span class="fu">==</span> mconcat [ value a1, value a2 ]</a>
<a class="sourceLine" id="cb42-31" data-line-number="31">    , valid a1, valid a2</a>
<a class="sourceLine" id="cb42-32" data-line-number="32">    ]</a>
<a class="sourceLine" id="cb42-33" data-line-number="33">  <span class="dt">Only3</span> m a1 a2 a3 <span class="ot">-&gt;</span> and</a>
<a class="sourceLine" id="cb42-34" data-line-number="34">    [ m <span class="fu">==</span> mconcat [ value a1, value a2, value a3 ]</a>
<a class="sourceLine" id="cb42-35" data-line-number="35">    , valid a1, valid a2, valid a3</a>
<a class="sourceLine" id="cb42-36" data-line-number="36">    ]</a>
<a class="sourceLine" id="cb42-37" data-line-number="37">  <span class="dt">Only4</span> m a1 a2 a3 a4 <span class="ot">-&gt;</span> and</a>
<a class="sourceLine" id="cb42-38" data-line-number="38">    [ m <span class="fu">==</span> mconcat [ value a1, value a2, value a3, value a4 ]</a>
<a class="sourceLine" id="cb42-39" data-line-number="39">    , valid a1, valid a2, valid a3, valid a4</a>
<a class="sourceLine" id="cb42-40" data-line-number="40">    ]</a>
<a class="sourceLine" id="cb42-41" data-line-number="41"></a>
<a class="sourceLine" id="cb42-42" data-line-number="42">validateNode</a>
<a class="sourceLine" id="cb42-43" data-line-number="43"><span class="ot">  ::</span> ( <span class="dt">Eq</span> m, <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb42-44" data-line-number="44">  <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> <span class="dt">Node</span> m a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb42-45" data-line-number="45">validateNode valid x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb42-46" data-line-number="46">  <span class="dt">Node2</span> m a1 a2 <span class="ot">-&gt;</span> and</a>
<a class="sourceLine" id="cb42-47" data-line-number="47">    [ m <span class="fu">==</span> mconcat [ value a1, value a2 ]</a>
<a class="sourceLine" id="cb42-48" data-line-number="48">    , valid a1, valid a2</a>
<a class="sourceLine" id="cb42-49" data-line-number="49">    ]</a>
<a class="sourceLine" id="cb42-50" data-line-number="50">  <span class="dt">Node3</span> m a1 a2 a3 <span class="ot">-&gt;</span> and</a>
<a class="sourceLine" id="cb42-51" data-line-number="51">    [ m <span class="fu">==</span> mconcat [ value a1, value a2, value a3 ]</a>
<a class="sourceLine" id="cb42-52" data-line-number="52">    , valid a1, valid a2, valid a3</a>
<a class="sourceLine" id="cb42-53" data-line-number="53">    ]</a></code></pre></div>
<div class="sourceCode" id="cb43"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb43-1" data-line-number="1">toListDebugFT</a>
<a class="sourceLine" id="cb43-2" data-line-number="2"><span class="ot"> ::</span> ( <span class="dt">Valued</span> m a )</a>
<a class="sourceLine" id="cb43-3" data-line-number="3"> <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> [(a,m)]</a>
<a class="sourceLine" id="cb43-4" data-line-number="4">toListDebugFT xs <span class="fu">=</span> foo mempty xs</a>
<a class="sourceLine" id="cb43-5" data-line-number="5"> <span class="kw">where</span></a>
<a class="sourceLine" id="cb43-6" data-line-number="6">   foo e z <span class="fu">=</span> <span class="kw">case</span> uncons z <span class="kw">of</span></a>
<a class="sourceLine" id="cb43-7" data-line-number="7">     <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []</a>
<a class="sourceLine" id="cb43-8" data-line-number="8">     <span class="dt">Just</span> (a, ys) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb43-9" data-line-number="9">       <span class="kw">let</span> u <span class="fu">=</span> e <span class="fu">&lt;&gt;</span> value a</a>
<a class="sourceLine" id="cb43-10" data-line-number="10">       <span class="kw">in</span> (a, u) <span class="fu">:</span> foo u ys</a></code></pre></div>
<div class="sourceCode" id="cb44"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb44-1" data-line-number="1">showInternalFT</a>
<a class="sourceLine" id="cb44-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">Valued</span> m a, <span class="dt">Show</span> m, <span class="dt">Show</span> a )</a>
<a class="sourceLine" id="cb44-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb44-4" data-line-number="4">showInternalFT <span class="fu">=</span> showInternalFT&#39; show</a></code></pre></div>
<div class="sourceCode" id="cb45"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb45-1" data-line-number="1">showInternalFT&#39;</a>
<a class="sourceLine" id="cb45-2" data-line-number="2"><span class="ot">  ::</span> forall m a</a>
<a class="sourceLine" id="cb45-3" data-line-number="3">   <span class="fu">.</span> ( <span class="dt">Valued</span> m a, <span class="dt">Show</span> m )</a>
<a class="sourceLine" id="cb45-4" data-line-number="4">  <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">String</span>)</a>
<a class="sourceLine" id="cb45-5" data-line-number="5">  <span class="ot">-&gt;</span> <span class="dt">FingerTree</span> m a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb45-6" data-line-number="6">showInternalFT&#39; s x <span class="fu">=</span></a>
<a class="sourceLine" id="cb45-7" data-line-number="7">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb45-8" data-line-number="8">    p cs <span class="fu">=</span> <span class="kw">if</span> elem <span class="ch">&#39; &#39;</span> cs</a>
<a class="sourceLine" id="cb45-9" data-line-number="9">      <span class="kw">then</span> concat [<span class="st">&quot;(&quot;</span>,cs,<span class="st">&quot;)&quot;</span>]</a>
<a class="sourceLine" id="cb45-10" data-line-number="10">      <span class="kw">else</span> cs</a>
<a class="sourceLine" id="cb45-11" data-line-number="11"></a>
<a class="sourceLine" id="cb45-12" data-line-number="12">    showNode</a>
<a class="sourceLine" id="cb45-13" data-line-number="13"><span class="ot">      ::</span> (a <span class="ot">-&gt;</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">Node</span> m a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb45-14" data-line-number="14">    showNode s x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb45-15" data-line-number="15">      <span class="dt">Node2</span> m a1 a2 <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb45-16" data-line-number="16">        [ <span class="st">&quot;Node2&quot;</span>, p <span class="fu">$</span> show m, p <span class="fu">$</span> s a1, p <span class="fu">$</span> s a2 ]</a>
<a class="sourceLine" id="cb45-17" data-line-number="17">      <span class="dt">Node3</span> m a1 a2 a3 <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb45-18" data-line-number="18">        [ <span class="st">&quot;Node3&quot;</span>, p <span class="fu">$</span> show m, p <span class="fu">$</span> s a1, p <span class="fu">$</span> s a2, p <span class="fu">$</span> s a3 ]</a>
<a class="sourceLine" id="cb45-19" data-line-number="19"></a>
<a class="sourceLine" id="cb45-20" data-line-number="20">    showSome</a>
<a class="sourceLine" id="cb45-21" data-line-number="21"><span class="ot">      ::</span> (a <span class="ot">-&gt;</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">Some</span> m a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb45-22" data-line-number="22">    showSome s x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb45-23" data-line-number="23">      <span class="dt">Only1</span> m a1 <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb45-24" data-line-number="24">        [ <span class="st">&quot;Only1&quot;</span>, p <span class="fu">$</span> show m, p <span class="fu">$</span> s a1 ]</a>
<a class="sourceLine" id="cb45-25" data-line-number="25">      <span class="dt">Only2</span> m a1 a2 <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb45-26" data-line-number="26">        [ <span class="st">&quot;Only2&quot;</span>, p <span class="fu">$</span> show m, p <span class="fu">$</span> s a1, p <span class="fu">$</span> s a2 ]</a>
<a class="sourceLine" id="cb45-27" data-line-number="27">      <span class="dt">Only3</span> m a1 a2 a3 <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb45-28" data-line-number="28">        [ <span class="st">&quot;Only3&quot;</span>, p <span class="fu">$</span> show m, p <span class="fu">$</span> s a1, p <span class="fu">$</span> s a2, p <span class="fu">$</span> s a3 ]</a>
<a class="sourceLine" id="cb45-29" data-line-number="29">      <span class="dt">Only4</span> m a1 a2 a3 a4 <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb45-30" data-line-number="30">        [ <span class="st">&quot;Only4&quot;</span>, p <span class="fu">$</span> show m, p <span class="fu">$</span> s a1, p <span class="fu">$</span> s a2, p <span class="fu">$</span> s a3, p <span class="fu">$</span> s a4 ]</a>
<a class="sourceLine" id="cb45-31" data-line-number="31">  <span class="kw">in</span></a>
<a class="sourceLine" id="cb45-32" data-line-number="32">    <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb45-33" data-line-number="33">      <span class="dt">Stump</span> <span class="ot">-&gt;</span> <span class="st">&quot;Stump&quot;</span></a>
<a class="sourceLine" id="cb45-34" data-line-number="34">      <span class="dt">Leaf</span> m a <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb45-35" data-line-number="35">        [ <span class="st">&quot;Leaf&quot;</span>, p <span class="fu">$</span> show m, s a ]</a>
<a class="sourceLine" id="cb45-36" data-line-number="36">      <span class="dt">Branch</span> m as x bs <span class="ot">-&gt;</span> unwords</a>
<a class="sourceLine" id="cb45-37" data-line-number="37">        [ <span class="st">&quot;Branch&quot;</span></a>
<a class="sourceLine" id="cb45-38" data-line-number="38">        , p <span class="fu">$</span> show m</a>
<a class="sourceLine" id="cb45-39" data-line-number="39">        , p <span class="fu">$</span> showSome s as</a>
<a class="sourceLine" id="cb45-40" data-line-number="40">        , p <span class="fu">$</span> showInternalFT&#39; (showNode s) x</a>
<a class="sourceLine" id="cb45-41" data-line-number="41">        , p <span class="fu">$</span> showSome s bs</a>
<a class="sourceLine" id="cb45-42" data-line-number="42">        ]</a></code></pre></div>
</body>
</html>
