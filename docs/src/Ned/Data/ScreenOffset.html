<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Ned.Data.ScreenOffset</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; position: absolute; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; }
pre.numberSource a.sourceLine:empty
  { position: absolute; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: absolute; left: -5em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style type="text/css">
  /* Kudos to Pascal Hertleif                  */
  /* https://gist.github.com/killercup/5917178 */
  
  html {
    font-size: 100%;
    overflow-y: scroll;
    -webkit-text-size-adjust: 100%;
    -ms-text-size-adjust: 100%;
  }
  
  body {
    color: #444;
    font-family: Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman', serif;
    font-size: 12px;
    line-height: 1.7;
    padding: 1em;
    margin: auto;
    max-width: 42em;
    background: #fefefe;
  }
  
  a {
    color: #0645ad;
    text-decoration: none;
  }
  
  a:visited {
    color: #0b0080;
  }
  
  a:hover {
    color: #06e;
  }
  
  a:active {
    color: #faa700;
  }
  
  a:focus {
    outline: thin dotted;
  }
  
  *::-moz-selection {
    background: rgba(255, 255, 0, 0.3);
    color: #000;
  }
  
  *::selection {
    background: rgba(255, 255, 0, 0.3);
    color: #000;
  }
  
  a::-moz-selection {
    background: rgba(255, 255, 0, 0.3);
    color: #0645ad;
  }
  
  a::selection {
    background: rgba(255, 255, 0, 0.3);
    color: #0645ad;
  }
  
  p {
    margin: 1em 0;
  }
  
  img {
    max-width: 100%;
  }
  
  h1, h2, h3, h4, h5, h6 {
    color: #111;
    line-height: 125%;
    margin-top: 2em;
    font-weight: normal;
  }
  
  h4, h5, h6 {
    font-weight: bold;
  }
  
  h1 {
    font-size: 2.5em;
  }
  
  h2 {
    font-size: 2em;
  }
  
  h3 {
    font-size: 1.5em;
  }
  
  h4 {
    font-size: 1.2em;
  }
  
  h5 {
    font-size: 1em;
  }
  
  h6 {
    font-size: 0.9em;
  }
  
  blockquote {
    display: block;
    color: #666666;
    margin: 0;
    padding-left: 3em;
    border-left: 0.5em #EEE solid;
  }
  
  hr {
    display: block;
    height: 2px;
    border: 0;
    border-top: 1px solid #aaa;
    border-bottom: 1px solid #eee;
    margin: 1em 0;
    padding: 0;
  }
  
  pre, code, kbd, samp {
    color: #000;
    font-family: monospace, monospace;
    _font-family: 'courier new', monospace;
    font-size: 0.98em;
  }
  
  pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }
  
  b, strong {
    font-weight: bold;
  }
  
  dfn {
    font-style: italic;
  }
  
  ins {
    background: #ff9;
    color: #000;
    text-decoration: none;
  }
  
  mark {
    background: #ff0;
    color: #000;
    font-style: italic;
    font-weight: bold;
  }
  
  sub, sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
  }
  
  sup {
    top: -0.5em;
  }
  
  sub {
    bottom: -0.25em;
  }
  
  ul, ol {
    margin: 1em 0;
    padding: 0 0 0 2em;
  }
  
  li p:last-child {
    margin-bottom: 0;
  }
  
  ul ul, ol ol {
    margin: .3em 0;
  }
  
  dl {
    margin-bottom: 1em;
  }
  
  dt {
    font-weight: bold;
    margin-bottom: .8em;
  }
  
  dd {
    margin: 0 0 .8em 2em;
  }
  
  dd:last-child {
    margin-bottom: 0;
  }
  
  img {
    border: 0;
    -ms-interpolation-mode: bicubic;
    vertical-align: middle;
  }
  
  figure {
    display: block;
    text-align: center;
    margin: 1em 0;
  }
  
  figure img {
    border: none;
    margin: 0 auto;
  }
  
  figcaption {
    font-size: 0.8em;
    font-style: italic;
    margin: 0 0 .8em;
  }
  
  table {
    margin-bottom: 2em;
    border-bottom: 1px solid #ddd;
    border-right: 1px solid #ddd;
    border-spacing: 0;
    border-collapse: collapse;
  }
  
  table th {
    padding: .2em 1em;
    background-color: #eee;
    border-top: 1px solid #ddd;
    border-left: 1px solid #ddd;
  }
  
  table td {
    padding: .2em 1em;
    border-top: 1px solid #ddd;
    border-left: 1px solid #ddd;
    vertical-align: top;
  }
  
  .author {
    font-size: 1.2em;
    text-align: center;
  }
  
  .sourceCode {
    background-color: #eee;
  }
  
  @media only screen and (min-width: 480px) {
    body {
      font-size: 14px;
    }
  }
  @media only screen and (min-width: 768px) {
    body {
      font-size: 16px;
    }
  }
  @media print {
    * {
      background: transparent !important;
      color: black !important;
      filter: none !important;
      -ms-filter: none !important;
    }
  
    body {
      font-size: 12pt;
      max-width: 100%;
    }
  
    a, a:visited {
      text-decoration: underline;
    }
  
    hr {
      height: 1px;
      border: 0;
      border-bottom: 1px solid black;
    }
  
    a[href]:after {
      content: " (" attr(href) ")";
    }
  
    abbr[title]:after {
      content: " (" attr(title) ")";
    }
  
    .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after {
      content: "";
    }
  
    pre, blockquote {
      border: 1px solid #999;
      padding-right: 1em;
      page-break-inside: avoid;
    }
  
    tr, img {
      page-break-inside: avoid;
    }
  
    img {
      max-width: 100% !important;
    }
  
    @page :left {
      margin: 15mm 20mm 15mm 10mm;
  }
  
    @page :right {
      margin: 15mm 10mm 15mm 20mm;
  }
  
    p, h2, h3 {
      orphans: 3;
      widows: 3;
    }
  
    h2, h3 {
      page-break-after: avoid;
    }
  }
  </style>
</head>
<body>
<header>
<h1 class="title">Ned.Data.ScreenOffset</h1>
</header>
<h2 id="contents">Contents</h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#exposed-api">Exposed API</a></li>
<li><a href="#spans">Spans</a></li>
<li><a href="#type-parameters">Type parameters</a></li>
<li><a href="#screen-offsets">Screen offsets</a></li>
<li><a href="#a-monoid-action-for-screen-offsets">A monoid action for screen offsets</a></li>
</ul>
<h1 id="introduction">Introduction</h1>
<p>Looking ahead, we’ll eventually implement text buffers as a zipped finger tree of characters. To make this work we need a suitable <code>Monoid</code> instance to serve as the ‘measurement’ for text. But what should go in that monoid? Some natural choices are character count and byte count. Another choice is to carry line and column information so we can efficiently seek to a specific position in the text, although it’s not immediately obvious that that is a monoid.</p>
<p>Yet another option is to have every character carry information about its position <em>on the screen</em>. This allows efficient seeking to a given screen position. Unfortunately now the monoid instance on our measurement will depend on the screen width and the tab width, the choice of which we’d like to leave up to the user. So we need our monoid instance to take two type level number parameters, but also need for these types to be invisible to the consuming code. This is precisely the problem that implicit configurations are designed to solve.</p>
<p>In this module we will develop a monoid of <em>screen offsets</em>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="ot">{-# LANGUAGE</span></a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="ot">    ScopedTypeVariables</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="ot">  , Rank2Types</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="ot">#-}</span></a></code></pre></div>
<h1 id="exposed-api">Exposed API</h1>
<div class="sourceCode" id="cb2"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="kw">module</span> <span class="dt">Ned.Data.ScreenOffset</span> (</a>
<a class="sourceLine" id="cb2-2" data-line-number="2">    <span class="dt">ScreenOffset</span>(<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">  , <span class="dt">Span</span>(<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb2-4" data-line-number="4">  , mkNoNewlines</a>
<a class="sourceLine" id="cb2-5" data-line-number="5">  , mkWithNewlines</a>
<a class="sourceLine" id="cb2-6" data-line-number="6">  , defNoNewlines</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">  , defWithNewlines</a>
<a class="sourceLine" id="cb2-8" data-line-number="8"></a>
<a class="sourceLine" id="cb2-9" data-line-number="9">  <span class="co">-- * Numeric type parameters</span></a>
<a class="sourceLine" id="cb2-10" data-line-number="10">  , <span class="dt">IsWidth</span>(<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb2-11" data-line-number="11">  , withWidth</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">  , <span class="dt">IsTab</span>(<span class="fu">..</span>)</a>
<a class="sourceLine" id="cb2-13" data-line-number="13">  , withTab</a></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" data-line-number="1">  , applyScreenOffset</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">  , applyBlockOffset</a></code></pre></div>
<div class="sourceCode" id="cb4"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" data-line-number="1">  <span class="co">-- ** Utilities</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">  , takeChunk</a>
<a class="sourceLine" id="cb4-3" data-line-number="3">  , takeChunks</a>
<a class="sourceLine" id="cb4-4" data-line-number="4">  , spanWidth</a>
<a class="sourceLine" id="cb4-5" data-line-number="5">) <span class="kw">where</span></a></code></pre></div>
<div class="sourceCode" id="cb5"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Data.Proxy</span></a></code></pre></div>
<div class="sourceCode" id="cb6"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">import</span> <span class="dt">Ned.Data.ReflectNat</span></a>
<a class="sourceLine" id="cb6-2" data-line-number="2"><span class="kw">import</span> <span class="dt">Ned.Data.RunLengthEncoding</span></a></code></pre></div>
<h1 id="spans">Spans</h1>
<p>Now we’re starting to get to the gritty details of text in terminal windows.</p>
<p>Unicode characters have a <em>width</em> attribute, for the number of ‘cells’ they occupy in the terminal window. For instance, ordinary latin text characters have width 1, combining characters have width 0, and East Asian script characters have width 2. Fortunately though that’s it; every character that has a specific width has width 0, 1, or 2. The only exception is the <em>tab</em> character, whose width is dynamic; the width of tab is however many cells away it is from the next tab stop, so is dependent on where the tab appears on the screen.</p>
<p>We will represent the possible character widths using the <code>Span</code> type.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">data</span> <span class="dt">Span</span></a>
<a class="sourceLine" id="cb7-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">Fixed0</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">  <span class="fu">|</span> <span class="dt">Fixed1</span></a>
<a class="sourceLine" id="cb7-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">Fixed2</span></a>
<a class="sourceLine" id="cb7-5" data-line-number="5">  <span class="fu">|</span> <span class="dt">Stretchy</span></a>
<a class="sourceLine" id="cb7-6" data-line-number="6">  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Show</span>)</a></code></pre></div>
<p>There’s actually one more special case – newlines, whose width is however many cells away it is from the end of the terminal window. But we’ll handle these differently in a moment.</p>
<p>We will be using run length encoded lists of spans, and it will be very useful to know the total width of such a list.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" data-line-number="1">spanWidth</a>
<a class="sourceLine" id="cb8-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoding</span> <span class="dt">Span</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">spanWidth tab rle <span class="fu">=</span> w <span class="dv">0</span> rle</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-5" data-line-number="5"><span class="ot">    w ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoding</span> <span class="dt">Span</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    w m xs <span class="fu">=</span> <span class="kw">case</span> firstRun xs <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-7" data-line-number="7">      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> m</a>
<a class="sourceLine" id="cb8-8" data-line-number="8">      <span class="dt">Just</span> (<span class="dt">Run</span> (k,a), bs) <span class="ot">-&gt;</span> <span class="kw">case</span> a <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">        <span class="dt">Fixed0</span> <span class="ot">-&gt;</span> w m bs</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">        <span class="dt">Fixed1</span> <span class="ot">-&gt;</span> w (m <span class="fu">+</span> k) bs</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">        <span class="dt">Fixed2</span> <span class="ot">-&gt;</span> w (m <span class="fu">+</span> <span class="dv">2</span><span class="fu">*</span>k) bs</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">        <span class="dt">Stretchy</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">          <span class="kw">let</span> n <span class="fu">=</span> tab <span class="fu">*</span> (<span class="dv">1</span> <span class="fu">+</span> quot m tab) <span class="kw">in</span></a>
<a class="sourceLine" id="cb8-14" data-line-number="14">          <span class="kw">if</span> k <span class="fu">==</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb8-15" data-line-number="15">            <span class="kw">then</span> w n bs</a>
<a class="sourceLine" id="cb8-16" data-line-number="16">            <span class="kw">else</span> w (n <span class="fu">+</span> tab<span class="fu">*</span>(k<span class="fu">-</span><span class="dv">1</span>)) bs</a></code></pre></div>
<h1 id="type-parameters">Type parameters</h1>
<p>We’ll need to encode the width and tab parameters of a text buffer in its type. To do this we’ll be using the <code>ReflectNat</code> machinery.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">class</span> <span class="dt">IsWidth</span> p <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-2" data-line-number="2"><span class="ot">  toWidth   ::</span> <span class="dt">Proxy</span> p <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3"><span class="ot">  showWidth ::</span> <span class="dt">Proxy</span> p <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb9-4" data-line-number="4"></a>
<a class="sourceLine" id="cb9-5" data-line-number="5"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">  ( <span class="dt">ReflectNat</span> p</a>
<a class="sourceLine" id="cb9-7" data-line-number="7">  ) <span class="ot">=&gt;</span> <span class="dt">IsWidth</span> (<span class="dt">Nat</span> p)</a>
<a class="sourceLine" id="cb9-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">    toWidth _ <span class="fu">=</span> reflectNat (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> p)</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    showWidth _ <span class="fu">=</span> show (undefined<span class="ot"> ::</span> <span class="dt">Nat</span> p)</a>
<a class="sourceLine" id="cb9-11" data-line-number="11"></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">withWidth</a>
<a class="sourceLine" id="cb9-13" data-line-number="13"><span class="ot">  ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb9-14" data-line-number="14">  <span class="ot">-&gt;</span> (forall p<span class="fu">.</span> (<span class="dt">IsWidth</span> p) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> p <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb9-15" data-line-number="15">  <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb9-16" data-line-number="16">withWidth k cont <span class="fu">=</span> reifyNat k <span class="fu">$</span></a>
<a class="sourceLine" id="cb9-17" data-line-number="17">  \(<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> p) <span class="ot">-&gt;</span> cont (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Nat</span> p))</a></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">class</span> <span class="dt">IsTab</span> p <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-2" data-line-number="2"><span class="ot">  toTab   ::</span> <span class="dt">Proxy</span> p <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-3" data-line-number="3"><span class="ot">  showTab ::</span> <span class="dt">Proxy</span> p <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb10-4" data-line-number="4"></a>
<a class="sourceLine" id="cb10-5" data-line-number="5"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">  ( <span class="dt">ReflectNat</span> p</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">  ) <span class="ot">=&gt;</span> <span class="dt">IsTab</span> (<span class="dt">Nat</span> p)</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb10-9" data-line-number="9">    toTab _ <span class="fu">=</span> reflectNat (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> p)</a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    showTab _ <span class="fu">=</span> show (undefined<span class="ot"> ::</span> <span class="dt">Nat</span> p)</a>
<a class="sourceLine" id="cb10-11" data-line-number="11"></a>
<a class="sourceLine" id="cb10-12" data-line-number="12">withTab</a>
<a class="sourceLine" id="cb10-13" data-line-number="13"><span class="ot">  ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb10-14" data-line-number="14">  <span class="ot">-&gt;</span> (forall p<span class="fu">.</span> (<span class="dt">IsTab</span> p) <span class="ot">=&gt;</span> <span class="dt">Proxy</span> p <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb10-15" data-line-number="15">  <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb10-16" data-line-number="16">withTab k cont <span class="fu">=</span> reifyNat k <span class="fu">$</span></a>
<a class="sourceLine" id="cb10-17" data-line-number="17">  \(<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> p) <span class="ot">-&gt;</span> cont (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Nat</span> p))</a></code></pre></div>
<h1 id="screen-offsets">Screen offsets</h1>
<p>The <code>ScreenOffset</code> type models the position of a given character on the screen. More precisely, it models a <em>cell offset</em>; some number of newlines followed by a run length encoded list of spans. I imagine <code>ScreenOffset</code> in terms of moveable type. We have a given list of pieces of type (the <code>Span</code>s) that need to be wrapped to a page (the terminal window) of a given width.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="kw">data</span> <span class="dt">ScreenOffset</span> w t</a>
<a class="sourceLine" id="cb11-2" data-line-number="2">  <span class="fu">=</span> <span class="dt">NoNewlines</span></a>
<a class="sourceLine" id="cb11-3" data-line-number="3">      (<span class="dt">RunLengthEncoding</span> <span class="dt">Span</span>)</a>
<a class="sourceLine" id="cb11-4" data-line-number="4">  <span class="fu">|</span> <span class="dt">WithNewlines</span></a>
<a class="sourceLine" id="cb11-5" data-line-number="5">      (<span class="dt">RunLengthEncoding</span> <span class="dt">Span</span>)</a>
<a class="sourceLine" id="cb11-6" data-line-number="6">      <span class="dt">Int</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7">      (<span class="dt">RunLengthEncoding</span> <span class="dt">Span</span>)</a>
<a class="sourceLine" id="cb11-8" data-line-number="8">  <span class="kw">deriving</span> <span class="dt">Eq</span></a></code></pre></div>
<p>We need a monoid instance for <code>ScreenOffset</code>, which intuitively works something like this. Given two screen offsets, if the second has no line offset, then we can just concatenate the second block offset to the first. But this may cause the block offset to march off the right edge of the window, so we need to wrap it first (possibly adjusting the line offset as we go). If the second screen offset does have a line offset, we again need to wrap the first block offset to figure out how many lines it occupies. So in both cases <em>wrapping</em> a block offset is a crucial operation.</p>
<p>To be a little more specific about what is meant by wrapping, imagine we have a physical sequence of blocks of width 0, 1, or 2 (Forget tabs for a moment) and a grid of some fixed integer width. By wrapping we mean to line up the blocks, in order, fitting as many as we can on a line before shifting down and starting over.</p>
<p>We can break the problem of wrapping lists of spans into subproblems. First consider how to break off the <em>first</em> full line of spans – we can think about this recursively. If there is no space left on the current line, pull as many width 0 spans off of the block list as we can. If there is space left on the current line, take the next block in the queue. If it fits, place it and move on, and if it doesn’t we’re done.</p>
<p>The <code>takeChunk</code> function performs this operation. The details are a little hairier because (1) we have to account for tabs too and (2) the queue of spans is run length encoded for efficiency reasons, and we can use this to optimize here as well but it makes the arithmetic much fiddlier.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" data-line-number="1">takeChunk</a>
<a class="sourceLine" id="cb12-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoding</span> <span class="dt">Span</span></a>
<a class="sourceLine" id="cb12-3" data-line-number="3">  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">RunLengthEncoding</span> <span class="dt">Span</span>, <span class="dt">RunLengthEncoding</span> <span class="dt">Span</span>)</a>
<a class="sourceLine" id="cb12-4" data-line-number="4">takeChunk width tab rle <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-5" data-line-number="5">  <span class="kw">if</span> isEmptyRLE rle</a>
<a class="sourceLine" id="cb12-6" data-line-number="6">    <span class="kw">then</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb12-7" data-line-number="7">    <span class="kw">else</span> greedy <span class="dv">0</span> mempty rle</a>
<a class="sourceLine" id="cb12-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb12-9" data-line-number="9">    greedy</a>
<a class="sourceLine" id="cb12-10" data-line-number="10"><span class="ot">      ::</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb12-11" data-line-number="11">      <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoding</span> <span class="dt">Span</span></a>
<a class="sourceLine" id="cb12-12" data-line-number="12">      <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoding</span> <span class="dt">Span</span></a>
<a class="sourceLine" id="cb12-13" data-line-number="13">      <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">RunLengthEncoding</span> <span class="dt">Span</span>, <span class="dt">RunLengthEncoding</span> <span class="dt">Span</span>)</a>
<a class="sourceLine" id="cb12-14" data-line-number="14">    greedy m as bs <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-15" data-line-number="15">      <span class="kw">if</span> m <span class="fu">&gt;=</span> width</a>
<a class="sourceLine" id="cb12-16" data-line-number="16"></a>
<a class="sourceLine" id="cb12-17" data-line-number="17">        <span class="co">-- chunk is full; make sure remainder is not empty.</span></a>
<a class="sourceLine" id="cb12-18" data-line-number="18">        <span class="kw">then</span> <span class="kw">case</span> firstRun bs <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-19" data-line-number="19">          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> (as, mempty)</a>
<a class="sourceLine" id="cb12-20" data-line-number="20">          <span class="dt">Just</span> (<span class="dt">Run</span> (k, a), ds) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-21" data-line-number="21">            <span class="kw">case</span> a <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-22" data-line-number="22">              <span class="dt">Fixed0</span> <span class="ot">-&gt;</span> greedy m (as <span class="fu">&lt;&gt;</span> fromFreqList [(k,a)]) ds</a>
<a class="sourceLine" id="cb12-23" data-line-number="23">              _      <span class="ot">-&gt;</span> <span class="dt">Just</span> (as, bs)</a>
<a class="sourceLine" id="cb12-24" data-line-number="24"></a>
<a class="sourceLine" id="cb12-25" data-line-number="25">        <span class="co">-- chunk is not full yet</span></a>
<a class="sourceLine" id="cb12-26" data-line-number="26">        <span class="kw">else</span> <span class="kw">case</span> firstRun bs <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-27" data-line-number="27">          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb12-28" data-line-number="28">          <span class="dt">Just</span> (<span class="dt">Run</span> (k,a), ds) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-29" data-line-number="29">            </a>
<a class="sourceLine" id="cb12-30" data-line-number="30">            <span class="kw">case</span> a <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-31" data-line-number="31">              <span class="dt">Fixed0</span> <span class="ot">-&gt;</span> greedy m (as <span class="fu">&lt;&gt;</span> fromFreqList [(k,a)]) ds</a>
<a class="sourceLine" id="cb12-32" data-line-number="32"></a>
<a class="sourceLine" id="cb12-33" data-line-number="33">              <span class="dt">Fixed1</span> <span class="ot">-&gt;</span> <span class="kw">let</span> capacity <span class="fu">=</span> width <span class="fu">-</span> m <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-34" data-line-number="34">                <span class="kw">if</span> k <span class="fu">&lt;=</span> capacity</a>
<a class="sourceLine" id="cb12-35" data-line-number="35">                  <span class="kw">then</span> greedy (m<span class="fu">+</span>k) (as <span class="fu">&lt;&gt;</span> fromFreqList [(k,a)]) ds</a>
<a class="sourceLine" id="cb12-36" data-line-number="36">                  <span class="kw">else</span> <span class="dt">Just</span></a>
<a class="sourceLine" id="cb12-37" data-line-number="37">                    ( as <span class="fu">&lt;&gt;</span> fromFreqList [(capacity,a)]</a>
<a class="sourceLine" id="cb12-38" data-line-number="38">                    , fromFreqList [(k<span class="fu">-</span>capacity,a)] <span class="fu">&lt;&gt;</span> ds )</a>
<a class="sourceLine" id="cb12-39" data-line-number="39"></a>
<a class="sourceLine" id="cb12-40" data-line-number="40">              <span class="dt">Fixed2</span> <span class="ot">-&gt;</span> <span class="kw">let</span> capacity <span class="fu">=</span> width <span class="fu">-</span> m <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-41" data-line-number="41">                <span class="kw">if</span> capacity <span class="fu">&lt;</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb12-42" data-line-number="42">                  <span class="kw">then</span> <span class="dt">Just</span> (as, bs)</a>
<a class="sourceLine" id="cb12-43" data-line-number="43">                  <span class="kw">else</span> <span class="kw">if</span> (<span class="dv">2</span><span class="fu">*</span>k) <span class="fu">&lt;=</span> capacity</a>
<a class="sourceLine" id="cb12-44" data-line-number="44">                    <span class="kw">then</span> greedy (m <span class="fu">+</span> <span class="dv">2</span><span class="fu">*</span>k)</a>
<a class="sourceLine" id="cb12-45" data-line-number="45">                      (as <span class="fu">&lt;&gt;</span> fromFreqList [(k,a)]) ds</a>
<a class="sourceLine" id="cb12-46" data-line-number="46">                    <span class="kw">else</span> <span class="kw">let</span> q <span class="fu">=</span> capacity <span class="ot">`quot`</span> <span class="dv">2</span> <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-47" data-line-number="47">                      greedy (m <span class="fu">+</span> <span class="dv">2</span><span class="fu">*</span>q)</a>
<a class="sourceLine" id="cb12-48" data-line-number="48">                        (as <span class="fu">&lt;&gt;</span> fromFreqList [(q,a)])</a>
<a class="sourceLine" id="cb12-49" data-line-number="49">                        (fromFreqList [(k<span class="fu">-</span>q,a)] <span class="fu">&lt;&gt;</span> ds)</a>
<a class="sourceLine" id="cb12-50" data-line-number="50"></a>
<a class="sourceLine" id="cb12-51" data-line-number="51">              <span class="dt">Stretchy</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb12-52" data-line-number="52">                <span class="co">-- next tab stop</span></a>
<a class="sourceLine" id="cb12-53" data-line-number="53">                <span class="kw">let</span> n <span class="fu">=</span> tab <span class="fu">*</span> (<span class="dv">1</span> <span class="fu">+</span> quot m tab) <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-54" data-line-number="54">                <span class="kw">if</span> n <span class="fu">&gt;=</span> width</a>
<a class="sourceLine" id="cb12-55" data-line-number="55">                  <span class="kw">then</span> greedy n</a>
<a class="sourceLine" id="cb12-56" data-line-number="56">                    (as <span class="fu">&lt;&gt;</span> fromFreqList [(<span class="dv">1</span>,a)])</a>
<a class="sourceLine" id="cb12-57" data-line-number="57">                    (fromFreqList [(k<span class="fu">-</span><span class="dv">1</span>,a)] <span class="fu">&lt;&gt;</span> ds)</a>
<a class="sourceLine" id="cb12-58" data-line-number="58">                  <span class="kw">else</span> <span class="kw">let</span> capacity <span class="fu">=</span> width <span class="fu">-</span> n <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-59" data-line-number="59">                    <span class="kw">if</span> (tab<span class="fu">*</span>(k<span class="fu">-</span><span class="dv">1</span>)) <span class="fu">&lt;=</span> capacity</a>
<a class="sourceLine" id="cb12-60" data-line-number="60">                      <span class="kw">then</span> greedy (n <span class="fu">+</span> tab<span class="fu">*</span>(k<span class="fu">-</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb12-61" data-line-number="61">                        (as <span class="fu">&lt;&gt;</span> fromFreqList [(k,a)]) ds</a>
<a class="sourceLine" id="cb12-62" data-line-number="62">                      <span class="kw">else</span> <span class="kw">let</span> q <span class="fu">=</span> capacity <span class="ot">`quot`</span> tab <span class="kw">in</span></a>
<a class="sourceLine" id="cb12-63" data-line-number="63">                        greedy (n <span class="fu">+</span> tab<span class="fu">*</span>q)</a>
<a class="sourceLine" id="cb12-64" data-line-number="64">                          (as <span class="fu">&lt;&gt;</span> fromFreqList [(q<span class="fu">+</span><span class="dv">1</span>,a)])</a>
<a class="sourceLine" id="cb12-65" data-line-number="65">                          (fromFreqList [(k<span class="fu">-</span>q<span class="fu">-</span><span class="dv">1</span>,a)] <span class="fu">&lt;&gt;</span> ds)</a></code></pre></div>
<p>Then <code>takeChunks</code> repeatedly tries to take the <em>first</em> chunk, bailing out when it can’t. Note that the taken chunks must all be ‘full’ lines.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" data-line-number="1">takeChunks</a>
<a class="sourceLine" id="cb13-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoding</span> <span class="dt">Span</span></a>
<a class="sourceLine" id="cb13-3" data-line-number="3">  <span class="ot">-&gt;</span> ([<span class="dt">RunLengthEncoding</span> <span class="dt">Span</span>], <span class="dt">RunLengthEncoding</span> <span class="dt">Span</span>)</a>
<a class="sourceLine" id="cb13-4" data-line-number="4">takeChunks width tab rle <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-5" data-line-number="5">  <span class="kw">if</span> (width <span class="fu">&lt;=</span> <span class="dv">0</span>) <span class="fu">||</span> (tab <span class="fu">&lt;=</span> <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb13-6" data-line-number="6">    <span class="kw">then</span> ([], rle)</a>
<a class="sourceLine" id="cb13-7" data-line-number="7">    <span class="kw">else</span> greedy [] rle</a>
<a class="sourceLine" id="cb13-8" data-line-number="8">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb13-9" data-line-number="9">    greedy</a>
<a class="sourceLine" id="cb13-10" data-line-number="10"><span class="ot">      ::</span> [<span class="dt">RunLengthEncoding</span> <span class="dt">Span</span>]</a>
<a class="sourceLine" id="cb13-11" data-line-number="11">      <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoding</span> <span class="dt">Span</span></a>
<a class="sourceLine" id="cb13-12" data-line-number="12">      <span class="ot">-&gt;</span> ([<span class="dt">RunLengthEncoding</span> <span class="dt">Span</span>], <span class="dt">RunLengthEncoding</span> <span class="dt">Span</span>)</a>
<a class="sourceLine" id="cb13-13" data-line-number="13">    greedy xs z <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-14" data-line-number="14">      <span class="kw">case</span> takeChunk width tab z <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-15" data-line-number="15">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> (reverse xs, z)</a>
<a class="sourceLine" id="cb13-16" data-line-number="16">        <span class="dt">Just</span> (as, bs) <span class="ot">-&gt;</span> greedy (as<span class="fu">:</span>xs) bs</a></code></pre></div>
<p>Now we can define a semigroup instance on screen offsets using <code>takeChunks</code> to determine the number of lines occupied by a list of spans.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb14-2" data-line-number="2">  ( <span class="dt">IsWidth</span> w, <span class="dt">IsTab</span> t</a>
<a class="sourceLine" id="cb14-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Semigroup</span> (<span class="dt">ScreenOffset</span> w t)</a>
<a class="sourceLine" id="cb14-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-5" data-line-number="5">    x <span class="fu">&lt;&gt;</span> y <span class="fu">=</span> <span class="kw">case</span> (x,y) <span class="kw">of</span></a>
<a class="sourceLine" id="cb14-6" data-line-number="6">      (<span class="dt">NoNewlines</span> a, <span class="dt">NoNewlines</span> b) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-7" data-line-number="7">        <span class="dt">NoNewlines</span> (a <span class="fu">&lt;&gt;</span> b)</a>
<a class="sourceLine" id="cb14-8" data-line-number="8">      (<span class="dt">NoNewlines</span> a, <span class="dt">WithNewlines</span> b1 v b2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-9" data-line-number="9">        <span class="dt">WithNewlines</span> (a <span class="fu">&lt;&gt;</span> b1) v b2</a>
<a class="sourceLine" id="cb14-10" data-line-number="10">      (<span class="dt">WithNewlines</span> a1 u a2, <span class="dt">NoNewlines</span> b) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-11" data-line-number="11">        <span class="dt">WithNewlines</span> a1 u (a2 <span class="fu">&lt;&gt;</span> b)</a>
<a class="sourceLine" id="cb14-12" data-line-number="12">      (<span class="dt">WithNewlines</span> a1 u a2, <span class="dt">WithNewlines</span> b1 v b2) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb14-13" data-line-number="13">        <span class="kw">let</span></a>
<a class="sourceLine" id="cb14-14" data-line-number="14">          w <span class="fu">=</span> toWidth (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> w)</a>
<a class="sourceLine" id="cb14-15" data-line-number="15">          t <span class="fu">=</span> toTab (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> t)</a>
<a class="sourceLine" id="cb14-16" data-line-number="16">          (c1,c2) <span class="fu">=</span> takeChunks w t (a2 <span class="fu">&lt;&gt;</span> b1)</a>
<a class="sourceLine" id="cb14-17" data-line-number="17">          k <span class="fu">=</span> length c1</a>
<a class="sourceLine" id="cb14-18" data-line-number="18">        <span class="kw">in</span></a>
<a class="sourceLine" id="cb14-19" data-line-number="19">          <span class="dt">WithNewlines</span> a1 (u <span class="fu">+</span> k <span class="fu">+</span> v) b2</a>
<a class="sourceLine" id="cb14-20" data-line-number="20"></a>
<a class="sourceLine" id="cb14-21" data-line-number="21"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb14-22" data-line-number="22">  ( <span class="dt">IsWidth</span> w, <span class="dt">IsTab</span> t</a>
<a class="sourceLine" id="cb14-23" data-line-number="23">  ) <span class="ot">=&gt;</span> <span class="dt">Monoid</span> (<span class="dt">ScreenOffset</span> w t)</a>
<a class="sourceLine" id="cb14-24" data-line-number="24">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb14-25" data-line-number="25">    mempty <span class="fu">=</span> <span class="dt">NoNewlines</span> mempty</a></code></pre></div>
<p>We’re finally prepared to define a helper function for constructing screen offsets. The monoid instance is needed for this so that the value is put into canonical form at definition time.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" data-line-number="1">mkNoNewlines</a>
<a class="sourceLine" id="cb15-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">IsWidth</span> w, <span class="dt">IsTab</span> t )</a>
<a class="sourceLine" id="cb15-3" data-line-number="3">  <span class="ot">=&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Span</span>)]</a>
<a class="sourceLine" id="cb15-4" data-line-number="4">  <span class="ot">-&gt;</span> <span class="dt">ScreenOffset</span> w t</a>
<a class="sourceLine" id="cb15-5" data-line-number="5">mkNoNewlines xs <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-6" data-line-number="6">  <span class="dt">NoNewlines</span> (fromFreqList xs)</a>
<a class="sourceLine" id="cb15-7" data-line-number="7"></a>
<a class="sourceLine" id="cb15-8" data-line-number="8">mkWithNewlines</a>
<a class="sourceLine" id="cb15-9" data-line-number="9"><span class="ot">  ::</span> ( <span class="dt">IsWidth</span> w, <span class="dt">IsTab</span> t )</a>
<a class="sourceLine" id="cb15-10" data-line-number="10">  <span class="ot">=&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Span</span>)] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Span</span>)]</a>
<a class="sourceLine" id="cb15-11" data-line-number="11">  <span class="ot">-&gt;</span> <span class="dt">ScreenOffset</span> w t</a>
<a class="sourceLine" id="cb15-12" data-line-number="12">mkWithNewlines as k bs <span class="fu">=</span></a>
<a class="sourceLine" id="cb15-13" data-line-number="13">  <span class="dt">WithNewlines</span> (fromFreqList as) k (fromFreqList bs)</a></code></pre></div>
<div class="sourceCode" id="cb16"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" data-line-number="1">defNoNewlines</a>
<a class="sourceLine" id="cb16-2" data-line-number="2"><span class="ot">  ::</span> ( <span class="dt">IsWidth</span> w, <span class="dt">IsTab</span> t )</a>
<a class="sourceLine" id="cb16-3" data-line-number="3">  <span class="ot">=&gt;</span> <span class="dt">Proxy</span> w <span class="ot">-&gt;</span> <span class="dt">Proxy</span> t</a>
<a class="sourceLine" id="cb16-4" data-line-number="4">  <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Span</span>)]</a>
<a class="sourceLine" id="cb16-5" data-line-number="5">  <span class="ot">-&gt;</span> <span class="dt">ScreenOffset</span> w t</a>
<a class="sourceLine" id="cb16-6" data-line-number="6">defNoNewlines _ _ <span class="fu">=</span> mkNoNewlines</a>
<a class="sourceLine" id="cb16-7" data-line-number="7"></a>
<a class="sourceLine" id="cb16-8" data-line-number="8">defWithNewlines</a>
<a class="sourceLine" id="cb16-9" data-line-number="9"><span class="ot">  ::</span> ( <span class="dt">IsWidth</span> w, <span class="dt">IsTab</span> t )</a>
<a class="sourceLine" id="cb16-10" data-line-number="10">  <span class="ot">=&gt;</span> <span class="dt">Proxy</span> w <span class="ot">-&gt;</span> <span class="dt">Proxy</span> t</a>
<a class="sourceLine" id="cb16-11" data-line-number="11">  <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Span</span>)] <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Span</span>)]</a>
<a class="sourceLine" id="cb16-12" data-line-number="12">  <span class="ot">-&gt;</span> <span class="dt">ScreenOffset</span> w t</a>
<a class="sourceLine" id="cb16-13" data-line-number="13">defWithNewlines _ _ <span class="fu">=</span> mkWithNewlines</a></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" data-line-number="1"><span class="kw">instance</span></a>
<a class="sourceLine" id="cb17-2" data-line-number="2">  ( <span class="dt">IsWidth</span> w, <span class="dt">IsTab</span> t</a>
<a class="sourceLine" id="cb17-3" data-line-number="3">  ) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">ScreenOffset</span> w t)</a>
<a class="sourceLine" id="cb17-4" data-line-number="4">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb17-5" data-line-number="5">    show x <span class="fu">=</span> <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb17-6" data-line-number="6">      <span class="dt">NoNewlines</span> xs <span class="ot">-&gt;</span> concat</a>
<a class="sourceLine" id="cb17-7" data-line-number="7">        [ <span class="st">&quot;defNoNewlines &quot;</span></a>
<a class="sourceLine" id="cb17-8" data-line-number="8">        , showWidth (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> w), <span class="st">&quot; &quot;</span></a>
<a class="sourceLine" id="cb17-9" data-line-number="9">        , showTab (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> t), <span class="st">&quot; &quot;</span></a>
<a class="sourceLine" id="cb17-10" data-line-number="10">        , show <span class="fu">$</span> toFreqList xs</a>
<a class="sourceLine" id="cb17-11" data-line-number="11">        ]</a>
<a class="sourceLine" id="cb17-12" data-line-number="12">      <span class="dt">WithNewlines</span> as k bs <span class="ot">-&gt;</span> concat</a>
<a class="sourceLine" id="cb17-13" data-line-number="13">        [ <span class="st">&quot;defWithNewlines &quot;</span></a>
<a class="sourceLine" id="cb17-14" data-line-number="14">        , showWidth (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> w), <span class="st">&quot; &quot;</span></a>
<a class="sourceLine" id="cb17-15" data-line-number="15">        , showTab (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> t), <span class="st">&quot; &quot;</span></a>
<a class="sourceLine" id="cb17-16" data-line-number="16">        , show <span class="fu">$</span> toFreqList as, <span class="st">&quot; &quot;</span></a>
<a class="sourceLine" id="cb17-17" data-line-number="17">        , show k, <span class="st">&quot; &quot;</span></a>
<a class="sourceLine" id="cb17-18" data-line-number="18">        , show <span class="fu">$</span> toFreqList bs</a>
<a class="sourceLine" id="cb17-19" data-line-number="19">        ]</a></code></pre></div>
<h1 id="a-monoid-action-for-screen-offsets">A monoid action for screen offsets</h1>
<p>The purpose of screen offsets is to let us express <em>relative</em> positions in the terminal window, so we can (for instance) have a chunk of text and know quickly at which position the <em>following</em> chunk of text will start. First a helper for span lists:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" data-line-number="1">applyBlockOffset</a>
<a class="sourceLine" id="cb18-2" data-line-number="2"><span class="ot">  ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">RunLengthEncoding</span> <span class="dt">Span</span></a>
<a class="sourceLine" id="cb18-3" data-line-number="3">  <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb18-4" data-line-number="4">applyBlockOffset width tab rle x <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-5" data-line-number="5">  foldl f x rle</a>
<a class="sourceLine" id="cb18-6" data-line-number="6">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb18-7" data-line-number="7">    f (c,l) b <span class="fu">=</span> <span class="kw">case</span> b <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-8" data-line-number="8">      <span class="dt">Fixed0</span> <span class="ot">-&gt;</span> (c,l)</a>
<a class="sourceLine" id="cb18-9" data-line-number="9"></a>
<a class="sourceLine" id="cb18-10" data-line-number="10">      <span class="dt">Fixed1</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-11" data-line-number="11">        <span class="kw">if</span> c<span class="fu">+</span><span class="dv">1</span> <span class="fu">&gt;=</span> width</a>
<a class="sourceLine" id="cb18-12" data-line-number="12">          <span class="kw">then</span> (<span class="dv">0</span>, l<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb18-13" data-line-number="13">          <span class="kw">else</span> (c<span class="fu">+</span><span class="dv">1</span>, l)</a>
<a class="sourceLine" id="cb18-14" data-line-number="14"></a>
<a class="sourceLine" id="cb18-15" data-line-number="15">      <span class="dt">Fixed2</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-16" data-line-number="16">       <span class="kw">case</span> compare (c<span class="fu">+</span><span class="dv">2</span>) width <span class="kw">of</span></a>
<a class="sourceLine" id="cb18-17" data-line-number="17">         <span class="dt">LT</span> <span class="ot">-&gt;</span> (c<span class="fu">+</span><span class="dv">2</span>, l)</a>
<a class="sourceLine" id="cb18-18" data-line-number="18">         <span class="dt">EQ</span> <span class="ot">-&gt;</span> (<span class="dv">0</span>,   l<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb18-19" data-line-number="19">         <span class="dt">GT</span> <span class="ot">-&gt;</span> (<span class="dv">2</span>,   l<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb18-20" data-line-number="20"></a>
<a class="sourceLine" id="cb18-21" data-line-number="21">      <span class="dt">Stretchy</span> <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb18-22" data-line-number="22">        <span class="kw">let</span> n <span class="fu">=</span> tab <span class="fu">*</span> (<span class="dv">1</span> <span class="fu">+</span> quot c tab) <span class="kw">in</span></a>
<a class="sourceLine" id="cb18-23" data-line-number="23">        <span class="kw">if</span> n <span class="fu">&gt;=</span> width</a>
<a class="sourceLine" id="cb18-24" data-line-number="24">          <span class="kw">then</span> (<span class="dv">0</span>, l<span class="fu">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb18-25" data-line-number="25">          <span class="kw">else</span> (n, l)</a></code></pre></div>
<p>And now the most important function of this module after the monoid instance – applying a screen offset to a pair of screen coordinates.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode literate haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" data-line-number="1">applyScreenOffset</a>
<a class="sourceLine" id="cb19-2" data-line-number="2"><span class="ot">  ::</span> forall w t</a>
<a class="sourceLine" id="cb19-3" data-line-number="3">   <span class="fu">.</span> ( <span class="dt">IsWidth</span> w, <span class="dt">IsTab</span> t )</a>
<a class="sourceLine" id="cb19-4" data-line-number="4">  <span class="ot">=&gt;</span> <span class="dt">ScreenOffset</span> w t</a>
<a class="sourceLine" id="cb19-5" data-line-number="5">  <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>) <span class="ot">-&gt;</span> (<span class="dt">Int</span>, <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb19-6" data-line-number="6">applyScreenOffset x pos <span class="fu">=</span></a>
<a class="sourceLine" id="cb19-7" data-line-number="7">  <span class="kw">let</span></a>
<a class="sourceLine" id="cb19-8" data-line-number="8">    w <span class="fu">=</span> toWidth (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> w)</a>
<a class="sourceLine" id="cb19-9" data-line-number="9">    t <span class="fu">=</span> toTab (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> t)</a>
<a class="sourceLine" id="cb19-10" data-line-number="10">  <span class="kw">in</span></a>
<a class="sourceLine" id="cb19-11" data-line-number="11">    <span class="kw">case</span> x <span class="kw">of</span></a>
<a class="sourceLine" id="cb19-12" data-line-number="12">      <span class="dt">NoNewlines</span> cs <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb19-13" data-line-number="13">        applyBlockOffset w t cs pos</a>
<a class="sourceLine" id="cb19-14" data-line-number="14">      <span class="dt">WithNewlines</span> as k bs <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb19-15" data-line-number="15">        <span class="kw">let</span> (_,v) <span class="fu">=</span> applyBlockOffset w t as pos</a>
<a class="sourceLine" id="cb19-16" data-line-number="16">        <span class="kw">in</span> applyBlockOffset w t bs (<span class="dv">0</span>,k<span class="fu">+</span>v)</a></code></pre></div>
<p>There’s no standard type class for this, but in the tests we’ll verify that <code>applyScreenOffset</code> is a monoid action on the set of valid screen coordinates.</p>
</body>
</html>
